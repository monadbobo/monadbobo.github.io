<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL · RocksDB ·  写入逻辑的实现 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL · RocksDB ·  写入逻辑的实现</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL · RocksDB ·  写入逻辑的实现</h1><div class="post-meta">Jul 4, 2018</div><div class="post-content"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在RocksDB中，每次写入它都会先写WAL,然后再写入MemTable,这次我们就来分析这两个逻辑具体是如何实现的.<br>首先需要明确的是在RocksDB中，WAL的写入是单线程顺序串行写入的，而MemTable则是可以并发多线程写入的。</p>
<p>而在RocksDB 5.5中引进了一个选项enable_pipelined_write，这个选项的目的就是将WAL和MemTable的写入pipeline化，<br>也就是说当一个线程写完毕WAL之后，此时在WAL的write队列中等待的其他的write则会开始继续写入WAL, 而当前线程将会继续<br>写入MemTable.此时就将不同的Writer的写入WAL和写入MemTable并发执行了.</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们这里只来分析pipeline的实现，核心函数就是DBImpl::PipelinedWriteImpl.</p>
<ul>
<li><p>每一个DB(DBImpl)都有一个write_thread_(class WriteThread).</p>
</li>
<li><p>每次调用Write的时候会先写入WAL, 此时新建一个WriteThread::Writer对象，并将这个对象加入到一个Group中(调用JoinBatchGroup)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WriteThread::<span class="function">Writer <span class="title">w</span><span class="params">(write_options, my_batch, callback, log_ref,</span></span></span><br><span class="line"><span class="function"><span class="params">                        disable_memtable)</span></span>;</span><br><span class="line">write_thread_.JoinBatchGroup(&amp;w);</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们来看JoinBatchGroup,这个函数主要是用来讲所有的写入WAL加入到一个Group中.这里可以看到当当前的Writer<br>对象是leader(比如第一个进入的对象)的时候将会直接返回，否则将会等待知道更新为对应的状态．</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WriteThread::JoinBatchGroup(Writer* w) &#123;</span><br><span class="line">...................................</span><br><span class="line">  <span class="keyword">bool</span> linked_as_leader = LinkOne(w, &amp;newest_writer_);</span><br><span class="line">  <span class="keyword">if</span> (linked_as_leader) &#123;</span><br><span class="line">    SetState(w, STATE_GROUP_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TEST_SYNC_POINT_CALLBACK(<span class="string">"WriteThread::JoinBatchGroup:Wait"</span>, w);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!linked_as_leader) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wait util:</span></span><br><span class="line"><span class="comment">     * 1) An existing leader pick us as the new leader when it finishes</span></span><br><span class="line"><span class="comment">     * 2) An existing leader pick us as its follewer and</span></span><br><span class="line"><span class="comment">     * 2.1) finishes the memtable writes on our behalf</span></span><br><span class="line"><span class="comment">     * 2.2) Or tell us to finish the memtable writes in pralallel</span></span><br><span class="line"><span class="comment">     * 3) (pipelined write) An existing leader pick us as its follower and</span></span><br><span class="line"><span class="comment">     *    finish book-keeping and WAL write for us, enqueue us as pending</span></span><br><span class="line"><span class="comment">     *    memtable writer, and</span></span><br><span class="line"><span class="comment">     * 3.1) we become memtable writer group leader, or</span></span><br><span class="line"><span class="comment">     * 3.2) an existing memtable writer group leader tell us to finish memtable</span></span><br><span class="line"><span class="comment">     *      writes in parallel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    AwaitState(w, STATE_GROUP_LEADER | STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">                      STATE_PARALLEL_MEMTABLE_WRITER | STATE_COMPLETED,</span><br><span class="line">               &amp;jbg_ctx);</span><br><span class="line">    TEST_SYNC_POINT_CALLBACK(<span class="string">"WriteThread::JoinBatchGroup:DoneWaiting"</span>, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们来看LinkOne函数，这个函数主要用来讲当前的Writer对象加入到group中，这里可以看到由于<br>写入是并发的因此对应的newest_writer_(保存最新的写入对象)需要原子操作来更新.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> WriteThread::LinkOne(Writer* w, <span class="built_in">std</span>::atomic&lt;Writer*&gt;* newest_writer) &#123;</span><br><span class="line">  assert(newest_writer != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(w-&gt;state == STATE_INIT);</span><br><span class="line">  Writer* writers = newest_writer-&gt;load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    w-&gt;link_older = writers;</span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;compare_exchange_weak(writers, w)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (writers == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当从JoinBatchGroup返回之后，当当前的Writer对象为leader的话，则将会把此leader下的所有的write都<br>链接到一个WriteGroup中(调用EnterAsBatchGroupLeader函数),　并开始写入WAL,这里要注意非leader的write将会直接<br>进入memtable的写入，这是因为非leader的write都将会被当前它所从属的leader来打包(group)写入，后面我们会看到实现.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> WriteThread::EnterAsBatchGroupLeader(Writer* leader,</span><br><span class="line">                                            WriteGroup* write_group) &#123;</span><br><span class="line">  assert(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(leader-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(write_group != <span class="literal">nullptr</span>);</span><br><span class="line">................................................</span><br><span class="line">  Writer* newest_writer = newest_writer_.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is safe regardless of any db mutex status of the caller. Previous</span></span><br><span class="line">  <span class="comment">// calls to ExitAsGroupLeader either didn't call CreateMissingNewerLinks</span></span><br><span class="line">  <span class="comment">// (they emptied the list and then we added ourself as leader) or had to</span></span><br><span class="line">  <span class="comment">// explicitly wake us up (the list was non-empty when we added ourself,</span></span><br><span class="line">  <span class="comment">// so we have already received our MarkJoined).</span></span><br><span class="line">  CreateMissingNewerLinks(newest_writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tricky. Iteration start (leader) is exclusive and finish</span></span><br><span class="line">  <span class="comment">// (newest_writer) is inclusive. Iteration goes from old to new.</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">    w = w-&gt;link_newer;</span><br><span class="line">.........................................</span><br><span class="line">    w-&gt;write_group = write_group;</span><br><span class="line">    size += batch_size;</span><br><span class="line">    write_group-&gt;last_writer = w;</span><br><span class="line">    write_group-&gt;size++;</span><br><span class="line">  &#125;</span><br><span class="line">..............................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里注意到遍历是通过link_newer进行的，之所以这样做是相当于在写入WAL之前，对于当前leader的Write<br>做一次snapshot(通过CreateMissingNewerLinks函数).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WriteThread::CreateMissingNewerLinks(Writer* head) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* next = head-&gt;link_older;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || next-&gt;link_newer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      assert(next == <span class="literal">nullptr</span> || next-&gt;link_newer == head);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next-&gt;link_newer = head;</span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述操作进行完毕之后，进入写WAL操作,最终会把这个write_group打包成一个writeBatch(通过MergeBatch函数)进行写入.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (w.ShouldWriteToWAL()) &#123;</span><br><span class="line">...............................</span><br><span class="line">      w.status = WriteToWAL(wal_write_group, log_writer, log_used,</span><br><span class="line">                            need_log_sync, need_log_dir_sync, current_sequence);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当当前的leader将它自己与它的follow写入之后，此时它将需要写入memtable,那么此时之前还阻塞的Writer，分为两种情况<br>第一种是已经被当前的leader打包写入到WAL，这些writer(包括leader自己)需要将他们链接到memtable writer list.还有一种情况，那就是还没有写入WAL的，此时这类writer则需要选择一个leader然后继续写入WAL.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WriteThread::ExitAsBatchGroupLeader(WriteGroup&amp; write_group,</span><br><span class="line">                                         Status status) &#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  assert(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line">.....................................</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    <span class="comment">// Notify writers don't write to memtable to exit.</span></span><br><span class="line">......................................</span><br><span class="line">    <span class="comment">// Link the ramaining of the group to memtable writer list.</span></span><br><span class="line">    <span class="keyword">if</span> (write_group.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (LinkGroup(write_group, &amp;newest_memtable_writer_)) &#123;</span><br><span class="line">        <span class="comment">// The leader can now be different from current writer.</span></span><br><span class="line">        SetState(write_group.leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Reset newest_writer_ and wake up the next leader.</span></span><br><span class="line">    Writer* newest_writer = last_writer;</span><br><span class="line">    <span class="keyword">if</span> (!newest_writer_.compare_exchange_strong(newest_writer, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      Writer* next_leader = newest_writer;</span><br><span class="line">      <span class="keyword">while</span> (next_leader-&gt;link_older != last_writer) &#123;</span><br><span class="line">        next_leader = next_leader-&gt;link_older;</span><br><span class="line">        assert(next_leader != <span class="literal">nullptr</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      next_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">      SetState(next_leader, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line">    AwaitState(leader, STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">                           STATE_PARALLEL_MEMTABLE_WRITER | STATE_COMPLETED,</span><br><span class="line">               &amp;eabgl_ctx);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> .....................................</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来我们来看写入memtable的操作，这里逻辑类似写入WAL,如果是leader的话，则依旧会创建一个group(WriteGroup),然后遍历需要写入memtable的writer,将他们都加入到group中(EnterAsMemTableWriter),然后则设置并发执行的大小，以及设置对应状态(LaunchParallelMemTableWriters).这里注意每次setstate就将会唤醒之前阻塞的Writer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WriteThread::LaunchParallelMemTableWriters(WriteGroup* write_group) &#123;</span><br><span class="line">  assert(write_group != <span class="literal">nullptr</span>);</span><br><span class="line">  write_group-&gt;running.store(write_group-&gt;size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> w : *write_group) &#123;</span><br><span class="line">    SetState(w, STATE_PARALLEL_MEMTABLE_WRITER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里要注意，在构造memtable的group的时候，我们不需要创建link_newer，因为之前在写入WAL的时候，我们已经构造好link_newer,那么此时我们使用构造好的group也就是表示这个group中包含的都是已经写入到WAL的操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WriteThread::EnterAsMemTableWriter(Writer* leader,</span><br><span class="line">                                        WriteGroup* write_group) &#123;</span><br><span class="line">....................................</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!allow_concurrent_memtable_write_ || !leader-&gt;batch-&gt;HasMerge()) &#123;</span><br><span class="line"> ....................................................</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_group-&gt;last_writer = last_writer;</span><br><span class="line">  write_group-&gt;last_sequence =</span><br><span class="line">      last_writer-&gt;sequence + WriteBatchInternal::Count(last_writer-&gt;batch) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后开始执行写入MemTable的操作，之前在写入WAL的时候被阻塞的所有Writer此时都会进入下面这个逻辑，此时也就意味着<br>并发写入MemTable．</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (w.state == WriteThread::STATE_PARALLEL_MEMTABLE_WRITER) &#123;</span><br><span class="line">．．．．．．．．．．．．．．．．．．．．．．．．．</span><br><span class="line">    w.status = WriteBatchInternal::InsertInto(</span><br><span class="line">        &amp;w, w.sequence, &amp;column_family_memtables, &amp;flush_scheduler_,</span><br><span class="line">        write_options.ignore_missing_column_families, <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>,</span><br><span class="line">        <span class="literal">true</span> <span class="comment">/*concurrent_memtable_writes*/</span>);</span><br><span class="line">    <span class="keyword">if</span> (write_thread_.CompleteParallelMemTableWriter(&amp;w)) &#123;</span><br><span class="line">      MemTableInsertStatusCheck(w.status);</span><br><span class="line">      versions_-&gt;SetLastSequence(w.write_group-&gt;last_sequence);</span><br><span class="line">      write_thread_.ExitAsMemTableWriter(&amp;w, *w.write_group);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后当当前group的所有Writer都写入MemTable之后，则将会调用ExitAsMemTableWriter来进行收尾工作.如果有新的memtable<br>writer list需要处理，那么则唤醒对应的Writer,然后设置已经处理完毕的Writer的状态.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> WriteThread::ExitAsMemTableWriter(Writer* <span class="comment">/*self*/</span>,</span><br><span class="line">                                       WriteGroup&amp; write_group) &#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line"></span><br><span class="line">  Writer* newest_writer = last_writer;</span><br><span class="line">  <span class="keyword">if</span> (!newest_memtable_writer_.compare_exchange_strong(newest_writer,</span><br><span class="line">                                                       <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    CreateMissingNewerLinks(newest_writer);</span><br><span class="line">    Writer* next_leader = last_writer-&gt;link_newer;</span><br><span class="line">    assert(next_leader != <span class="literal">nullptr</span>);</span><br><span class="line">    next_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">    SetState(next_leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write_group.status.ok()) &#123;</span><br><span class="line">      w-&gt;status = write_group.status;</span><br><span class="line">    &#125;</span><br><span class="line">    Writer* next = w-&gt;link_newer;</span><br><span class="line">    <span class="keyword">if</span> (w != leader) &#123;</span><br><span class="line">      SetState(w, STATE_COMPLETED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (w == last_writer) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Note that leader has to exit last, since it owns the write group.</span></span><br><span class="line">  SetState(leader, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们可以看到在RocksDB中，WAL的写入始终是串行写入，而MemTable可以多线程并发写入，也就是说在系统压力到一定阶段的时候，<br>写入WAL肯定会成为瓶颈.</p>
</div><div class="tags"><a href="/tags/rocksdb/">rocksdb</a></div><div class="post-nav"><a class="pre" href="/2018/08/08/mysql-·-rocksdb-memtable-write.html">MySQL · RocksDB ·  MemTable的写入</a><a class="next" href="/2018/06/06/mysql-·-rocksdb-introduction-to-column-family.html">MySQL · RocksDB · Column Family介绍</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/redo-log-design-and-implementation-in-innodb-1.html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/mtr-minitransaction-design-and-implementation.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-·-rocksdb-data-reading-2.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-·-rocksdb-data-reading-1.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-·-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-·-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/mysql-·-rocksdb-memtable-write.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/mysql-·-rocksdb-implementation-of-write-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>