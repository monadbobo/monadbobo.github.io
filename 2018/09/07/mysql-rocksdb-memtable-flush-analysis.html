<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL · RocksDB · Memtable flush分析 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL · RocksDB · Memtable flush分析</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL · RocksDB · Memtable flush分析</h1><div class="post-meta">Sep 7, 2018</div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们知道在RocksDB中，最终数据的持久化都是保存在SST中，而SST则是由Memtable刷新到磁盘生成的，因此这次我们就主要来分析在RocksDB中何时以及如何来Flush内存数据(memtable)到SST.</p>
<p>简单来说在RocksDB中，每一个ColumnFamily都有自己的Memtable,当Memtable超过固定大小之后(或者WAL文件超过限制)，它将会被设置为immutable,然后会有后台的线程启动来刷新这个immutable memtable到磁盘(SST).</p>
<h2 id="相关设置"><a href="#相关设置" class="headerlink" title="相关设置"></a>相关设置</h2><ol>
<li>write_buffer_size　表示每个columnfamily的memtable的大小限制</li>
<li>db_write_buffer_size 总的memtable的大小限制(所有的ColumnFamily).</li>
<li>max_write_buffer_number 最大的memtable的个数</li>
<li>min_write_buffer_number_to_merge　表示最小的可以被flush的memtable的个数</li>
</ol>
<h2 id="Flush-Memtable的触发条件"><a href="#Flush-Memtable的触发条件" class="headerlink" title="Flush Memtable的触发条件"></a>Flush Memtable的触发条件</h2><p>在下面这几种条件下RocksDB会flush memtable到磁盘.</p>
<ol>
<li>当某一个memtable的大小超过write_buffer_size.</li>
<li>当总的memtable的大小超过db_write_buffer_size.</li>
<li>当WAL文件的大小超过max_total_wal_size之后<br>最后一个条件的原因是，当WAL文件大小太大之后，我们需要清理WAL,因此此时我们需要将此WAL对应的数据都刷新到磁盘，也是刷新Memtable.</li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>首先在全局的DBImpl中包含了一个flush_queue_的队列，这个队列将会保存所有的将要被flush到磁盘的ColumnFamily.只有当当前的ColumnFamily满足flush条件（cfd-&gt;imm()-&gt;IsFlushPending()）才会将此CF加入到flush队列．</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> &#123;</span></span><br><span class="line">................................</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;ColumnFamilyData*&gt; flush_queue_;</span><br><span class="line">...................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后我们来看IsFlushPending的实现．这个函数的意思就是至少有一个memtable需要被flush.而MemTableList这个类则是保存了所有的immutable memtables.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MemTableList::IsFlushPending() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((flush_requested_ &amp;&amp; num_flush_not_started_ &gt;= <span class="number">1</span>) ||</span><br><span class="line">      (num_flush_not_started_ &gt;= min_write_buffer_number_to_merge_)) &#123;</span><br><span class="line">    assert(imm_flush_needed.load(<span class="built_in">std</span>::memory_order_relaxed));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这几个变量的含义在注释中比较清楚, 而min_write_buffer_number_to_merge_就是min_write_buffer_number_to_merge．</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the number of elements that still need flushing</span></span><br><span class="line"><span class="keyword">int</span> num_flush_not_started_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// committing in progress</span></span><br><span class="line"><span class="keyword">bool</span> commit_in_progress_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requested a flush of all memtables to storage</span></span><br><span class="line"><span class="keyword">bool</span> flush_requested_;</span><br></pre></td></tr></table></figure>
<p>可以看到在SchedulePendingFlush函数中，最终会将对应的ColumnFamily加入到flush queue中.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::SchedulePendingFlush(ColumnFamilyData* cfd,</span><br><span class="line">                                  FlushReason flush_reason) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cfd-&gt;queued_for_flush() &amp;&amp; cfd-&gt;imm()-&gt;IsFlushPending()) &#123;</span><br><span class="line">    AddToFlushQueue(cfd, flush_reason);</span><br><span class="line">    ++unscheduled_flushes_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而刷新MemTable到磁盘是一个后台线程来做的，这个后台线程叫做BGWorkFlush，最终这个函数会调用BackgroundFlush函数，而BackgroundFlush主要功能是在flush_queue_中找到一个ColumnFamily然后刷新它的memtable到磁盘.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::BackgroundFlush(<span class="keyword">bool</span>* made_progress, JobContext* job_context,</span><br><span class="line">                               LogBuffer* log_buffer) &#123;</span><br><span class="line">................................</span><br><span class="line">  <span class="keyword">while</span> (!flush_queue_.empty()) &#123;</span><br><span class="line">    <span class="comment">// This cfd is already referenced</span></span><br><span class="line">    <span class="keyword">auto</span> first_cfd = PopFirstFromFlushQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first_cfd-&gt;IsDropped() || !first_cfd-&gt;imm()-&gt;IsFlushPending()) &#123;</span><br><span class="line">      <span class="comment">// can't flush this CF, try next one</span></span><br><span class="line">      <span class="keyword">if</span> (first_cfd-&gt;Unref()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> first_cfd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// found a flush!</span></span><br><span class="line">    cfd = first_cfd;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cfd != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">....................................</span><br><span class="line">    status = FlushMemTableToOutputFile(cfd, mutable_cf_options, made_progress,</span><br><span class="line">                                       job_context, log_buffer);</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;Unref()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> cfd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面可以看到最终会调用FlushMemTableToOutputFile来刷新Memtable到磁盘，等到最后我们来分析这个函数.</p>
<p>而这个刷新线程的调用是在MaybeScheduleFlushOrCompaction函数中进行的。这里可以看到刷新县城的限制是在max_flushes中设置的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::MaybeScheduleFlushOrCompaction() &#123;</span><br><span class="line">..........................................</span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = GetBGJobLimits();</span><br><span class="line">  <span class="keyword">bool</span> is_flush_pool_empty =</span><br><span class="line">      env_-&gt;GetBackgroundThreads(Env::Priority::HIGH) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!is_flush_pool_empty &amp;&amp; unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         bg_flush_scheduled_ &lt; bg_job_limits.max_flushes) &#123;</span><br><span class="line">    unscheduled_flushes_--;</span><br><span class="line">    bg_flush_scheduled_++;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWorkFlush, <span class="keyword">this</span>, Env::Priority::HIGH, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...........................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RocksDB中，有一个SwitchMemtable函数，这个函数用来将现在的memtable改变为immutable,然后再新建一个memtable,也就是说理论上来说每一次内存的memtable被刷新到磁盘之前肯定会调用这个函数．而在实现中，每一次调用SwitchMemtable之后，都会调用对应immutable　memtable的FlushRequested函数来设置对应memtable的flush_requeseted_, 并且会调用上面的SchedulePendingFlush来将对应的ColumnFamily加入到flush_queue_队列中．因此这里我们就通过这几个函数的调用栈来分析RocksDB中何时会触发flush操作.</p>
<p>在RocksDB中会有四个地方会调用SwitchMemtable,分别是:</p>
<ol>
<li>DbImpl::HandleWriteBufferFull</li>
<li>DBImpl::SwitchWAL</li>
<li>DBImpl::FlushMemTable</li>
<li>DBImpl::ScheduleFlushes</li>
</ol>
<p>接下来我们就来一个个分析这几个函数．</p>
<p>先来看HandleWriteBufferFull.这个函数主要是处理所有ColumnFamily的memtable内存超过限制的情况．可以看到它会调用SwitchMemtable然后再将对应的cfd加入到flush_queue_,最后再来调用后台刷新线程.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::HandleWriteBufferFull(WriteContext* write_context) &#123;</span><br><span class="line">...................................</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> cfd : *versions_-&gt;GetColumnFamilySet()) &#123;</span><br><span class="line">...............................</span><br><span class="line">  <span class="keyword">if</span> (cfd_picked != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = SwitchMemtable(cfd_picked, write_context,</span><br><span class="line">                            FlushReason::kWriteBufferFull);</span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      cfd_picked-&gt;imm()-&gt;FlushRequested();</span><br><span class="line">      SchedulePendingFlush(cfd_picked, FlushReason::kWriteBufferFull);</span><br><span class="line">      MaybeScheduleFlushOrCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的调用是在是在写WAL之前，也就是每次写WAL都会进行这个判断.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::PreprocessWrite(<span class="keyword">const</span> WriteOptions&amp; write_options,</span><br><span class="line">                               <span class="keyword">bool</span>* need_log_sync,</span><br><span class="line">                               WriteContext* write_context) &#123;</span><br><span class="line">..........................................</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(status.ok() &amp;&amp; write_buffer_manager_-&gt;ShouldFlush())) &#123;</span><br><span class="line">    <span class="comment">// Before a new memtable is added in SwitchMemtable(),</span></span><br><span class="line">    <span class="comment">// write_buffer_manager_-&gt;ShouldFlush() will keep returning true. If another</span></span><br><span class="line">    <span class="comment">// thread is writing to another DB with the same write buffer, they may also</span></span><br><span class="line">    <span class="comment">// be flushed. We may end up with flushing much more DBs than needed. It's</span></span><br><span class="line">    <span class="comment">// suboptimal but still correct.</span></span><br><span class="line">    status = HandleWriteBufferFull(write_context);</span><br><span class="line">  &#125;</span><br><span class="line">........................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到会调用write_buffer的shouldflush来判断是否处理bufferfull.而这个函数很简单，就是判断memtable所使用的内存是否已经超过限制.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Should only be called from write thread</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ShouldFlush</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (enabled()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mutable_memtable_memory_usage() &gt; mutable_limit_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memory_usage() &gt;= buffer_size_ &amp;&amp;</span><br><span class="line">        mutable_memtable_memory_usage() &gt;= buffer_size_ / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="comment">// If the memory exceeds the buffer size, we trigger more aggressive</span></span><br><span class="line">      <span class="comment">// flush. But if already more than half memory is being flushed,</span></span><br><span class="line">      <span class="comment">// triggering more flush may not help. We will hold it instead.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而mutable_limit_和buffer_size_的初始化在这里,这里buffer_size_就是db_write_buffer_size这个可配置的选项. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WriteBufferManager::WriteBufferManager(<span class="keyword">size_t</span> _buffer_size,</span><br><span class="line">                                       <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Cache&gt; cache)</span><br><span class="line">    : buffer_size_(_buffer_size),</span><br><span class="line">      mutable_limit_(buffer_size_ * <span class="number">7</span> / <span class="number">8</span>),</span><br></pre></td></tr></table></figure>
<p>然后我们来看mutable_memtable_memory_usage和memory_usage，这两个函数用来返回整体的write_buffer所使用的内存(memory_used_)以及将要被释放的内存(memory_active_),比如一个memory table被标记为immutable,则表示这块内存将要被释放.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Only valid if enabled()</span></span><br><span class="line"><span class="keyword">size_t</span> memory_usage() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> memory_used_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> mutable_memtable_memory_usage() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> memory_active_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来看SwitchWAL，流程和上面的HandleWriteBufferFull基本一致.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::SwitchWAL(WriteContext* write_context) &#123;</span><br><span class="line">...............................................</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> cfd : *versions_-&gt;GetColumnFamilySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;IsDropped()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;OldestLogToKeep() &lt;= oldest_alive_log) &#123;</span><br><span class="line">      status = SwitchMemtable(cfd, write_context);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cfd-&gt;imm()-&gt;FlushRequested();</span><br><span class="line">      SchedulePendingFlush(cfd, FlushReason::kWriteBufferManager);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  MaybeScheduleFlushOrCompaction();</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数被调用比较简单，就是判断是否WAL的大小是否已经超过了设置的wal大小(max_total_wal_size).可以看到它的调用也是在每次写WAL之前.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::PreprocessWrite(<span class="keyword">const</span> WriteOptions&amp; write_options,</span><br><span class="line">                               <span class="keyword">bool</span>* need_log_sync,</span><br><span class="line">                               WriteContext* write_context) &#123;</span><br><span class="line">.................................................</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(status.ok() &amp;&amp; !single_column_family_mode_ &amp;&amp;</span><br><span class="line">               total_log_size_ &gt; GetMaxTotalWalSize())) &#123;</span><br><span class="line">    status = SwitchWAL(write_context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然后是FlushMemTable，这个函数用来强制刷新刷新memtable到磁盘，比如用户直接调用Flush接口.可以看到和上面的集中情况基本一致，switchmemtable-&gt;flushrequested-&gt;maybescheduleflushorcompaction.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::FlushMemTable(ColumnFamilyData* cfd,</span><br><span class="line">                             <span class="keyword">const</span> FlushOptions&amp; flush_options,</span><br><span class="line">                             FlushReason flush_reason, <span class="keyword">bool</span> writes_stopped) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">uint64_t</span> flush_memtable_id = <span class="number">0</span>;</span><br><span class="line">  &#123;</span><br><span class="line">.........................................</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SwitchMemtable() will release and reacquire mutex during execution</span></span><br><span class="line">    s = SwitchMemtable(cfd, &amp;context);</span><br><span class="line">    flush_memtable_id = cfd-&gt;imm()-&gt;GetLatestMemTableID();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!writes_stopped) &#123;</span><br><span class="line">      write_thread_.ExitUnbatched(&amp;w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cfd-&gt;imm()-&gt;FlushRequested();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// schedule flush</span></span><br><span class="line">    SchedulePendingFlush(cfd, flush_reason);</span><br><span class="line">    MaybeScheduleFlushOrCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">...........................</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们来看最后一种情况，这种情况和前面三种有一个最大的区别就是前面三种情况的出现都是需要立即调用flush线程来刷新memtable到磁盘，而还有一种情况则是没那么紧急的情况，也就是说可以等到后面某个时间段再调用flush线程来刷新内容到磁盘.</p>
<p>在这种情况下，每一个memtable都会有一个状态叫做flush_state_,而每个memtable都有可能有三种状态.而状态的更新是通过UpdateFlushState来进行的.这里可以推测的到这些都是对于单个memtable的限制.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">enum</span> FlushStateEnum &#123; FLUSH_NOT_REQUESTED, FLUSH_REQUESTED, FLUSH_SCHEDULED &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MemTable::UpdateFlushState() &#123;</span><br><span class="line">  <span class="keyword">auto</span> state = flush_state_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (state == FLUSH_NOT_REQUESTED &amp;&amp; ShouldFlushNow()) &#123;</span><br><span class="line">    <span class="comment">// ignore CAS failure, because that means somebody else requested</span></span><br><span class="line">    <span class="comment">// a flush</span></span><br><span class="line">    flush_state_.compare_exchange_strong(state, FLUSH_REQUESTED,</span><br><span class="line">                                         <span class="built_in">std</span>::memory_order_relaxed,</span><br><span class="line">                                         <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而UpdateFlushState什么时候会被调用呢，很简单，就是当你每次操作memtable的时候，比如update/add这些操作.</p>
<p>可以看到当shoudflushnow之后，将会设置flush_state_状态为FLUSH_REQUESTED,也就是此memtable将会被flush.</p>
<p>然后来看shouldflushnow函数，这个函数主要的判断就是判断是否当前MemTable的内存使用是否超过了write_buffer_size，如果超过了，那么就返回true.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MemTable::ShouldFlushNow() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">size_t</span> write_buffer_size = write_buffer_size_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> kAllowOverAllocationRatio = <span class="number">0.6</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If arena still have room for new block allocation, we can safely say it</span></span><br><span class="line">  <span class="comment">// shouldn't flush.</span></span><br><span class="line">  <span class="keyword">auto</span> allocated_memory = table_-&gt;ApproximateMemoryUsage() +</span><br><span class="line">                          range_del_table_-&gt;ApproximateMemoryUsage() +</span><br><span class="line">                          arena_.MemoryAllocatedBytes();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if we can still allocate one more block without exceeding the</span></span><br><span class="line">  <span class="comment">// over-allocation ratio, then we should not flush.</span></span><br><span class="line">  <span class="keyword">if</span> (allocated_memory + kArenaBlockSize &lt;</span><br><span class="line">      write_buffer_size + kArenaBlockSize * kAllowOverAllocationRatio) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if user keeps adding entries that exceeds write_buffer_size, we need to</span></span><br><span class="line">  <span class="comment">// flush earlier even though we still have much available memory left.</span></span><br><span class="line">  <span class="keyword">if</span> (allocated_memory &gt;</span><br><span class="line">      write_buffer_size + kArenaBlockSize * kAllowOverAllocationRatio) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arena_.AllocatedAndUnused() &lt; kArenaBlockSize / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来看当设置了flush_state_状态之后，会做什么操作.对应的MEmtable有一个ShouldScheduleFlush函数，这个函数用来返回当前的memtable是否已经被设置flush_requested状态位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ShouldScheduleFlush</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> flush_state_.load(<span class="built_in">std</span>::memory_order_relaxed) == FLUSH_REQUESTED;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>而这个函数会在checkmemtablefull中被调用,这个函数主要用来将已经设置flush_state_为flush_requested的memtable的状态改变为flush_schedule(意思就是已经进入flush的调度队列),然后将这个columnfamily加入到对应的调度队列.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckMemtableFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flush_scheduler_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span>* cfd = cf_mems_-&gt;current();</span><br><span class="line">    assert(cfd != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;mem()-&gt;ShouldScheduleFlush() &amp;&amp;</span><br><span class="line">        cfd-&gt;mem()-&gt;MarkFlushScheduled()) &#123;</span><br><span class="line">      <span class="comment">// MarkFlushScheduled only returns true if we are the one that</span></span><br><span class="line">      <span class="comment">// should take action, so no need to dedup further</span></span><br><span class="line">      flush_scheduler_-&gt;ScheduleFlush(cfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中MarkFlushScheduled就是用来改变状态.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MarkFlushScheduled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> before = FLUSH_REQUESTED;</span><br><span class="line">  <span class="keyword">return</span> flush_state_.compare_exchange_strong(before, FLUSH_SCHEDULED,</span><br><span class="line">                                              <span class="built_in">std</span>::memory_order_relaxed,</span><br><span class="line">                                              <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而ScheduleFlush则是比较重要的一个函数，就是用来将对应的CF加入到flush调度队列(FlushScheduler).<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> FlushScheduler::ScheduleFlush(ColumnFamilyData* cfd) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">  <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(checking_mutex_);</span><br><span class="line">  assert(checking_set_.count(cfd) == <span class="number">0</span>);</span><br><span class="line">  checking_set_.insert(cfd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// NDEBUG</span></span></span><br><span class="line">  cfd-&gt;Ref();</span><br><span class="line"><span class="comment">// Suppress false positive clang analyzer warnings.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __clang_analyzer__</span></span><br><span class="line">  Node* node = <span class="keyword">new</span> Node&#123;cfd, head_.load(<span class="built_in">std</span>::memory_order_relaxed)&#125;;</span><br><span class="line">  <span class="keyword">while</span> (!head_.compare_exchange_strong(</span><br><span class="line">      node-&gt;next, node, <span class="built_in">std</span>::memory_order_relaxed, <span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="comment">// failing CAS updates the first param, so we are already set for</span></span><br><span class="line">    <span class="comment">// retry.  TakeNextColumnFamily won't happen until after another</span></span><br><span class="line">    <span class="comment">// inter-thread synchronization, so we don't even need release</span></span><br><span class="line">    <span class="comment">// semantics for this CAS</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// __clang_analyzer__</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而checkmemtablefull会在下面三种条件下被调用</p>
<ol>
<li>delete操作</li>
<li>put操作</li>
<li>merge操作.</li>
</ol>
<p>然后我们来看flushscheduler如何来调度flush线程.首先在每次写WAL之前都会调用PreprocessWrite,然后这个函数会判断flush_scheduler是否为空(也就是是否有已经满掉的memtable需要刷新到磁盘).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::PreprocessWrite(<span class="keyword">const</span> WriteOptions&amp; write_options,</span><br><span class="line">                               <span class="keyword">bool</span>* need_log_sync,</span><br><span class="line">                               WriteContext* write_context) &#123;</span><br><span class="line">..................................................................</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(status.ok() &amp;&amp; !flush_scheduler_.Empty())) &#123;</span><br><span class="line">    status = ScheduleFlushes(write_context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而在SscheduleFlushes中，则会遍历之前所有的需要被flush的memtable，然后调用switchMemtable来进行后续操作.这里要注意在SwitchMemtable也会触发调用flush线程.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::ScheduleFlushes(WriteContext* context) &#123;</span><br><span class="line">  ColumnFamilyData* cfd;</span><br><span class="line">  <span class="keyword">while</span> ((cfd = flush_scheduler_.TakeNextColumnFamily()) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> status = SwitchMemtable(cfd, context, FlushReason::kWriteBufferFull);</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;Unref()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> cfd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="刷新memtable到sst"><a href="#刷新memtable到sst" class="headerlink" title="刷新memtable到sst"></a>刷新memtable到sst</h2><p>在RocksDB中刷新是通过FlushJob这个类来实现的,整个实现还是比较简单.最终这里是调用WriteLevel0Table来刷新内容到磁盘。这里就不分析sst的格式了，需要了解具体格式的可以看RocksDB的<a href="https://github.com/facebook/rocksdb/wiki/Rocksdb-BlockBasedTable-Format" target="_blank" rel="noopener">wiki</a>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status FlushJob::Run(LogsWithPrepTracker* prep_tracker,</span><br><span class="line">                     FileMetaData* file_meta) &#123;</span><br><span class="line">...........................................</span><br><span class="line">  <span class="comment">// This will release and re-acquire the mutex.</span></span><br><span class="line">  Status s = WriteLevel0Table();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp;</span><br><span class="line">      (shutting_down_-&gt;load(<span class="built_in">std</span>::memory_order_acquire) || cfd_-&gt;IsDropped())) &#123;</span><br><span class="line">    s = Status::ShutdownInProgress(</span><br><span class="line">        <span class="string">"Database shutdown or Column family drop during flush"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    cfd_-&gt;imm()-&gt;RollbackMemtableFlush(mems_, meta_.fd.GetNumber());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TEST_SYNC_POINT(<span class="string">"FlushJob::InstallResults"</span>);</span><br><span class="line">    <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">    s = cfd_-&gt;imm()-&gt;InstallMemtableFlushResults(</span><br><span class="line">        cfd_, mutable_cf_options_, mems_, prep_tracker, versions_, db_mutex_,</span><br><span class="line">        meta_.fd.GetNumber(), &amp;job_context_-&gt;memtables_to_free, db_directory_,</span><br><span class="line">        log_buffer_);</span><br><span class="line">  &#125;</span><br><span class="line">........................................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/rocksdb/">rocksdb</a></div><div class="post-nav"><a class="pre" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a><a class="next" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>