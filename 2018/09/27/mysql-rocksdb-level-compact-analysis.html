<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL · RocksDB · Level Compact 分析 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL · RocksDB · Level Compact 分析</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL · RocksDB · Level Compact 分析</h1><div class="post-meta">Sep 27, 2018</div><div class="post-content"><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>在RocksDB中，将MemTable刷新到磁盘之后,将会有很多sstable,而这些sstable则是可能包含了相同的key的不同时间的值，这样子就会导致两个问题:</p>
<ol>
<li>浪费磁盘空间</li>
<li>读取内容将会非常慢.</li>
</ol>
<p>而compact就是用来解决上面两个问题的，简单来说compact就是读取几个sstable然后合并为一个(或者多个)sstable.<br>而什么时候合并，合并的时候如何来挑选sstable,这个就是compcation strategy.一般来说compact strategy的目的都是为了更低的amplification:</p>
<ul>
<li>避免一次读请求读取太多的sstables.<ul>
<li>读放大</li>
</ul>
</li>
<li>避免一些临时数据(deleted/overwritten/expired)在磁盘上停留时间过长</li>
<li>避免磁盘上临时空间过大<ul>
<li>空间放大</li>
</ul>
</li>
<li>避免compact相同的数据太多次<ul>
<li>写放大</li>
</ul>
</li>
</ul>
<p>而在RockDB中实现了多种<a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">compact　strategy</a>,不同的strategy有不同的侧重，这里我们只分析默认的strategy,<br>那就是leveled-N compaction.</p>
<p>在Leveled compaction中，所有的SSTables被分为很多levels(level0/1/2/3…).</p>
<ul>
<li>最新的SSTable(从memtable中刷新下来的)是属于Level0<ul>
<li>每一个SSTable都是有序的</li>
<li>只有Level0的SSTable允许overlap</li>
</ul>
</li>
<li>除了level0之外其他的level的总的SSTable大小有一个最大的限制<ul>
<li>通过level_compaction_dynamic_level_bytes来计算</li>
</ul>
</li>
<li>在Level0，如果积攒够了足够的(level0_file_num_compaction_trigger)SSTable,则就会进行compact.<ul>
<li>一般来说会把全部的SSTables compact到下一个level(Level1).</li>
<li>不会写一个很大的SSTable,</li>
</ul>
</li>
<li>一般来说百分之90的空间都是给最后一级level的.</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><h3 id="Compact运行的条件"><a href="#Compact运行的条件" class="headerlink" title="Compact运行的条件"></a>Compact运行的条件</h3><p>先来看在RocksDB中是什么时候会引起compact.在RocksDB中所有的compact都是在后台线程中进行的，这个线程就是BGWorkCompaction.这个线程只有在两种情况下被调用，一个是<br>手动compact(RunManualCompaction),一个就是自动(MaybeScheduleFlushOrCompaction),我们主要来看自动的compact,而MaybeScheduleFlushOrCompaction这个函数我们在之前介绍flush的时候已经介绍过了，简单来说就是会在切换WAL(SwitchWAL)或者writebuffer满的时候(HandleWriteBufferFull)被调用.</p>
<p>我们来看在MaybeScheduleFlushOrCompaction中compact的调用.这里可以看到RocksDB中后台运行的compact会有一个限制(max_compactions).而我们可以看到这里还有一个变量<br>unscheduled_compactions_，这个变量表示需要被compact的columnfamily的队列长度.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (bg_compaction_scheduled_ &lt; bg_job_limits.max_compactions &amp;&amp;</span><br><span class="line">       unscheduled_compactions_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  CompactionArg* ca = <span class="keyword">new</span> CompactionArg;</span><br><span class="line">  ca-&gt;db = <span class="keyword">this</span>;</span><br><span class="line">  ca-&gt;prepicked_compaction = <span class="literal">nullptr</span>;</span><br><span class="line">  bg_compaction_scheduled_++;</span><br><span class="line">  unscheduled_compactions_--;</span><br><span class="line">  env_-&gt;Schedule(&amp;DBImpl::BGWorkCompaction, ca, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                 &amp;DBImpl::UnscheduleCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似flush的逻辑，compact的时候RocksDB也有一个队列叫做DBImpl::compaction_queue_.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;ColumnFamilyData*&gt; compaction_queue_;</span><br></pre></td></tr></table></figure>
<p>然后我们来看这个队列何时被更新,其中unscheduled_compactions_和队列的更新是同步的，因此只有compaction_queue_更新之后，调用compact后台线程才会进入compact处理.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::SchedulePendingCompaction(ColumnFamilyData* cfd) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cfd-&gt;queued_for_compaction() &amp;&amp; cfd-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    AddToCompactionQueue(cfd);</span><br><span class="line">    ++unscheduled_compactions_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的核心函数是NeedsCompaction,通过这个函数来判断是否有sst需要被compact，因此接下来我们就来详细分析这个函数.当满足下列几个条件之一就将会更新compact队列</p>
<ul>
<li>有超时的sst(ExpiredTtlFiles)</li>
<li>files_marked_for_compaction_或者bottommost_files_marked_for_compaction_都不为空<ul>
<li>后面会介绍这两个队列</li>
</ul>
</li>
<li>遍历所有的level的sst,然后判断是否需要compact<ul>
<li>最核心的条件(上面两个队列都是在这里更新的).</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> LevelCompactionPicker::NeedsCompaction(</span><br><span class="line">    <span class="keyword">const</span> VersionStorageInfo* vstorage) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;ExpiredTtlFiles().empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;BottommostFilesMarkedForCompaction().empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!vstorage-&gt;FilesMarkedForCompaction().empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= vstorage-&gt;MaxInputLevel(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vstorage-&gt;CompactionScore(i) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此接下来我们来分析最核心的CompactionScore,这里将会涉及到两个变量,这两个变量分别保存了level以及每个level所对应的score(这里score越高表示compact优先级越高)，而score小于１则表示不需要compact.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; compaction_score_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; compaction_level_;</span><br></pre></td></tr></table></figure>
<p>这两个vector是在VersionStorageInfo::ComputeCompactionScore中被更新,因此我们来看这个函数，这个函数中会对level-0和其他的level区别处理。<br>首先来看level-0的处理:</p>
<ol>
<li>首先会计算level-0下所有文件的大小(total_size)以及文件个数(num_sorted_runs).</li>
<li>用文件个数除以level0_file_num_compaction_trigger来得到对应的score</li>
<li>如果当前不止一层level,那么将会从上面的score和(total_size/max_bytes_for_level_base)取最大值.</li>
</ol>
<p>之所以要做第三步，主要还是为了防止level-0的文件size过大，那么当它需要compact的时候有可能会需要和level-1 compact,那么此时就有可能会有一个很大的compact.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> num_sorted_runs = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">uint64_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span>* f : files_[level]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!f-&gt;being_compacted) &#123;</span><br><span class="line">          total_size += f-&gt;compensated_file_size;</span><br><span class="line">          num_sorted_runs++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">.........................</span><br><span class="line">      score = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(num_sorted_runs) /</span><br><span class="line">                mutable_cf_options.level0_file_num_compaction_trigger;</span><br><span class="line">        <span class="keyword">if</span> (compaction_style_ == kCompactionStyleLevel &amp;&amp; num_levels() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          score = <span class="built_in">std</span>::max(</span><br><span class="line">              score, <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(total_size) /</span><br><span class="line">                     mutable_cf_options.max_bytes_for_level_base);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>然后是非level-0的处理,这里也是计算level的文件大小然后再除以MaxBytesForLevel，然后得到当前level的score.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> level_bytes_no_compacting = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> f : files_[level]) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!f-&gt;being_compacted) &#123;</span><br><span class="line">    level_bytes_no_compacting += f-&gt;compensated_file_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">score = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes_no_compacting) /</span><br><span class="line">        MaxBytesForLevel(level);</span><br></pre></td></tr></table></figure></p>
<p>上面我们看到有一个MaxBytesForLevel,这个函数的作用就是得到当前level的最大的文件大小.而这个函数实现也很简单.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> VersionStorageInfo::MaxBytesForLevel(<span class="keyword">int</span> level) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(level_max_bytes_.size()));</span><br><span class="line">  <span class="keyword">return</span> level_max_bytes_[level];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到核心就是level_max_bytes_这个数组，接下来我们就来看这个数组是在哪里被初始化的。level_max_bytes这个数组是在VersionStorageInfo::CalculateBaseBytes<br>这个函数中被初始化，这里RocksDB有一个option叫做level_compaction_dynamic_level_bytes,这个配置如果被设置，那么level_max_bytes将会这样<br>设置(这里我们只关注level):</p>
<ul>
<li>如果是level-1那么level-1的的文件大小限制为options.max_bytes_for_level_base.</li>
<li>如果level大于1那么当前level-i的大小限制为(其中max_bytes这两个变量都是options中设置的)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target_Size(Ln+1) = Target_Size(Ln) * max_bytes_for_level_multiplier * max_bytes_for_level_multiplier_additional[n].</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>举个例子,如果max_bytes_for_level_base=1024,max_bytes_for_level_multiplier=10,然后max_bytes_for_level_multiplier_additional未设置，那么L1,<br>L2,L3的大小限制分别为1024,10240,102400.</p>
<p>下面是对应代码.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ioptions.level_compaction_dynamic_level_bytes) &#123;</span><br><span class="line">  base_level_ = (ioptions.compaction_style == kCompactionStyleLevel) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Calculate for static bytes base case</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ioptions.num_levels; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ioptions.compaction_style == kCompactionStyleUniversal) &#123;</span><br><span class="line">      level_max_bytes_[i] = options.max_bytes_for_level_base;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      level_max_bytes_[i] = MultiplyCheckOverflow(</span><br><span class="line">          MultiplyCheckOverflow(level_max_bytes_[i - <span class="number">1</span>],</span><br><span class="line">                                options.max_bytes_for_level_multiplier),</span><br><span class="line">          options.MaxBytesMultiplerAdditional(i - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      level_max_bytes_[i] = options.max_bytes_for_level_base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来看如果设置了level_compaction_dynamic_level_bytes会如何来计算.如果设置了dynamic,那么就说明每次计算出来的每个level的最大值都是不一样的,<br>首先我们要知道调用CalculateBaseBytes是在每次创建version的时候。因此他是这样计算的.最大的level(num_levels -1 )的大小限制是不计入计算的，然后就是这样计算.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Target_Size(Ln-1) = Target_Size(Ln) / max_bytes_for_level_multiplier</span><br></pre></td></tr></table></figure></p>
<p>举个例子，假设调用CalculateBaseBytes的时候，max_bytes_for_level_base是1G,然后num_levels = 6，然后当前最大的level的大小为256G,那么从L1-L6的大小是<br> 0, 0, 0.276GB, 2.76GB, 27.6GB 和 276GB.</p>
<p>首先计算第一个非空的level.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num_levels_; i++) &#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> total_size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; f : files_[i]) &#123;</span><br><span class="line">    total_size += f-&gt;fd.GetFileSize();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (total_size &gt; <span class="number">0</span> &amp;&amp; first_non_empty_level == <span class="number">-1</span>) &#123;</span><br><span class="line">    first_non_empty_level = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (total_size &gt; max_level_size) &#123;</span><br><span class="line">    max_level_size = total_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得到最小的那个非0的level的size.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> base_bytes_max = options.max_bytes_for_level_base;</span><br><span class="line"><span class="keyword">uint64_t</span> base_bytes_min = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(</span><br><span class="line">    base_bytes_max / options.max_bytes_for_level_multiplier);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try whether we can make last level's target size to be max_level_size</span></span><br><span class="line"><span class="keyword">uint64_t</span> cur_level_size = max_level_size;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = num_levels_ - <span class="number">2</span>; i &gt;= first_non_empty_level; i--) &#123;</span><br><span class="line">  <span class="comment">// Round up after dividing</span></span><br><span class="line">  cur_level_size = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(</span><br><span class="line">      cur_level_size / options.max_bytes_for_level_multiplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到base_level_size，一般来说也就是cur_level_size.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find base level (where L0 data is compacted to).</span></span><br><span class="line">base_level_ = first_non_empty_level;</span><br><span class="line"><span class="keyword">while</span> (base_level_ &gt; <span class="number">1</span> &amp;&amp; cur_level_size &gt; base_bytes_max) &#123;</span><br><span class="line">  --base_level_;</span><br><span class="line">  cur_level_size = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(</span><br><span class="line">      cur_level_size / options.max_bytes_for_level_multiplier);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_level_size &gt; base_bytes_max) &#123;</span><br><span class="line">  <span class="comment">// Even L1 will be too large</span></span><br><span class="line">  assert(base_level_ == <span class="number">1</span>);</span><br><span class="line">  base_level_size = base_bytes_max;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  base_level_size = cur_level_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后给level_max_bytes_ 赋值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint64_t</span> level_size = base_level_size;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = base_level_; i &lt; num_levels_; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; base_level_) &#123;</span><br><span class="line">      level_size = MultiplyCheckOverflow(</span><br><span class="line">          level_size, options.max_bytes_for_level_multiplier);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't set any level below base_bytes_max. Otherwise, the LSM can</span></span><br><span class="line">    <span class="comment">// assume an hourglass shape where L1+ sizes are smaller than L0. This</span></span><br><span class="line">    <span class="comment">// causes compaction scoring, which depends on level sizes, to favor L1+</span></span><br><span class="line">    <span class="comment">// at the expense of L0, which may fill up and stall.</span></span><br><span class="line">    level_max_bytes_[i] = <span class="built_in">std</span>::max(level_size, base_bytes_max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Compact实现细节"><a href="#Compact实现细节" class="headerlink" title="Compact实现细节"></a>Compact实现细节</h3><p>分析完毕何时会触发Compact,那么我们接下来来分析如何Compact.其中Compact的所有操作都在DBImpl::BackgroundCompaction中进行，因此接下来我们来分析<br>这个函数.<br>首先是从compaction_queue_队列中读取第一个需要compact的column family.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cfd is referenced here</span></span><br><span class="line"><span class="keyword">auto</span> cfd = PopFirstFromCompactionQueue();</span><br><span class="line"><span class="comment">// We unreference here because the following code will take a Ref() on</span></span><br><span class="line"><span class="comment">// this cfd if it is going to use it (Compaction class holds a</span></span><br><span class="line"><span class="comment">// reference).</span></span><br><span class="line"><span class="comment">// This will all happen under a mutex so we don't have to be afraid of</span></span><br><span class="line"><span class="comment">// somebody else deleting it.</span></span><br><span class="line"><span class="keyword">if</span> (cfd-&gt;Unref()) &#123;</span><br><span class="line">  <span class="keyword">delete</span> cfd;</span><br><span class="line">  <span class="comment">// This was the last reference of the column family, so no need to</span></span><br><span class="line">  <span class="comment">// compact.</span></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是选取当前CF中所需要compact的内容.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.reset(cfd-&gt;PickCompaction(*mutable_cf_options, log_buffer));</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看到PickCompaction这个函数，而这个函数会根据设置的不同的Compact策略调用不同的方法，这里我们只看默认的LevelCompact的对应函数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compaction* LevelCompactionBuilder::PickCompaction() &#123;</span><br><span class="line">  <span class="comment">// Pick up the first file to start compaction. It may have been extended</span></span><br><span class="line">  <span class="comment">// to a clean cut.</span></span><br><span class="line">  SetupInitialFiles();</span><br><span class="line">  <span class="keyword">if</span> (start_level_inputs_.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(start_level_ &gt;= <span class="number">0</span> &amp;&amp; output_level_ &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If it is a L0 -&gt; base level compaction, we need to set up other L0</span></span><br><span class="line">  <span class="comment">// files if needed.</span></span><br><span class="line">  <span class="keyword">if</span> (!SetupOtherL0FilesIfNeeded()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick files in the output level and expand more files in the start level</span></span><br><span class="line">  <span class="comment">// if needed.</span></span><br><span class="line">  <span class="keyword">if</span> (!SetupOtherInputsIfNeeded()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Form a compaction object containing the files we picked.</span></span><br><span class="line">  Compaction* c = GetCompaction();</span><br><span class="line"></span><br><span class="line">  TEST_SYNC_POINT_CALLBACK(<span class="string">"LevelCompactionPicker::PickCompaction:Return"</span>, c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里PickCompaction分别调用了三个主要的函数.</p>
<ul>
<li>SetupInitialFiles　这个函数主要用来初始化需要Compact的文件.</li>
<li>SetupOtherL0FilesIfNeeded 如果需要compact的话，那么还需要再设置对应的L0文件</li>
<li>SetupOtherInputsIfNeeded 选择对应的输出文件</li>
</ul>
<p>先来看SetupInitialFiles,这个函数他会遍历所有的level,然后来选择对应需要compact的input和output.</p>
<p>这里可看到，他会从之前计算好的的compact信息中得到对应的score.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LevelCompactionBuilder::SetupInitialFiles() &#123;</span><br><span class="line">  <span class="comment">// Find the compactions by size on all levels.</span></span><br><span class="line">  <span class="keyword">bool</span> skipped_l0_to_base = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compaction_picker_-&gt;NumberLevels() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    start_level_score_ = vstorage_-&gt;CompactionScore(i);</span><br><span class="line">    start_level_ = vstorage_-&gt;CompactionScoreLevel(i);</span><br><span class="line">    assert(i == <span class="number">0</span> || start_level_score_ &lt;= vstorage_-&gt;CompactionScore(i - <span class="number">1</span>));</span><br><span class="line">................................................................</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当score大于一才有必要进行compact的处理(所有操作都在上面的循环中).这里可以看到如果是level0的话，那么output_level<br>则是vstorage_-&gt;base_level(),否则就是level+1.<br>这里base_level()可以认为就是level1或者是最小的非空的level(之前CalculateBaseBytes中计算).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start_level_score_ &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (skipped_l0_to_base &amp;&amp; start_level_ == vstorage_-&gt;base_level()) &#123;</span><br><span class="line">        <span class="comment">// If L0-&gt;base_level compaction is pending, don't schedule further</span></span><br><span class="line">        <span class="comment">// compaction from base level. Otherwise L0-&gt;base_level compaction</span></span><br><span class="line">        <span class="comment">// may starve.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      output_level_ =</span><br><span class="line">          (start_level_ == <span class="number">0</span>) ? vstorage_-&gt;base_level() : start_level_ + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (PickFileToCompact()) &#123;</span><br><span class="line">        <span class="comment">// found the compaction!</span></span><br><span class="line">        <span class="keyword">if</span> (start_level_ == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// L0 score = `num L0 files` / `level0_file_num_compaction_trigger`</span></span><br><span class="line">          compaction_reason_ = CompactionReason::kLevelL0FilesNum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// L1+ score = `Level files size` / `MaxBytesForLevel`</span></span><br><span class="line">          compaction_reason_ = CompactionReason::kLevelMaxLevelSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// didn't find the compaction, clear the inputs</span></span><br><span class="line">  ......................................................</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们可以看到最终是通过PickFileToCompact来选择input以及output文件.因此我们接下来就来分这个函数.</p>
<p>首先是得到当前level(start_level_)的未compacted的最大大小的文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pick the largest file in this level that is not already</span></span><br><span class="line"><span class="comment">// being compacted</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; file_size =</span><br><span class="line">    vstorage_-&gt;FilesByCompactionPri(start_level_);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files =</span><br><span class="line">    vstorage_-&gt;LevelFiles(start_level_);</span><br></pre></td></tr></table></figure></p>
<p>紧接着就是这个函数最核心的功能了，它会开始遍历当前的输入level的所有待compact的文件，然后选择一些合适的文件然后compact到下一个level.</p>
<ul>
<li><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cmp_idx;</span><br><span class="line">  <span class="keyword">for</span> (cmp_idx = vstorage_-&gt;NextCompactionIndex(start_level_);</span><br><span class="line">       cmp_idx &lt; file_size.size(); cmp_idx++) &#123;</span><br><span class="line">..........................................    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后我们来详细分析上面循环中所做的事情<br>首先选择好文件之后，将会扩展当前文件的key的范围，得到一个”clean cut”的范围，<br>这里”clean cut”是这个意思，假设我们有五个文件他们的key range分别为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1[a1 a2] f2[a3 a4] f3[a4 a6] f4[a6 a7] f5[a8 a9]</span><br></pre></td></tr></table></figure></p>
<p>如果我们第一次选择了f3,那么我们通过clean cut，则将还会选择f2,f4，因为他们都是连续的.<br>选择好之后，会再做一次判断，这次是判断是否正在compact的out_level的文件范围是否和我们选择好的文件的key有重合，如果有，则跳过这个文件.<br>这里之所以会有这个判断，主要原因还是因为compact是会并行的执行的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = file_size[cmp_idx];</span><br><span class="line">    <span class="keyword">auto</span>* f = level_files[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do not pick a file to compact if it is being compacted</span></span><br><span class="line">    <span class="comment">// from n-1 level.</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;being_compacted) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_level_inputs_.files.push_back(f);</span><br><span class="line">    start_level_inputs_.level = start_level_;</span><br><span class="line">    <span class="keyword">if</span> (!compaction_picker_-&gt;ExpandInputsToCleanCut(cf_name_, vstorage_,</span><br><span class="line">                                                    &amp;start_level_inputs_) ||</span><br><span class="line">        compaction_picker_-&gt;FilesRangeOverlapWithCompaction(</span><br><span class="line">            &#123;start_level_inputs_&#125;, output_level_)) &#123;</span><br><span class="line">      <span class="comment">// A locked (pending compaction) input-level file was pulled in due to</span></span><br><span class="line">      <span class="comment">// user-key overlap.</span></span><br><span class="line">      start_level_inputs_.clear();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>选择好输入文件之后，接下来就是选择输出level中需要一起被compact的文件(output_level_inputs).<br>实现也是比较简单，就是从输出level的所有文件中找到是否有和上面选择好的input中有重合的文件，如果有，那么则需要一起进行compact.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InternalKey smallest, largest;</span><br><span class="line">compaction_picker_-&gt;GetRange(start_level_inputs_, &amp;smallest, &amp;largest);</span><br><span class="line">CompactionInputFiles output_level_inputs;</span><br><span class="line">output_level_inputs.level = output_level_;</span><br><span class="line">vstorage_-&gt;GetOverlappingInputs(output_level_, &amp;smallest, &amp;largest,</span><br><span class="line">                                &amp;output_level_inputs.files);</span><br><span class="line"><span class="keyword">if</span> (!output_level_inputs.empty() &amp;&amp;</span><br><span class="line">    !compaction_picker_-&gt;ExpandInputsToCleanCut(cf_name_, vstorage_,</span><br><span class="line">                                                &amp;output_level_inputs)) &#123;</span><br><span class="line">  start_level_inputs_.clear();</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">base_index_ = index;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>继续分析PickCompaction，我们知道在RocksDB中level-0会比较特殊，那是因为只有level-0中的文件是无序的，而在上面的操作中，<br>我们是假设在非level-0,因此接下来我们需要处理level-0的情况,这个函数就是SetupOtherL0FilesIfNeeded.</p>
<p>这里如果start_level_为０，也就是level-0的话，才会进行下面的处理，就是从level-0中得到所有的重合key的文件，然后加入到start_level_inputs中.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">if (start_level_ == 0 &amp;&amp; output_level_ != 0) &#123;</span><br><span class="line">  // Two level 0 compaction won&apos;t run at the same time, so don&apos;t need to worry</span><br><span class="line">  // about files on level 0 being compacted.</span><br><span class="line">  assert(compaction_picker_-&gt;level0_compactions_in_progress()-&gt;empty());</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  compaction_picker_-&gt;GetRange(start_level_inputs_, &amp;smallest, &amp;largest);</span><br><span class="line">  // Note that the next call will discard the file we placed in</span><br><span class="line">  // c-&gt;inputs_[0] earlier and replace it with an overlapping set</span><br><span class="line">  // which will include the picked file.</span><br><span class="line">  start_level_inputs_.files.clear();</span><br><span class="line">  vstorage_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest,</span><br><span class="line">                                  &amp;start_level_inputs_.files);</span><br><span class="line"></span><br><span class="line">  // If we include more L0 files in the same compaction run it can</span><br><span class="line">  // cause the &apos;smallest&apos; and &apos;largest&apos; key to get extended to a</span><br><span class="line">  // larger range. So, re-invoke GetRange to get the new key range</span><br><span class="line">  compaction_picker_-&gt;GetRange(start_level_inputs_, &amp;smallest, &amp;largest);</span><br><span class="line">  if (compaction_picker_-&gt;IsRangeInCompaction(</span><br><span class="line">          vstorage_, &amp;smallest, &amp;largest, output_level_, &amp;parent_index_)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设start_level_inputs被扩展了，那么对应的output也需要被扩展，因为非level0的其他的level的文件key都是不会overlap的.<br>那么此时就是会调用SetupOtherInputsIfNeeded.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (output_level_ != <span class="number">0</span>) &#123;</span><br><span class="line">  output_level_inputs_.level = output_level_;</span><br><span class="line">  <span class="keyword">if</span> (!compaction_picker_-&gt;SetupOtherInputs(</span><br><span class="line">          cf_name_, mutable_cf_options_, vstorage_, &amp;start_level_inputs_,</span><br><span class="line">          &amp;output_level_inputs_, &amp;parent_index_, base_index_)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compaction_inputs_.push_back(start_level_inputs_);</span><br><span class="line">  <span class="keyword">if</span> (!output_level_inputs_.empty()) &#123;</span><br><span class="line">    compaction_inputs_.push_back(output_level_inputs_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In some edge cases we could pick a compaction that will be compacting</span></span><br><span class="line">  <span class="comment">// a key range that overlap with another running compaction, and both</span></span><br><span class="line">  <span class="comment">// of them have the same output level. This could happen if</span></span><br><span class="line">  <span class="comment">// (1) we are running a non-exclusive manual compaction</span></span><br><span class="line">  <span class="comment">// (2) AddFile ingest a new file into the LSM tree</span></span><br><span class="line">  <span class="comment">// We need to disallow this from happening.</span></span><br><span class="line">  <span class="keyword">if</span> (compaction_picker_-&gt;FilesRangeOverlapWithCompaction(compaction_inputs_,</span><br><span class="line">                                                          output_level_)) &#123;</span><br><span class="line">    <span class="comment">// This compaction output could potentially conflict with the output</span></span><br><span class="line">    <span class="comment">// of a currently running compaction, we cannot run it.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  compaction_picker_-&gt;GetGrandparents(vstorage_, start_level_inputs_,</span><br><span class="line">                                      output_level_inputs_, &amp;grandparents_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是构造一个compact然后返回.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Form a compaction object containing the files we picked.</span></span><br><span class="line">Compaction* c = GetCompaction();</span><br><span class="line"></span><br><span class="line">TEST_SYNC_POINT_CALLBACK(<span class="string">"LevelCompactionPicker::PickCompaction:Return"</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c;</span><br></pre></td></tr></table></figure></p>
<p>最后再回到BackgroundCompaction中，这里就是在得到需要compact的文件之后，进行具体的compact.<br>这里我们可以看到核心的数据结构就是CompactionJob,每一次的compact都是一个job,最终对于文件的compact都是在<br>CompactionJob::run中实现.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompactionJob <span class="title">compaction_job</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        job_context-&gt;job_id, c.get(), immutable_db_options_,</span></span></span><br><span class="line"><span class="function"><span class="params">        env_options_for_compaction_, versions_.get(), &amp;shutting_down_,</span></span></span><br><span class="line"><span class="function"><span class="params">        preserve_deletes_seqnum_.load(), log_buffer, directories_.GetDbDir(),</span></span></span><br><span class="line"><span class="function"><span class="params">        GetDataDir(c-&gt;column_family_data(), c-&gt;output_path_id()), stats_,</span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;mutex_, &amp;bg_error_, snapshot_seqs, earliest_write_conflict_snapshot,</span></span></span><br><span class="line"><span class="function"><span class="params">        snapshot_checker, table_cache_, &amp;event_logger_,</span></span></span><br><span class="line"><span class="function"><span class="params">        c-&gt;mutable_cf_options()-&gt;paranoid_file_checks,</span></span></span><br><span class="line"><span class="function"><span class="params">        c-&gt;mutable_cf_options()-&gt;report_bg_io_stats, dbname_,</span></span></span><br><span class="line"><span class="function"><span class="params">        &amp;compaction_job_stats)</span></span>;</span><br><span class="line">    compaction_job.Prepare();</span><br><span class="line"></span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    compaction_job.Run();</span><br><span class="line">    TEST_SYNC_POINT(<span class="string">"DBImpl::BackgroundCompaction:NonTrivial:AfterRun"</span>);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    status = compaction_job.Install(*c-&gt;mutable_cf_options());</span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      InstallSuperVersionAndScheduleWork(</span><br><span class="line">          c-&gt;column_family_data(), &amp;job_context-&gt;superversion_context,</span><br><span class="line">          *c-&gt;mutable_cf_options(), FlushReason::kAutoCompaction);</span><br><span class="line">    &#125;</span><br><span class="line">    *made_progress = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>在RocksDB中，Compact是会多线程并发的执行，而这里怎样并发，并发多少线程都是在CompactionJob中实现的，简单来说，当你的compact的文件range不重合的话，那么都是可以并发执行的。</p>
<p>我们先来看CompactionJob::Prepare函数，在这个函数中主要是做一些执行前的准备工作，首先是取得对应的compact的边界，这里每一个需要并发的compact都被抽象为一个sub compaction.因此在GenSubcompactionBoundaries会解析到对应的sub compaction以及边界.解析完毕之后，则将会把对应的信息全部加入sub_compact_states中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CompactionJob::Prepare() &#123;</span><br><span class="line">  ..........................</span><br><span class="line">  <span class="keyword">if</span> (c-&gt;ShouldFormSubcompactions()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">    GenSubcompactionBoundaries();</span><br><span class="line">    MeasureTime(stats_, SUBCOMPACTION_SETUP_TIME,</span><br><span class="line">                env_-&gt;NowMicros() - start_micros);</span><br><span class="line"></span><br><span class="line">    assert(sizes_.size() == boundaries_.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt;= boundaries_.size(); i++) &#123;</span><br><span class="line">      Slice* start = i == <span class="number">0</span> ? <span class="literal">nullptr</span> : &amp;boundaries_[i - <span class="number">1</span>];</span><br><span class="line">      Slice* end = i == boundaries_.size() ? <span class="literal">nullptr</span> : &amp;boundaries_[i];</span><br><span class="line">      compact_-&gt;sub_compact_states.emplace_back(c, start, end, sizes_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    MeasureTime(stats_, NUM_SUBCOMPACTIONS_SCHEDULED,</span><br><span class="line">                compact_-&gt;sub_compact_states.size());</span><br><span class="line">  &#125;</span><br><span class="line">......................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此我们来详细分析GenSubcompactionBoundaries，这个函数比较长，我们来分开分析，首先是遍历所有的需要compact的level,然后取得每一个level的边界(也就是最大最小key)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CompactionJob::GenSubcompactionBoundaries() &#123;</span><br><span class="line">...........................</span><br><span class="line">  <span class="comment">// Add the starting and/or ending key of certain input files as a potential</span></span><br><span class="line">  <span class="comment">// boundary</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> lvl_idx = <span class="number">0</span>; lvl_idx &lt; c-&gt;num_input_levels(); lvl_idx++) &#123;</span><br><span class="line">    <span class="keyword">int</span> lvl = c-&gt;level(lvl_idx);</span><br><span class="line">    <span class="keyword">if</span> (lvl &gt;= start_lvl &amp;&amp; lvl &lt;= out_lvl) &#123;</span><br><span class="line">      <span class="keyword">const</span> LevelFilesBrief* flevel = c-&gt;input_levels(lvl_idx);</span><br><span class="line">      <span class="keyword">size_t</span> num_files = flevel-&gt;num_files;</span><br><span class="line">.....................</span><br><span class="line">      <span class="keyword">if</span> (lvl == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// For level 0 add the starting and ending key of each file since the</span></span><br><span class="line">        <span class="comment">// files may have greatly differing key ranges (not range-partitioned)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">          bounds.emplace_back(flevel-&gt;files[i].smallest_key);</span><br><span class="line">          bounds.emplace_back(flevel-&gt;files[i].largest_key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For all other levels add the smallest/largest key in the level to</span></span><br><span class="line">        <span class="comment">// encompass the range covered by that level</span></span><br><span class="line">        bounds.emplace_back(flevel-&gt;files[<span class="number">0</span>].smallest_key);</span><br><span class="line">        bounds.emplace_back(flevel-&gt;files[num_files - <span class="number">1</span>].largest_key);</span><br><span class="line">        <span class="keyword">if</span> (lvl == out_lvl) &#123;</span><br><span class="line">          <span class="comment">// For the last level include the starting keys of all files since</span></span><br><span class="line">          <span class="comment">// the last level is the largest and probably has the widest key</span></span><br><span class="line">          <span class="comment">// range. Since it's range partitioned, the ending key of one file</span></span><br><span class="line">          <span class="comment">// and the starting key of the next are very close (or identical).</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; num_files; i++) &#123;</span><br><span class="line">            bounds.emplace_back(flevel-&gt;files[i].smallest_key);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">......................</span><br></pre></td></tr></table></figure>
<p>然后则是对取得的bounds进行排序以及去重.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(bounds.begin(), bounds.end(),</span><br><span class="line">          [cfd_comparator](<span class="keyword">const</span> Slice&amp; a, <span class="keyword">const</span> Slice&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cfd_comparator-&gt;Compare(ExtractUserKey(a),</span><br><span class="line">                                           ExtractUserKey(b)) &lt; <span class="number">0</span>;</span><br><span class="line">          &#125;);</span><br><span class="line"><span class="comment">// Remove duplicated entries from bounds</span></span><br><span class="line">bounds.erase(</span><br><span class="line">    <span class="built_in">std</span>::unique(bounds.begin(), bounds.end(),</span><br><span class="line">                [cfd_comparator](<span class="keyword">const</span> Slice&amp; a, <span class="keyword">const</span> Slice&amp; b) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> cfd_comparator-&gt;Compare(ExtractUserKey(a),</span><br><span class="line">                                                 ExtractUserKey(b)) == <span class="number">0</span>;</span><br><span class="line">                &#125;),</span><br><span class="line">    bounds.end());</span><br></pre></td></tr></table></figure>
<p>接近着就来计算理想情况下所需要的subcompactions的个数以及输出文件的个数.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group the ranges into subcompactions</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> min_file_fill_percent = <span class="number">4.0</span> / <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> base_level = v-&gt;storage_info()-&gt;base_level();</span><br><span class="line"><span class="keyword">uint64_t</span> max_output_files = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="built_in">std</span>::<span class="built_in">ceil</span>(</span><br><span class="line">    sum / min_file_fill_percent /</span><br><span class="line">    MaxFileSizeForLevel(*(c-&gt;mutable_cf_options()), out_lvl,</span><br><span class="line">        c-&gt;immutable_cf_options()-&gt;compaction_style, base_level,</span><br><span class="line">        c-&gt;immutable_cf_options()-&gt;level_compaction_dynamic_level_bytes)));</span><br><span class="line"><span class="keyword">uint64_t</span> subcompactions =</span><br><span class="line">    <span class="built_in">std</span>::min(&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(ranges.size()),</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(c-&gt;max_subcompactions()),</span><br><span class="line">              max_output_files&#125;);</span><br></pre></td></tr></table></figure></p>
<p>最后更新boundaries_，这里会根据根据文件的大小，通过平均的size,来吧所有的range分为几份，最终这些都会保存在boundaries_中.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (subcompactions &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">double</span> mean = sum * <span class="number">1.0</span> / subcompactions;</span><br><span class="line">  <span class="comment">// Greedily add ranges to the subcompaction until the sum of the ranges'</span></span><br><span class="line">  <span class="comment">// sizes becomes &gt;= the expected mean size of a subcompaction</span></span><br><span class="line">  sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ranges.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    sum += ranges[i].size;</span><br><span class="line">    <span class="keyword">if</span> (subcompactions == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// If there's only one left to schedule then it goes to the end so no</span></span><br><span class="line">      <span class="comment">// need to put an end boundary</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= mean) &#123;</span><br><span class="line">      boundaries_.emplace_back(ExtractUserKey(ranges[i].range.limit));</span><br><span class="line">      sizes_.emplace_back(sum);</span><br><span class="line">      subcompactions--;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sizes_.emplace_back(sum + ranges.back().size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们来看CompactJob::Run的实现,在这个函数中，就是会遍历所有的sub_compact,然后启动线程来进行对应的compact工作，最后等到所有的线程完成，然后退出.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch a thread for each of subcompactions 1...num_threads-1</span></span><br><span class="line"> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;port::Thread&gt; thread_pool;</span><br><span class="line"> thread_pool.reserve(num_threads - <span class="number">1</span>);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; compact_-&gt;sub_compact_states.size(); i++) &#123;</span><br><span class="line">   thread_pool.emplace_back(&amp;CompactionJob::ProcessKeyValueCompaction, <span class="keyword">this</span>,</span><br><span class="line">                            &amp;compact_-&gt;sub_compact_states[i]);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Always schedule the first subcompaction (whether or not there are also</span></span><br><span class="line"> <span class="comment">// others) in the current thread to be efficient with resources</span></span><br><span class="line"> ProcessKeyValueCompaction(&amp;compact_-&gt;sub_compact_states[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Wait for all other threads (if there are any) to finish execution</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : thread_pool) &#123;</span><br><span class="line">   thread.join();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (output_directory_) &#123;</span><br><span class="line">   output_directory_-&gt;Fsync();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最后我们可以看到最终compact工作是在CompactionJob::ProcessKeyValueCompaction是实现的，这个函数我们暂时就不分析了，我们只需要知道所有的compact工作都是在这个函数中执行的.</p>
</div><div class="tags"><a href="/tags/rocksdb/">rocksdb</a></div><div class="post-nav"><a class="pre" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a><a class="next" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>