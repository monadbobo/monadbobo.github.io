<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>pagefault | 但行好事 莫問前程</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">pagefault</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2011/09/18/c-reference-manual-reading-notes-(4).html">c reference manual读书笔记(四)</a></h1><div class="post-meta">2011-09-18</div><div class="post-content"><p>主要是介绍c语言中的类型</p>
<p>1 c语言里面分为数值类型(Arithmetic，包括整数，浮点.enum 等),指针类型，数组类型，结构类型，联合类型，函数类型以及void类型。c99中添加了_Bool _Complex _Imaginary三种新的类型。</p>
<p>2 标准c只定义了整数类型的最小精度。char至少8位，short/int至少16位，long至少32位。 long long至少64位。所有的范围都保存在limits.h中。</p>
<p>3 一个有符号的整数所能表示的范围，不仅依赖于位数，还依赖于2进制编码，比如现在的计算机一般都是使用2进制补码的表示(two&#8217;s complement)。这里要注意整数类型默认都是signed.</p>
<p>4 一个有符号的整数和无符号的混合的表达式(四则运算，比较等),都会先将有符号的整数转为无符号整数再进行。而所有的无符号的算术运算，最后都会把结果对2的n次方取摸。</p></div><p class="readmore"><a href="/2011/09/18/c-reference-manual-reading-notes-(4).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/08/28/detailed-explanation-of-tcp-option-tcp_defer_accept-under-linux.html">linux下tcp选项TCP_DEFER_ACCEPT详解</a></h1><div class="post-meta">2011-08-28</div><div class="post-content"><p>TCP_DEFER_ACCEPT这个选项可能大家都知道，不过我这里会从源码和数据包来详细的分析这个选项。要注意，这里我所使用的内核版本是3.0.</p>
<p>首先看man手册中的介绍(man 7 tcp):</p>
<blockquote>
<p>TCP_DEFER_ACCEPT (since Linux 2.4)</p>
</blockquote>
<blockquote>
<p>Allow a listener to be awakened only when data arrives on the socket. Takes an integer value (seconds), this can bound the maximum number of attempts TCP will make to complete the connection. This option should not be used in code intended to be portable. </p>
</blockquote>
<p>我先来简单介绍下，这个选项主要是针对server端的服务器，一般来说我们三次握手，当客户端发送syn，然后server端接收到，然后发送syn + ack,然后client接收到syn+ack之后，再次发送ack(client进入establish状态),最终server端收到最后一个ack，进入establish状态。</p>
<p>而当正确的设置了TCP_DEFER_ACCEPT选项之后，server端会在接收到最后一个ack之后，并不进入establish状态，而只是将这个socket标记为acked，然后丢掉这个ack。此时server端这个socket还是处于syn_recved，然后接下来就是等待client发送数据， 而由于这个socket还是处于syn_recved,因此此时就会被syn_ack定时器所控制，对syn ack进行重传,而重传次数是由我们设置TCP_DEFER_ACCEPT传进去的值以及TCP_SYNCNT选项，proc文件系统的tcp_synack_retries一起来决定的(后面分析源码会看到如何来计算这个值).而我们知道我们传递给TCP_DEFER_ACCEPT的是秒，而在内核里面会将这个东西转换为重传次数.</p>
<p>这里要注意，当重传次数超过限制之后，并且当最后一个ack到达时，下一次导致超时的synack定时器还没启动，那么这个defer的连接将会被加入到establish队列，然后通知上层用户。这个也是符合man里面所说的(Takes an integer value (seconds), this can bound the maximum number of attempts TCP will make to complete the connection.) 也就是最终会完成这个连接.</p></div><p class="readmore"><a href="/2011/08/28/detailed-explanation-of-tcp-option-tcp_defer_accept-under-linux.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/08/17/design-and-implementation-of-upstream-in-nginx-(5).html">nginx中upstream的设计和实现(五)</a></h1><div class="post-meta">2011-08-17</div><div class="post-content"><p>这次主要来分析upstream中的发送数据给client, 以及当buf不足，将一部分写到temp file的部分，他们对应的函数分别是ngx_event_pipe_write_to_downstream和ngx_event_pipe_write_chain_to_temp_file.</p>
<p>先来看ngx_event_pipe_write_to_downstream，这个函数顾名思义，就是写buf到临时文件。而所写的buf就是p-&gt;in,也就是将要发送给client的数据。</p>
<p>这个函数，它会处理两类的情况，一类是cache打开，一类是cache未打开。我们这里主要来分析cache关闭的情况。</p>
<p>首先来看这个函数的第一部分的代码,这部分代码主要是遍历p-&gt;in,然后计算能写多少buf到文件(temp file的size是有限制的).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//out就是将要保存到file的数据</span><br><span class="line">      </span><br><span class="line">if (p-&gt;buf_to_file) &#123;</span><br><span class="line">  </span><br><span class="line">//cache打开的情况</span><br><span class="line">          </span><br><span class="line">fl.buf = p-&gt;buf_to_file;</span><br><span class="line">          </span><br><span class="line">fl.next = p-&gt;in;</span><br><span class="line">          </span><br><span class="line">out = &amp;fl;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//得到数据</span><br><span class="line">          </span><br><span class="line">out = p-&gt;in;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果cache没有打开</span><br><span class="line">      </span><br><span class="line">if (!p-&gt;cacheable) &#123;</span><br><span class="line"></span><br><span class="line">size = 0;</span><br><span class="line">          </span><br><span class="line">cl = out;</span><br><span class="line">          </span><br><span class="line">ll = NULL;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0,</span><br><span class="line">                         </span><br><span class="line">&quot;pipe offset: %O&quot;, p-&gt;temp_file-&gt;offset);</span><br><span class="line">  </span><br><span class="line">//开始遍历out</span><br><span class="line">          </span><br><span class="line">do &#123;</span><br><span class="line">  </span><br><span class="line">//计算大小</span><br><span class="line">              </span><br><span class="line">bsize = cl-&gt;buf-&gt;last &amp;#8211; cl-&gt;buf-&gt;pos;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">//看是否超过限制限制</span><br><span class="line">              </span><br><span class="line">if ((size + bsize &gt; p-&gt;temp_file_write_size)</span><br><span class="line">                 </span><br><span class="line">|| (p-&gt;temp_file-&gt;offset + size + bsize &gt; p-&gt;max_temp_file_size))</span><br><span class="line">              </span><br><span class="line">&#123;</span><br><span class="line">                  </span><br><span class="line">break;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size += bsize;</span><br><span class="line">              </span><br><span class="line">ll = &amp;cl-&gt;next;</span><br><span class="line">              </span><br><span class="line">cl = cl-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125; while (cl);</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0, &quot;size: %z&quot;, size);</span><br><span class="line"></span><br><span class="line">if (ll == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_BUSY;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//cl存在则说明只有一部分buf能够写入到temp file，此时p-&gt;in保存剩下的chain</span><br><span class="line">          </span><br><span class="line">if (cl) &#123;</span><br><span class="line">             </span><br><span class="line">p-&gt;in = cl;</span><br><span class="line">             </span><br><span class="line">*ll = NULL;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//否则说明所有的buf都写入到了temp file，此时p-&gt;in则设置为空</span><br><span class="line">             </span><br><span class="line">p-&gt;in = NULL;</span><br><span class="line">             </span><br><span class="line">p-&gt;last_in = &amp;p-&gt;in;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//cache打开的情况，可以看到和上面类似.</span><br><span class="line">          </span><br><span class="line">p-&gt;in = NULL;</span><br><span class="line">          </span><br><span class="line">p-&gt;last_in = &amp;p-&gt;in;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2011/08/17/design-and-implementation-of-upstream-in-nginx-(5).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/08/06/design-and-implementation-of-upstream-in-nginx-(4).html">nginx中upstream的设计和实现(四)</a></h1><div class="post-meta">2011-08-06</div><div class="post-content"><p>这此主要是分析发送数据到客户端的部分以及buffering状态下，nginx接收upstream数据的部分，这也是upstream的最复杂的部分，这里我还是忽略了cache部分，以后我会专门写blog来分析nginx的cache部分。</p>
<p>这部分的函数入口是ngx_http_upstream_send_response，这里有一个很重要的标记，那就是u-&gt;buffering，这个标记的含义就是nginx是否会尽可能多的读取upstream的数据。如果关闭，则就是一个同步的发送，也就是接收多少，发送给客户端多少。默认这个是打开的。也就是nginx会buf住upstream发送的数据。</p>
<p>不管buffering是否打开，后端发送的头都不会被buffer，首先会发送header，然后才是body的发送，而body的发送就需要区分buffering选项了。如下图所示：</p>
<p><a href="http://www.flickr.com/photos/67458145@N00/6015131336/" title="upstream_ac by Minibobo, on Flickr" target="_blank" rel="noopener"><img src="http://farm7.static.flickr.com/6013/6015131336_7fcfe4edba.jpg" width="500" height="163" alt="upstream_ac"></a></p></div><p class="readmore"><a href="/2011/08/06/design-and-implementation-of-upstream-in-nginx-(4).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/07/30/c-reference-manual-reading-notes-(3).html">c reference manual读书笔记(三)</a></h1><div class="post-meta">2011-07-30</div><div class="post-content"><p>这次主要是针对c语言中的声明(declaration)定义.</p>
<p>1 在c语言中声明的作用域(scope)可以分为4种，分别是 block/local scope, prototype scope, function scope以及file scope.其中file scope是最顶层的域. 如果一个声明不是external的，则默认这个声明就是被限制在它所出现的文件中.</p>
<p>2 一个标示符在它被完全声明之前是不能使用的。更精确的说就是从我们定义一个声明到这个声明的结束之间不能出现这个标示符.可是下面的例子是完全正确的，这是因为使用intsize(sizeof)之前，它已经被声明了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int intsize = sizeof(intsize)</span><br></pre></td></tr></table></figure>
<p>而下面的例子则会编译出错，因为Test在使用之前还没有被声明.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct &#123;Test *s&#125; Test;</span><br></pre></td></tr></table></figure>
<p>3 c语言中也支持forward reference，不过只允许下面三种类型,分别是 在goto语句中的label，label都是在goto语句之后声明的；还有就是允许在struct,union,array类型的完全声明之前使用当前的声明，比如下面的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct s &#123;struct s *n&#125; T;</span><br></pre></td></tr></table></figure>
<p>最后一种例外是函数的声明，这个原因是在c99之前，c语言允许隐式(implicitly)的声明，也就是如果一个函数在调用之前没有被声明，则在函数被调用的地方会隐式的声明这个函数(后面会详细介绍这个)。不过c99是不允许隐式的声明的.</p></div><p class="readmore"><a href="/2011/07/30/c-reference-manual-reading-notes-(3).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/07/16/c-reference-manual-reading-notes-(2).html">c reference manual读书笔记(二)</a></h1><div class="post-meta">2011-07-16</div><div class="post-content"><p>这次主要是预处理器和宏处理的部分。</p>
<p>1 预处理器主要是处理源代码中以#开头的行，预处理器执行完毕后的代码必定是一个合法的c程序.</p>
<p>2 预处理器的命令是完全不依赖于c语言的语法的.</p>
<p>3 预处理器不会parse源代码，预处理的词法处理和编译器的是不同的，预处理器能够理解合法的c标记，可是它也会忽略在c编译器中认为是不合法标记。比如下面的代码,对于预处理器来说，没有任何问题的.</p></div><p class="readmore"><a href="/2011/07/16/c-reference-manual-reading-notes-(2).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/07/03/c-reference-manual-reading-notes-(1).html">c reference manual读书笔记(一)</a></h1><div class="post-meta">2011-07-03</div><div class="post-content"><p>我读的是第五版的影印版，简单的做了一些笔记.下面是第二章的笔记.</p>
<p>1 c 源文件的字符集(character set)包含在ISO/IEC 10646的Latin block中. 包括5种类型，分别是 52个lating大小写字母，10个数字(0-9)，空格，horizontal tab(ht) vertical tab(VT) form feed(FF) 以及29个graphic 字符(这个可以去看c99的手册).而不在集合内的字符可能会出现在注释/字符常量/字符串常量/文件名中.在c中还有执行字符集(execution character)的概念,一般来说编译和运行都在相同的电脑，则source字符集和执行字符集都是相同的.</p>
<p>2 在c的源程序中，blank, end-of-line, vertical tab, form feed, horizontal-tab都会被认为是空格(whitespace characters).</p>
<p>3 c89中要求逻辑行的最大长度是509个字符，而c99是4095个字符.</p>
<p>4 c语言中可以使用 9个trigraphs(比如??/表示)，而trigraphs的翻译会在词法分析之前(gcc默认编译没有打开trigraph，必须添加-trigraphs命令，或者使用-std命令指定c标准).</p>
<p>5 多字节字符(multibytes characters),主要针对非英语的环境.编码实现分为state-independent和state-depend,顾名思义，一个是编码依赖于前一个多字节字符，一个是不依赖于前一个多字节字符.</p></div><p class="readmore"><a href="/2011/07/03/c-reference-manual-reading-notes-(1).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/06/11/introduction-to-rfc-2988-(computing-tcp-&amp;-s-retransmission-timer).html">rfc 2988(Computing TCP&amp;#8217;s Retransmission Timer)简介</a></h1><div class="post-meta">2011-06-11</div><div class="post-content"><p>rfc 2988是描述tcp如何计算定时器的一个rfc，是2000年发布的，而最近2988 已经被更新:</p>
<p><a href="http://tools.ietf.org/html/draft-paxson-tcpm-rfc2988bis-02" target="_blank" rel="noopener">http://tools.ietf.org/html/draft-paxson-tcpm-rfc2988bis-02</a></p>
<p>并且google的jerry chu(2988bis的作者之一)最近在内核提交一个patch，主要是用来修改3次握手时的初始化rto的值(以及rfc 2988bis的一些改变)，当前的内核默认是3，而patch修改这个值为1，主要的修改依据是rfc2988.</p></div><p class="readmore"><a href="/2011/06/11/introduction-to-rfc-2988-(computing-tcp-&amp;-s-retransmission-timer).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/06/01/a-bug-in-nginx-fast-cgi-module.html">nginx fastcgi模块的一个bug</a></h1><div class="post-meta">2011-06-01</div><div class="post-content"><p>上周服务器更新到nginx的0.8.X之后，nginx出现了core dump的情况，而在0.7.X并不会出现，通过察看core dump文件以及nginx 0.8.x和0.7.x的比较，发现core dump是nginx 0.8.40引入下面这个feature才导致的:</p>
<blockquote>
<p>*) Feature: a &#8220;fastcgi_param&#8221; directive with value starting with</p>
</blockquote>
<blockquote>
<p>&#8220;HTTP_&#8221; overrides a client request header line.</p>
</blockquote>
<p>在nginx 0.8.40之后，如果你的fastcgi_param定义的变量以HTTP_开头，则传递给后端的头会忽略request header中的这个头，比如定义了一个 fastcgi_param $HTTP_HOST test, 那么传递给后端时，host这个头的值就是test.</p>
<p>这里的逻辑是这样子的，当nginx创建一个fastcgi request的时候，会先计算所需要的长度，首先是计算header的长度，在计算之前会先分配一个ignored数组(用来保存将要被忽略的头),它的大小是配置文件中fastcgi_param定义的以HTTP_开头的变量的个数. 然后遍历所有的request header，如果发现header的名字和fastcgi_param中定义的变量的(HTTP_开头)名字相同(使用hash)，则将这个header指针放到ignored数组中，最后在拷贝request header的时候直接在这个数组里面查找，如果有则跳过，否则拷贝头以及它的值。</p>
<p>看起来没什么问题，可是这里忽略了request header有可能会有重复的这个情况，此时ignored数组可能就会越界，从而导致core dump.</p></div><p class="readmore"><a href="/2011/06/01/a-bug-in-nginx-fast-cgi-module.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/05/09/introduction-to-tfo-(tcp-fast-open).html">TFO(tcp fast open)简介</a></h1><div class="post-meta">2011-05-09</div><div class="post-content"><p>这个是google的几个人提交的一个rfc，是对tcp的一个增强，简而言之就是在3次握手的时候也用来交换数据。这个东西google内部已经在使用了，不过内核的相关patch还没有开源出来，chrome也支持这个了(client的内核必须支持). 要注意，TFO默认是关闭的，因为它有一些特定的适用场景，下面我会介绍到。</p></div><p class="readmore"><a href="/2011/05/09/introduction-to-tfo-(tcp-fast-open).html">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/5/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>