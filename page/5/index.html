<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>pagefault | 但行好事 莫問前程</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">pagefault</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2011/05/09/.html">TFO(tcp fast open)简介</a></h1><div class="post-meta">2011-05-09</div><div class="post-content"><p>这个是google的几个人提交的一个rfc，是对tcp的一个增强，简而言之就是在3次握手的时候也用来交换数据。这个东西google内部已经在使用了，不过内核的相关patch还没有开源出来，chrome也支持这个了(client的内核必须支持). 要注意，TFO默认是关闭的，因为它有一些特定的适用场景，下面我会介绍到。</p></div><p class="readmore"><a href="/2011/05/09/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/04/27/design-and-implementation-of-upstream-in-nginx-(3).html">nginx中upstream的设计和实现(三)</a></h1><div class="post-meta">2011-04-27</div><div class="post-content"><p>这次主要来分析当upstream发送过来数据之后，nginx是如何来处理。不过这里我忽略了cache部分，以后我会专门来分析nginx的cache部分。</p>
<p>在前面blog我们能得知upstream端的读回调函数是ngx_http_upstream_process_header，因此这次我们就从ngx_http_upstream_process_header的分析开始。</p>
<p>下面是ngx_http_upstream_process_header执行的流程图.</p>
<p><a href="http://www.flickr.com/photos/67458145@N00/5660159919/" title="upstream_process_header by Minibobo, on Flickr" target="_blank" rel="noopener"><img src="http://farm6.static.flickr.com/5186/5660159919_146459ed32.jpg" width="444" height="456" alt="upstream_process_header"></a></p></div><p class="readmore"><a href="/2011/04/27/design-and-implementation-of-upstream-in-nginx-(3).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/04/20/.html">linux kernel中epoll的设计和实现</a></h1><div class="post-meta">2011-04-20</div><div class="post-content"><p>这里就不贴源码了，源码分析的话，网上一大堆，我这里只是简要的描述下epoll的实现和一些关键的代码片段。</p>
<p>相关的文件在 fs/eventpoll.c中,我看的是2.6.38的内核代码.</p>
<p>1 epoll在创建的时候会调用anon_inode_getfd新建一个file instance，也就是epoll可以看成一个文件。因此我们可以看到epoll_create会返回一个fd.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">error = anon_inode_getfd(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep,</span><br><span class="line">				   </span><br><span class="line">O_RDWR | (flags &amp; O_CLOEXEC));</span><br></pre></td></tr></table></figure>
<p>2 epoll所管理的所有的句柄都是放在一个大的结构eventpoll(红黑树)中,而这个结构是保存在file 的private_data域中的(因为epoll本身就是一个文件).这样每次通过epoll fd就可以直接得到eventpoll.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">file = fget(epfd);</span><br><span class="line">	  </span><br><span class="line">/\* Get the &quot;struct file \*&quot; for the target file */</span><br><span class="line">	  </span><br><span class="line">tfile = fget(fd);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">	  </span><br><span class="line">ep = file-&gt;private_data;</span><br></pre></td></tr></table></figure>
<p>3 每一个加入到epoll监听的句柄(也就是红黑树的一个节点)都是一个epitem.它包含了一个 struct eventpoll *ep，也就是它所属于的eventpoll(epoll实例).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">		  </span><br><span class="line">return -ENOMEM;</span><br><span class="line"></span><br><span class="line">/\* Item initialization follow here &amp;#8230; \*/</span><br><span class="line">	  </span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">	  </span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">	  </span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">	  </span><br><span class="line">epi-&gt;ep = ep;</span><br><span class="line">	  </span><br><span class="line">ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">	  </span><br><span class="line">epi-&gt;event = *event;</span><br><span class="line">	  </span><br><span class="line">epi-&gt;nwait = 0;</span><br><span class="line">	  </span><br><span class="line">epi-&gt;next = EP_UNACTIVE_PTR;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2011/04/20/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/04/14/design-and-implementation-of-upstream-in-nginx-(2).html">nginx中upstream的设计和实现(二)</a></h1><div class="post-meta">2011-04-14</div><div class="post-content"><p>这次主要来看upstream的几个相关的hook函数。</p>
<p>首先要知道，对于upstream，同时有两个连接，一个时client和nginx，一个是nginx和upstream，这个时候就会有两个回调，然后上篇blog中，我们能看到在upstream中，会改变read_event_handler和write_event_handler,不过这里有三个条件，分别是</p>
<p>1 没有使用cache，</p>
<p>2 不忽略client的提前终止</p>
<p>3 不是post_action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//条件赋值</span><br><span class="line">      </span><br><span class="line">if (!u-&gt;store &amp;&amp; !r-&gt;post_action &amp;&amp; !u-&gt;conf-&gt;ignore_client_abort) &#123;</span><br><span class="line">  </span><br><span class="line">//然后给读写handler赋值</span><br><span class="line">          </span><br><span class="line">r-&gt;read_event_handler = ngx_http_upstream_rd_check_broken_connection;</span><br><span class="line">          </span><br><span class="line">r-&gt;write_event_handler = ngx_http_upstream_wr_check_broken_connection;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2011/04/14/design-and-implementation-of-upstream-in-nginx-(2).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/04/08/.html">nginx中upstream的设计和实现(一)</a></h1><div class="post-meta">2011-04-08</div><div class="post-content"><p>在nginx的模块中，分为3种类型，分别是handler，filter和upstream，其中upstream可以看做一种特殊的handler，它主要用来实现和后端另外的服务器(php/jboss等)进行通信，由于在nginx中全部都是使用非阻塞，并且是一个流式的处理，所以upstream的实现很复杂，接下来我会通过几篇blog来详细的分析下nginx中upstream的设计和实现。</p>
<p>upstream顾名思义，真正产生内容的地方在&#8221;上游&#8221;而不是nginx，也就是说nginx是位于client和后端的upstream之间的桥梁，在这种情况下，一个upstream需要做的事情主要有2个，第一个是当client发送http请求过来之后，需要创建一个到后端upstream的请求。第二个是当后端发送数据过来之后，需要将后端upstream的数据再次发送给client.接下来会看到，我们编写一个upstream模块，最主要也是这两个hook方法。</p>
<p>首先来看如果我们要写一个upstream模块的话，大体的步骤是什么，我们以memcached模块为例子，我们会看到如果我们自己编写upstream模块的话，只需要编写upstream需要的一些hook函数，然后挂载到upstream上就可以了。</p></div><p class="readmore"><a href="/2011/04/08/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/03/27/.html">路由的基本概念介绍</a></h1><div class="post-meta">2011-03-27</div><div class="post-content"><p>这里主要是针对linux下的路由一些基本概念.</p>
<p>1 路由是位于L3（ip层）。</p>
<p>2 路由表(routing table)也叫做Forwarding Information Base(FIB).</p>
<p>3 路由器之间通过路由协议(routing protocols)进行信息的交换.</p>
<p>4 一个路由表包含了一大堆的路由，一个路由就是存储了一些传输数据包到给定地址的必须信息。在linux里面一个路由主要包括了这三个参数，分别是目的网络地址，需要使用的设备以及下一跳网关(next hop gateway)。</p></div><p class="readmore"><a href="/2011/03/27/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/03/13/.html">nginx中if命令的设计和实现</a></h1><div class="post-meta">2011-03-13</div><div class="post-content"><p>先看这篇文章：<a href="http://wiki.nginx.org/IfIsEvil，这篇文章只是简单的介绍了if使用中一些很恶心的地方，接下来我会通过代码来看if为什么是" target="_blank" rel="noopener">http://wiki.nginx.org/IfIsEvil，这篇文章只是简单的介绍了if使用中一些很恶心的地方，接下来我会通过代码来看if为什么是</a> evil的。</p></div><p class="readmore"><a href="/2011/03/13/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/02/23/.html">nginx对TCP_CORK/TCP_NOPUSH的使用</a></h1><div class="post-meta">2011-02-23</div><div class="post-content"><p>在nginx中使用了send_file 并且配合TCP_CORK/TCP_NOPUSH进行操作，我们一般的操作是这样子的，首先调用tcp_cork，阻塞下层的数据发送，然后调用send_file发送数据，最后关闭TCP_CORK/TCP_NOPUSH.而在nginx中不是这样处理的，前面两步都是一样的，最后一步，它巧妙的利用的http的特性，那就是基本都是短连接，也就是处理完当前的request之后，就会关闭当前的连接句柄，而在linux中，如果不是下面两种情况之一，那么关闭tcp句柄，就会发送完发送buf中的数据，才进行tcp的断开操作(具体可以看我以前写的那篇 “linux内核中tcp连接的断开处理”的 blog) :</p>
<p>1 接收buf中还有未读数据。</p>
<p>2 so_linger设置并且超时时间为0.</p>
<p>而如果调用shutdown来关闭写端的话，就是直接发送完写buf中的数据，然后发送fin。</p>
<p>ok，通过上面我们知道每次处理完请求，都会关闭连接(keepalive 会单独处理),而关闭连接就会帮我们将cork拔掉，所以这里就可以节省一个系统调用，从这里能看到nginx对细节的处理到了一个什么程度。</p>
<p>接下来还有一个单独要处理的就是keepalive的连接，由于keepalive是不会关闭当前的连接的，因此这里就必须显式的关闭tcp_cork。</p></div><p class="readmore"><a href="/2011/02/23/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/02/17/.html">nginx对keepalive和pipeline请求处理分析</a></h1><div class="post-meta">2011-02-17</div><div class="post-content"><p>这次主要来看nginx中对keepalive和pipeline的处理，这里概念就不用介绍了。直接来看nginx是如何来做的。</p>
<p>首先来看keepalive的处理。我们知道http 1.1中keepalive是默认的，除非客户端显式的指定connect头为close。下面就是nginx判断是否需要keepalive的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void</span><br><span class="line">  </span><br><span class="line">ngx_http_handler(ngx_http_request_t *r)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">          </span><br><span class="line">switch (r-&gt;headers_in.connection_type) &#123;</span><br><span class="line">          </span><br><span class="line">case 0:</span><br><span class="line">  </span><br><span class="line">//如果版本大于1.0则默认是keepalive</span><br><span class="line">              </span><br><span class="line">r-&gt;keepalive = (r-&gt;http_version &gt; NGX_HTTP_VERSION_10);</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case NGX_HTTP_CONNECTION_CLOSE:</span><br><span class="line">  </span><br><span class="line">//如果指定connection头为close则不需要keepalive</span><br><span class="line">              </span><br><span class="line">r-&gt;keepalive = 0;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case NGX_HTTP_CONNECTION_KEEP_ALIVE:</span><br><span class="line">              </span><br><span class="line">r-&gt;keepalive = 1;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2011/02/17/.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/02/09/design-and-implementation-of-request-buf-in-nginx.html">nginx中request buf的设计和实现</a></h1><div class="post-meta">2011-02-09</div><div class="post-content"><p>在nginx中request的buffer size我们能够通过两个命令进行设置，分别是large_client_header_buffers和client_header_buffer_size。这两个是有所不同的。</p>
<p>在解析request中，如果已经读取的request line 或者 request header大于lient_header_buffer_size的话，此时就会重新分配一块大的内存，然后将前面未完成解析的部分拷贝到当前的大的buf中，然后再进入解析处理，这部分的buf也就是large_client_header_buffers,也叫做large hader的处理。接下来我会通过代码来详细的分析这个过程。</p></div><p class="readmore"><a href="/2011/02/09/design-and-implementation-of-request-buf-in-nginx.html">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/design-and-implementation-of-redo-log-in-innodb-(i).html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>