<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>pagefault | 但行好事 莫問前程</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">pagefault</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2018/05/08/introduction-to-mysql.-rocksdb.-manifest-file.html">MySQL · RocksDB · MANIFEST文件介绍</a></h1><div class="post-meta">2018-05-08</div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在RocksDB中MANIFEST保存了存储引擎的内部的一些状态元数据，简单来说当系统异常重启，或者程序异常被退出之后，RocksDB需要有一种机制能够恢复到一个一致性的状态，<br>而这个一致性的状态就是靠MANIFEST来保证的.</p></div><p class="readmore"><a href="/2018/05/08/introduction-to-mysql.-rocksdb.-manifest-file.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2018/04/18/introduction-to-mysql-rocksdb-wal-(writeaheadlog).html">MySQL · RocksDB · WAL(WriteAheadLog)介绍</a></h1><div class="post-meta">2018-04-18</div><div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在RocksDB中每一次数据的更新都会涉及到两个结构，一个是内存中的memtable(后续会刷新到磁盘成为SST),第二个是WAL(WriteAheadLog)。<br>本篇文章主要就是来介绍WAL.</p></div><p class="readmore"><a href="/2018/04/18/introduction-to-mysql-rocksdb-wal-(writeaheadlog).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2013/12/03/lua-source-analysis-(v).html">Lua源码剖析(五)</a></h1><div class="post-meta">2013-12-03</div><div class="post-content"><p>这次主要来分析lua的gc。</p>
<p>首先lua中的数据类型包括下面9种，ni， Boolean， number， string， table，user data， thread , functions 以及 lightusedata.其中 string， table，thread , function 是会被垃圾回收管理的，其他的都是值存在。</p>
<p>因此我们来看对应的GC数据结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define CommonHeader GCObject *next; lu_byte tt; lu_byte marked</span><br><span class="line"></span><br><span class="line">typedef struct GCheader &#123;</span><br><span class="line">    </span><br><span class="line">CommonHeader;</span><br><span class="line">  </span><br><span class="line">&#125; GCheader;</span><br><span class="line"></span><br><span class="line">union GCObject &#123;</span><br><span class="line">    </span><br><span class="line">GCheader gch;</span><br><span class="line">    </span><br><span class="line">union TString ts;</span><br><span class="line">    </span><br><span class="line">union Udata u;</span><br><span class="line">    </span><br><span class="line">union Closure cl;</span><br><span class="line">    </span><br><span class="line">struct Table h;</span><br><span class="line">    </span><br><span class="line">struct Proto p;</span><br><span class="line">    </span><br><span class="line">struct UpVal uv;</span><br><span class="line">    </span><br><span class="line">struct lua_State th; /\* thread \*/</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在lua中字符串，userdata, thread, table ,string, thread(以及Upval, proto) 都会被垃圾回收管理。这里比较关键的就是GCheader这个结构体，我们可以看到这个结构体其实就是一个链表，也就是说所有的gc对象都会被链到一个链表中，其中tt表示当前对象的类型，在lua中包括下面这些类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define LUA_TNIL 0</span><br><span class="line">  </span><br><span class="line">#define LUA_TBOOLEAN 1</span><br><span class="line">  </span><br><span class="line">#define LUA_TLIGHTUSERDATA 2</span><br><span class="line">  </span><br><span class="line">#define LUA_TNUMBER 3</span><br><span class="line">  </span><br><span class="line">#define LUA_TSTRING 4</span><br><span class="line">  </span><br><span class="line">#define LUA_TTABLE 5</span><br><span class="line">  </span><br><span class="line">#define LUA_TFUNCTION 6</span><br><span class="line">  </span><br><span class="line">#define LUA_TUSERDATA 7</span><br><span class="line">  </span><br><span class="line">#define LUA_TTHREAD 8</span><br></pre></td></tr></table></figure>
<p>而marked表示当前对象的状态(涉及到gc算法，后续会详细分析),状态位包括下面这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define WHITE0BIT 0</span><br><span class="line">  </span><br><span class="line">#define WHITE1BIT 1</span><br><span class="line">  </span><br><span class="line">#define BLACKBIT 2</span><br><span class="line">  </span><br><span class="line">#define FINALIZEDBIT 3</span><br><span class="line">  </span><br><span class="line">#define KEYWEAKBIT 3</span><br><span class="line">  </span><br><span class="line">#define VALUEWEAKBIT 4</span><br><span class="line">  </span><br><span class="line">#define FIXEDBIT 5</span><br><span class="line">  </span><br><span class="line">#define SFIXEDBIT 6</span><br><span class="line">  </span><br><span class="line">#define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2013/12/03/lua-source-analysis-(v).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2013/09/08/lua-source-analysis-(4).html">Lua源码剖析（四）</a></h1><div class="post-meta">2013-09-08</div><div class="post-content"><p>前面三篇请看我前面的 <a href="http://www.pagefault.info/?p=34" title="lua源码分析" target="_blank" rel="noopener">blog</a></p>
<p>这篇主要来分析lua的虚拟机的实现，我看的代码依旧是5.1</p>
<p>因此首先从luaL_loadfile开始，这个函数我们知道是在当前的lua state加载一个lua文件，其中第二个参数就是filename。</p>
<p>其中LoadF结构很简单，它用来表示一个load file：</p>
<figure class="highlight plain"><figcaption><span>struct LoadF &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">int extraline;</span><br><span class="line">    </span><br><span class="line">FILE *f;</span><br><span class="line">    </span><br><span class="line">char buff[LUAL_BUFFERSIZE];</span><br><span class="line">  </span><br><span class="line">&#125; LoadF;</span><br></pre></td></tr></table></figure>
<p>其中会使用fopen来打开对应的文件名,然后根据第一个字符来判断是否是注释(#)，如果是则跳过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">lua_pushfstring(L, &quot;@%s&quot;, filename);</span><br><span class="line">      </span><br><span class="line">lf.f = fopen(filename, &quot;r&quot;);</span><br><span class="line">      </span><br><span class="line">if (lf.f == NULL) return errfile(L, &quot;open&quot;, fnameindex);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">c = getc(lf.f);</span><br><span class="line">    </span><br><span class="line">if (c == &amp;#8216;#&amp;#8217;) &#123; /\* Unix exec. file? \*/</span><br><span class="line">      </span><br><span class="line">lf.extraline = 1;</span><br><span class="line">      </span><br><span class="line">while ((c = getc(lf.f)) != EOF &amp;&amp; c != &amp;#8216;\n&amp;#8217;) ; /\* skip first line \*/</span><br><span class="line">      </span><br><span class="line">if (c == &amp;#8216;\n&amp;#8217;) c = getc(lf.f);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2013/09/08/lua-source-analysis-(4).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2013/05/11/early-retransmit-for-tcp-principle-and-implementation.html">Early Retransmit for TCP原理以及实现</a></h1><div class="post-meta">2013-05-11</div><div class="post-content"><p>Early Retransmit for TCP(ER)是google为了解决快重传的一些局限，从而对快重传(fast retransmit)做出的一些改变，其中ER在linux kernel 3.5进入了内核,他的paper在这里：</p>
<p><a href="http://tools.ietf.org/html/rfc5827" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc5827</a></p>
<p>首先我们要知道快重传算法的弱点很多，比如如果发送端接收不到足够数量(一般来说是3个)的ack，那么快重传算法就无法起作用，这个时候就只能等待RTO超时。ER主要就是为了解决这个问题的。在下面的条件下，就会导致收不到足够的ack。</p>
<ul>
<li>拥塞窗口比较小</li>
<li>窗口中一个很大的段丢失或者在传输的结尾处发生了丢包</li>
</ul></div><p class="readmore"><a href="/2013/05/11/early-retransmit-for-tcp-principle-and-implementation.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/10/21/tcp-congestion-handling-in-linux-kernel-(2).html">linux 内核tcp拥塞处理(二)</a></h1><div class="post-meta">2012-10-21</div><div class="post-content"><p>这篇接的是我最早在javaeye的那篇blog. <a href="http://simohayha.iteye.com/blog/614258" target="_blank" rel="noopener">http://simohayha.iteye.com/blog/614258</a></p>
<p>首先我们要知道在linux下分为5个拥塞状态，定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">enum tcp_ca_state &#123;</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Open = 0,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Open (1&lt;&lt;TCP_CA_Open)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Disorder = 1,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Disorder (1&lt;&lt;TCP_CA_Disorder)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_CWR = 2,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_CWR (1&lt;&lt;TCP_CA_CWR)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Recovery = 3,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Recovery (1&lt;&lt;TCP_CA_Recovery)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Loss = 4</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Loss (1&lt;&lt;TCP_CA_Loss)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TCP_CA_OPEN这个就是初始状态，也就是没有检测到任何拥塞的情况.</p>
<p>TCP_CA_Disorder 顾名思义，这个状态就是当第一次由于收到SACK或者重复的ack而检测到拥塞时，就进入这个状态.</p>
<p>TCP_CA_CWR 由于一些拥塞通知事件而导致拥塞窗口减小,然后就会进入这个状态。比如ECN，ICMP，本地设备拥塞。</p>
<p>TCP_CA_Recovery 当CWND减小</p>
<p>TCP_CA_Loss 超时或者SACK被拒绝，此时表示数据包丢失，因此进入这个状态.</p></div><p class="readmore"><a href="/2012/10/21/tcp-congestion-handling-in-linux-kernel-(2).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/08/18/vegas-analysis-of-tcp-congestion-algorithm.html">tcp拥塞算法vegas分析</a></h1><div class="post-meta">2012-08-18</div><div class="post-content"><p>tcp的vegas算法是基于delay的一个拥塞控制算法，所谓基于delay也就是说窗口的变化只和RTT的变化相关。而传统的基于丢包的算法是窗口的变化和丢包相关.</p>
<p>先来看原理，paper地址在这里(94年提出来的),基本上linux的实现就是按照paper来实现的，注意Vegas它是第一个基于delay的拥塞算法.</p>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.100.9587&amp;rep=rep1&amp;type=pdf" target="_blank" rel="noopener">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.100.9587&amp;rep=rep1&amp;type=pdf</a></p>
<p>它的主要思想是估计一段时间能够发送的数据量，然后和最终发送的数据量比较。如果预测要发送的数据没有被发送，那么就会被认为可能出现拥塞状况，如果这个状态持久，那么就减慢发送速度，并且这个算法不仅作用于拥塞避免状态，而且还作用于slow start状态。</p>
<p>不过vegas的缺点也是很明显.那就是他会被欺骗，也就是说本身这个正向的延迟就是比它期待的高，比如在tcp中，有可能正向反向做的不是相同的路径，那么当反向有拥塞的时候，就有问题了。也就是数据包ack返回给发送端的就是延迟的。此时就会导致Vegas降低拥塞窗口。这个问题就是基于延迟的拥塞算法的一个陷阱。不过在linux下vegas算法被打开，只有是正常状态才会被打开，而只要遇到异常(丢包/快重传..)就会使用经典的newreno算法.</p>
<p>并且如果连接都是Vegas算法，那么这些连接就是公平的，而如果有些是，有些不是，那么就不是公平的了，因此经典的tcp发送者是会尝试填满网络中的队列，而Vegas是尝试着保持队列为空。因此最终就会导致使用经典tcp拥塞算法的，发送的数据包越来越多，而Vegas的就会越来越慢。</p></div><p class="readmore"><a href="/2012/08/18/vegas-analysis-of-tcp-congestion-algorithm.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/08/01/calculation-of-rto-in-tcp-and-implementation-under-linux.html">tcp中RTO的计算以及linux下的实现</a></h1><div class="post-meta">2012-08-01</div><div class="post-content"><p>计算RTT以及RTO的代码比较简单，我们先来看原理，首先相关的rfc有两篇分别是rfc793以及rfc6298，而相关的paper有一篇，那就是Van Jacobson和Michael J. Karels的 Congestion Avoidance and Control这篇paper，这篇1988年的paper中描述的RTT计算方法，就是我们当前所使用的计算方法，可能有的操作系统有一点修改，不过基本的东西都一样。</p>
<p>首先RTT是什么，RTT简单来说，就是我发送一个数据包，然后对端回一个ack，那么当我接到ack之后，就能计算出从我发送出包到接到过了多久，这个时间就是RTT。RTT的计算是很简单的，就是一个时间差。</p>
<p>而RTO呢，RTO也就是tcp在发送一个数据包之后，会启动一个重传定时器，而RTO就是这个定时器的重传时间，那么这个时候，就有问题了，由于RTO是指的这次发送当前数据包所预估超时时间,那么RTO就需要一个很好的统计方法，来更好的预测这次的超时时间。</p>
<p>我们所能想到的最简单的方法，那就是取平均数，比如第一次RTT是500毫秒，第二次是800毫秒，那么第三次发送的时候，RTO就应该是650毫秒。其实经典的RTO计算方法和取平均有点类似，只不过因子不太一样，取平均的话，也就是老的RTO和新的RTT都是占50%的权重，而在经典的RTO计算中就有些变化了。</p></div><p class="readmore"><a href="/2012/08/01/calculation-of-rto-in-tcp-and-implementation-under-linux.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/07/11/source-code-analysis-of-nginx-least_conn-module.html">nginx least_conn 模块源码剖析</a></h1><div class="post-meta">2012-07-11</div><div class="post-content"><p>nginx在1.3.1添加了一个新模块 least_conn,也就是我们常说的最少连接负载均衡算法，简单来说就是每次选择的都是当前最少连接的一个server(这个最少连接不是全局的，是每个进程都有自己的一个统计列表)。</p>
<p>在看最少连接模块之前需要对round robin模块有一定的了解，这里我就不对round robin模块进行分析了，想要看这块代码，可以去我们组 卫岳的blog的这篇文章</p>
<p><a href="http://blog.sina.com.cn/s/blog_7303a1dc01014i0j.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7303a1dc01014i0j.html</a></p>
<p>ok，接下来就来看这个模块，首先来看如何打开least_conn模块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static ngx_command_t ngx_http_upstream_least_conn_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">&#123; ngx_string(&quot;least_conn&quot;),</span><br><span class="line">        </span><br><span class="line">NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS,</span><br><span class="line">        </span><br><span class="line">ngx_http_upstream_least_conn,</span><br><span class="line">        </span><br><span class="line">0,</span><br><span class="line">        </span><br><span class="line">0,</span><br><span class="line">        </span><br><span class="line">NULL &#125;,</span><br><span class="line"></span><br><span class="line">ngx_null_command</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2012/07/11/source-code-analysis-of-nginx-least_conn-module.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/07/04/a-problem-caused-by-opening-tcp_tw_recycle.html">打开tcp_tw_recycle引起的一个问题</a></h1><div class="post-meta">2012-07-04</div><div class="post-content"><p>今天<a href="http://weibo.com/benjiaming1981" title="普空" target="_blank" rel="noopener">普空</a>说了一个问题就是如果设置了tcp_tw_recycle ，那么如果客户端是NAT出来的，那么就可能会出现连接被直接rst的情况。然后我google了下，在内核列表也有人说了这个问题 <a href="https://lkml.org/lkml/2008/11/15/67" target="_blank" rel="noopener">https://lkml.org/lkml/2008/11/15/67</a></p>
<blockquote>
<p>The big problem is that both are incompatible with NAT. So if you</p>
</blockquote>
<blockquote>
<p>ever talk to any NATed clients don&#8217;t use it.</p>
</blockquote></div><p class="readmore"><a href="/2012/07/04/a-problem-caused-by-opening-tcp_tw_recycle.html">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>