<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>pagefault | 但行好事 莫問前程</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">pagefault</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title"><a href="/2012/07/03/an-out-of-socket-memory-problem.html">一个out of socket memory的问题</a></h1><div class="post-meta">2012-07-03</div><div class="post-content"><p>今天同事遇到一个问题，就是server(read hat 5, kernel 2.6.18)的dmesg打出了下面两个信息</p>
<blockquote>
<p>TCP: too many of orphaned sockets</p>
</blockquote>
<blockquote>
<p>Out of socket memory </p>
</blockquote>
<p>一般我们看到这个信息，第一反应肯定是需要调节tcp_mem(/proc/sys/net/ipv4)了，可是根据当时的内存使用情况，使用的内存并没有超过 tcp_mem。然后我先去看了最新的内核代码，3.4.4，其中涉及到socket 内存报警在这里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">bool tcp_check_oom(struct sock *sk, int shift)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">bool too_many_orphans, out_of_socket_memory;</span><br><span class="line"></span><br><span class="line">too_many_orphans = tcp_too_many_orphans(sk, shift);</span><br><span class="line">	  </span><br><span class="line">out_of_socket_memory = tcp_out_of_memory(sk);</span><br><span class="line"></span><br><span class="line">if (too_many_orphans &amp;&amp; net_ratelimit())</span><br><span class="line">		  </span><br><span class="line">pr_info(&quot;too many orphaned sockets\n&quot;);</span><br><span class="line">	  </span><br><span class="line">if (out_of_socket_memory &amp;&amp; net_ratelimit())</span><br><span class="line">		  </span><br><span class="line">pr_info(&quot;out of memory &amp;#8212; consider tuning tcp_mem\n&quot;);</span><br><span class="line">	  </span><br><span class="line">return too_many_orphans || out_of_socket_memory;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很简单，就是如果孤儿socket太多，则打印警告，然后如果socket memory超过限制，也打印出警告。</p></div><p class="readmore"><a href="/2012/07/03/an-out-of-socket-memory-problem.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/06/30/brief-analysis-of-intel-ten-gigabit-network-card-driver.html">intel万兆网卡驱动简要分析</a></h1><div class="post-meta">2012-06-30</div><div class="post-content"><p>这里分析的驱动代码是给予linux kernel 3.4.4</p>
<p>对应的文件在drivers/net/ethernet/intel 目录下，这个分析不涉及到很细节的地方，主要目的是理解下数据在协议栈和驱动之间是如何交互的。</p>
<p>首先我们知道网卡都是pci设备，因此这里每个网卡驱动其实就是一个pci驱动。并且intel这里是把好几个万兆网卡(82599/82598/x540)的驱动做在一起的。</p>
<p>首先我们来看对应的pci_driver的结构体，这里每个pci驱动都是一个pci_driver的结构体，而这里是多个万兆网卡共用这个结构体ixgbe_driver.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static struct pci_driver ixgbe_driver = &#123;</span><br><span class="line">	  </span><br><span class="line">.name = ixgbe_driver_name,</span><br><span class="line">	  </span><br><span class="line">.id_table = ixgbe_pci_tbl,</span><br><span class="line">	  </span><br><span class="line">.probe = ixgbe_probe,</span><br><span class="line">	  </span><br><span class="line">.remove = __devexit_p(ixgbe_remove),</span><br><span class="line">  </span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">	  </span><br><span class="line">.suspend = ixgbe_suspend,</span><br><span class="line">	  </span><br><span class="line">.resume = ixgbe_resume,</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">	  </span><br><span class="line">.shutdown = ixgbe_shutdown,</span><br><span class="line">	  </span><br><span class="line">.err_handler = &amp;ixgbe_err_handler</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2012/06/30/brief-analysis-of-intel-ten-gigabit-network-card-driver.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/05/30/mochiweb-source-code-analysis-(2).html">mochiweb源码分析(二)</a></h1><div class="post-meta">2012-05-30</div><div class="post-content"><p>这次主要来看mochiweb如何处理http协议以及如何将外部模块加载到mochiweb框架中。</p>
<p>首先在上一篇的分析最后，我们知道当accept句柄之后，mochiweb最终会调用call_loop方法，那么我们就从call_loop开始</p>
<p>[erlang]</p>
<p>call_loop({M, F}, Socket) -&gt;</p>
<p>M:F(Socket);</p>
<p>call_loop({M, F, [A1]}, Socket) -&gt;</p>
<p>M:F(Socket, A1);</p>
<p>call_loop({M, F, A}, Socket) -&gt;</p>
<p>erlang:apply(M, F, [Socket | A]);</p>
<p>call_loop(Loop, Socket) -&gt;</p>
<p>Loop(Socket).</p>
<p>[/erlang]</p></div><p class="readmore"><a href="/2012/05/30/mochiweb-source-code-analysis-(2).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/05/19/mochiweb-source-code-analysis-(1).html">mochiweb源码分析(一)</a></h1><div class="post-meta">2012-05-19</div><div class="post-content"><p>这篇主要分析下mochiweb的整体结构。</p>
<p>我这里看的代码是github上的最新代码( <a href="https://github.com/mochi/mochiweb" target="_blank" rel="noopener">https://github.com/mochi/mochiweb</a> )。</p>
<p>由于mochiweb是一个框架，因此我们就从他自带的简单例子入手，来看他是如何工作的。我们就从keepalive.erl开始。</p>
<p>首先来看这个模块的start函数，也就是它的启动函数：</p>
<p>[erlang]</p>
<p>-define(LOOP, {?MODULE, loop}).</p>
<p>start(Options = [{port, _Port}]) -&gt;</p>
<p>mochiweb_http:start([{name, ?MODULE}, {loop, ?LOOP} | Options]).</p>
<p>[/erlang]</p>
<p>可以看到启动函数非常简单，那就是直接调用mochiweb_http模块的start函数。那么我们整个分析流程，就从这个模块的start函数开始。这里要注意，我们可以看到是将当前回调模块的loop函数传递给了mochiweb_http,这就给后续调用回调，提供了接口。</p>
<p>[erlang]</p>
<p>%% @spec start(Options) -&gt; ServerRet</p>
<p>%% Options = [option()]</p>
<p>%% Option = {name, atom()} | {ip, string() | tuple()} | {backlog, integer()}</p>
<p>%% | {nodelay, boolean()} | {acceptor_pool_size, integer()}</p>
<p>%% | {ssl, boolean()} | {profile_fun, undefined | (Props) -&gt; ok}</p>
<p>%% | {link, false}</p>
<p>%% @doc Start a mochiweb server.</p>
<p>%% profile_fun is used to profile accept timing.</p>
<p>%% After each accept, if defined, profile_fun is called with a proplist of a subset of the mochiweb_socket_server state and timing information.</p>
<p>%% The proplist is as follows: [{name, Name}, {port, Port}, {active_sockets, ActiveSockets}, {timing, Timing}].</p>
<p>%% @end</p>
<p>start(Options) -&gt;</p>
<p>mochiweb_socket_server:start(parse_options(Options)).</p>
<p>[/erlang]</p></div><p class="readmore"><a href="/2012/05/19/mochiweb-source-code-analysis-(1).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/04/28/nginx-configuration-file-parsing-in-detail.html">Nginx配置文件解析详解</a></h1><div class="post-meta">2012-04-28</div><div class="post-content"><p>Nginx的配置解析相关的部分比较绕，比如为何要有4重指针，比如NGX_MAIN_CONF ， loc_conf,NGX_DIRECT_CONF有什么区别呢?这些我前面的blog都有些涉及，这次主要是把配置这块完全拿出来然后来分析下。</p>
<p>首先来看配置解析时的数据结构，这里主要是ngx_conf_t，这个结构保存了解析配置文件所需要的一些域，这个是非常重要的一个数据结构，我们详细来看这个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct ngx_conf_s &#123;</span><br><span class="line">  </span><br><span class="line">//当前解析到的命令名</span><br><span class="line">      </span><br><span class="line">char *name;</span><br><span class="line">  </span><br><span class="line">//当前命令的所有参数</span><br><span class="line">      </span><br><span class="line">ngx_array_t *args;</span><br><span class="line"></span><br><span class="line">//使用的cycle</span><br><span class="line">      </span><br><span class="line">ngx_cycle_t *cycle;</span><br><span class="line">  </span><br><span class="line">//所使用的内存池</span><br><span class="line">      </span><br><span class="line">ngx_pool_t *pool;</span><br><span class="line">  </span><br><span class="line">//这个pool将会在配置解析完毕后释放。</span><br><span class="line">      </span><br><span class="line">ngx_pool_t *temp_pool;</span><br><span class="line">  </span><br><span class="line">//这个表示将要解析的配置文件</span><br><span class="line">      </span><br><span class="line">ngx_conf_file_t *conf_file;</span><br><span class="line">  </span><br><span class="line">//配置log</span><br><span class="line">      </span><br><span class="line">ngx_log_t *log;</span><br><span class="line"></span><br><span class="line">//主要为了提供模块的层次化(后续会详细介绍)</span><br><span class="line">      </span><br><span class="line">void *ctx;</span><br><span class="line">  </span><br><span class="line">//模块类型</span><br><span class="line">      </span><br><span class="line">ngx_uint_t module_type;</span><br><span class="line">  </span><br><span class="line">//命令类型</span><br><span class="line">      </span><br><span class="line">ngx_uint_t cmd_type;</span><br><span class="line"></span><br><span class="line">//模块自定义的handler</span><br><span class="line">      </span><br><span class="line">ngx_conf_handler_pt handler;</span><br><span class="line">  </span><br><span class="line">//自定义handler的conf</span><br><span class="line">      </span><br><span class="line">char *handler_conf;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2012/04/28/nginx-configuration-file-parsing-in-detail.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/04/08/source-code-analysis-of-hotwheels.html">hotwheels源码剖析</a></h1><div class="post-meta">2012-04-08</div><div class="post-content"><p>在霸爷的推荐下，看了hotwheels的代码，接下来我就来分析下hotwheels的代码(主要是server端代码)，hotwheels是干吗的呢，介绍在这里:</p>
<p><a href="https://github.com/tolbrino/hotwheels" target="_blank" rel="noopener">https://github.com/tolbrino/hotwheels</a></p>
<blockquote>
<p>Janus is a messaging server optimized to unicast over TCP to thousands of clients subscribed to topics of interest.</p>
<p>The ultimate goal is to maintain a latency of less than 2 seconds for 20 thousand clients on Amazon EC2 (small instance).</p>
</blockquote>
<p>首先来看janus.app：</p>
<p>[erlang]</p>
<p>{application, janus,</p>
<p>[{description, “Janus”},</p>
<p>{vsn, “0.0.1”},</p>
<p>{id, “janus”},</p>
<p>{modules, [barrier,</p>
<p>bin,</p>
<p>bot,</p>
<p>client_proxy,</p>
<p>common,</p>
<p>flashbot,</p>
<p>histo,</p>
<p>janus,</p>
<p>janus_acceptor,</p>
<p>janus_admin,</p>
<p>janus_app,</p>
<p>janus_flash,</p>
<p>launcher,</p>
<p>mapper,</p>
<p>pubsub,</p>
<p>topman,</p>
<p>t,</p>
<p>transport,</p>
<p>util</p>
<p>]},</p>
<p>{registered, [janus_sup,</p>
<p>janus_topman_sup,</p>
<p>janus_proxy_mapper_sup,</p>
<p>janus_transport_sup,</p>
<p>janus_listener]},</p>
<p>{applications, [kernel,</p>
<p>stdlib,</p>
<p>mnesia,</p>
<p>inets</p>
<p>]},</p>
<p>{mod, {janus_app, []}},</p>
<p>{env, []}</p>
<p>]</p>
<p>}.</p>
<p>[/erlang]</p></div><p class="readmore"><a href="/2012/04/08/source-code-analysis-of-hotwheels.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/03/21/design-and-implementation-of-cache-in-nginx-(1).html">nginx中cache的设计和实现(一)</a></h1><div class="post-meta">2012-03-21</div><div class="post-content"><p>Nginx的cache实现比较简单，没有使用内存，全部都是使用文件来对后端的response进行cache，因此nginx相比varnish以及squid之类的专门做cache的server，可能效果不会那么好。特别如果cache内容比较大的话。不过还有一种折衷的处理，那就是挂载一个内存盘，然后让nginx cache到这个盘。</p>
<p>我这里的看的代码是1.1.17.</p>
<p>首先来看Nginx中如何开启cache，http cache主要是应用在upstream中的，因此upstream对应的两个命令来启用cache，一个是xxx_cache_path(比如proxy_cache_path)，它主要是用来创建管理cache的共享内存数据结构(红黑树和队列).一个是xxx_cache,它主要是使用前面创建的zone。</p>
<p>先来看第一个命令，xxx_cache_path,它会调用ngx_http_file_cache_set_slot函数，在看这个函数之前，先来看ngx_http_file_cache_t这个数据结构，它主要用来管理所有的cache文件，它本身不保存cache，只是保存管理cache的数据结构。每一个xxx_cache_path都会创建一个ngx_http_file_cache_t.</p></div><p class="readmore"><a href="/2012/03/21/design-and-implementation-of-cache-in-nginx-(1).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/03/04/c-reference-manual-reading-notes-(5).html">c reference manual读书笔记(五)</a></h1><div class="post-meta">2012-03-04</div><div class="post-content"><p>这次主要是介绍一些c语言中的类型转换。</p>
<p>1 在c语言里面，除了位域之外所有的数据对象都是表示为一堆抽象的存储单元,每一个存储单元都是由很多位组成的，每位的值不是1就是0，并且每一个存储单元都必须有唯一的地址，并且他们的每一个的大小都是和char的大小一致。每个存储单元有多少位，c语言并没有要求，可是每个存储单元必须能够存储基本字符集的每一个字符。 在标准c中也称存储单元为byte。</p>
<p>2 c程序员一般来说不需要在意一些机器的对齐限制，因为编译器会做对齐操作，但是，c也给了程序员忽略对齐限制的能力，比如cast一个指针到另外的类型。不过这里要注意，假设你要将一个类型为S的指针转换成类型T的指针，此时如果S的对齐因子如果不小于T的对齐因子，那么这个转换就是安全的(也就是说此时你取T的值，是没问题的). 可是如果S的对齐因子如果小于T的对齐因子，此时会出现两种情况，第一种就是当使用转换后的指针时，直接出错。第二种就是硬件或者编译器来帮你找到一个合适的指针来使用这个地址。</p>
<p>3 c99中定义了指针类型uintptr_t和intptr_t这两个值并不是指针的大小，而是指针类型不会超过这两个值, 这里要注意，很多实现中函数指针和数据指针大小是不一样的。而NULL只是数据空指针。对象的值和对象类型的值是不一样的，因为会有一些padding，而这些padding是没有定义的，</p></div><p class="readmore"><a href="/2012/03/04/c-reference-manual-reading-notes-(5).html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2012/01/05/upstream-sharing-of-nginx.html">nginx的upstream分享</a></h1><div class="post-meta">2012-01-05</div><div class="post-content"><p>今天给同事做的分享.</p>
<div style="width:425px" id="__ss_10812822"><br>  <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/minibobo/upstream-design-andimplementationinnginx-1" title="Upstream design and_implementation_in_nginx" target="_blank">Upstream design and_implementation_in_nginx</a></strong> <p></p><br><br>  <div style="padding:5px 0 12px"><br>    View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/minibobo" target="_blank">monad bobo</a><br>  </div><p></p><br></div></div><p class="readmore"><a href="/2012/01/05/upstream-sharing-of-nginx.html">阅读全文</a></p></div><div class="post"><h1 class="post-title"><a href="/2011/10/22/introduction-to-spdy-protocol.html">SPDY协议介绍</a></h1><div class="post-meta">2011-10-22</div><div class="post-content"><p>SPDY的主页： <a href="http://www.chromium.org/spdy" target="_blank" rel="noopener">http://www.chromium.org/spdy</a></p>
<p>我主要看的是SPDY Protocol Drafts 3，这个草稿现在还没完成，google的人将它放在github上面: <a href="http://mbelshe.github.com/SPDY-Specification/" target="_blank" rel="noopener">http://mbelshe.github.com/SPDY-Specification/</a></p></div><p class="readmore"><a href="/2011/10/22/introduction-to-spdy-protocol.html">阅读全文</a></p></div><nav class="page-navigator"><a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/">下一页</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>