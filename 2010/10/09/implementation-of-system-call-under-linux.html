<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>linux下系统调用的实现 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux下系统调用的实现</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux下系统调用的实现</h1><div class="post-meta">Oct 9, 2010<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a></span></div><div class="post-content"><p>基本的x86体系下系统调用相关的指令可以看<a href="http://blog.csdn.net/yayong/archive/2005/07/07/416477.aspx" target="_blank" rel="noopener">这篇</a>文章。</p>
<p>x86下，最早是使用软中断指令int 0×80来做的，不过现在内核是使用syscall和sysenter指令，只有64位下才会使用syscall,而大部分情况都是使用sysenter,这里我们主要介绍sysenter指令，不过具体实现3者现在都差不多，这是因为内核使用了VDSO来兼容所有的指令，接下来我们就要来详细的分析内核是如何实现vdso层，以及glibc库(也就是用户空间)是如何来调用vdso层的接口，从而进入内核。</p>
<a id="more"></a>
<p>首先来看glibc的代码，下面这段代码就是syscall的实现，位置是在sysdeps/unix/sysv/linux/i386/syscall.S这个文件里面。这段汇编很简单，就是保存寄存器，然后讲参数，系统调用号入站，最后调用ENTER_KERNEL进入内核。所以这里最关键的就是ENTER_KERNEL这个宏。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ENTRY (syscall)</span><br><span class="line"></span><br><span class="line">PUSHARGS_6 /\* Save register contents. \*/</span><br><span class="line">	  </span><br><span class="line">_DOARGS_6(44) /\* Load arguments. \*/</span><br><span class="line">	  </span><br><span class="line">movl 20(%esp), %eax /\* Load syscall number into %eax. \*/</span><br><span class="line">	  </span><br><span class="line">ENTER_KERNEL /\* Do the system call. \*/</span><br><span class="line">	  </span><br><span class="line">POPARGS_6 /\* Restore register contents. \*/</span><br><span class="line">	  </span><br><span class="line">cmpl $-4095, %eax /\* Check %eax for error. \*/</span><br><span class="line">	  </span><br><span class="line">jae SYSCALL_ERROR_LABEL /\* Jump to error handler if error. \*/</span><br><span class="line">  </span><br><span class="line">L(pseudo_end):</span><br><span class="line">	  </span><br><span class="line">ret /\* Return to caller. \*/</span><br><span class="line"></span><br><span class="line">PSEUDO_END (syscall)</span><br></pre></td></tr></table></figure>
<p>接下来我们就来看ENTER_KERNEL这个宏的实现，这个宏主要就是用来进入内核，通过vdso调用内核对应的系统调用接口，从而达到执行系统调用的目的。</p>
<p>通过下面的代码我们可以看到通过宏I386_USE_SYSENTER来决定是否使用快速系统调用，这里这个宏就不详细分析了，只需要知道他主要是通过makefile中的参数进行控制的就可以了。</p>
<p>如果I386_USE_SYSENTER没有定义，则说明不使用快速系统调用，此时使用老的方法，也就是使用软中断指令int $0×80来进入内核，而如果使用快速系统调用则通过SHARED宏来决定使用那种方式来得到vdso的页地址(也就是内核实现的系统调用的页,这个后面会详细介绍).这里接下来会详细分析SHARED打开的情况，也就是最常用的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#ifdef I386_USE_SYSENTER</span><br><span class="line">  </span><br><span class="line">\# ifdef SHARED</span><br><span class="line">  </span><br><span class="line">\# define ENTER_KERNEL call *%gs:SYSINFO_OFFSET</span><br><span class="line">  </span><br><span class="line">\# else</span><br><span class="line">  </span><br><span class="line">\# define ENTER_KERNEL call *_dl_sysinfo</span><br><span class="line">  </span><br><span class="line">\# endif</span><br><span class="line">  </span><br><span class="line">#else</span><br><span class="line">  </span><br><span class="line">\# define ENTER_KERNEL int $0x80</span><br><span class="line">  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>因此这里最关键就是call *%gs:SYSINFO_OFFSET这段汇编了，首先我们知道寄存器%gs里面保存的是TLS(Thread Local Storage),然后SYSINFO_OFFSET是在nptl/sysdeps/i386/tcb-offsets.sym里面定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">SYSINFO_OFFSET offsetof (tcbhead_t, sysinfo)</span><br></pre></td></tr></table></figure>
<p>下面就是 tcbhead_t的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">void \*tcb; /\* Pointer to the TCB. Not necessarily the</span><br><span class="line">			     </span><br><span class="line">thread descriptor used by libpthread. */</span><br><span class="line">    </span><br><span class="line">dtv_t *dtv;</span><br><span class="line">    </span><br><span class="line">void \*self; /\* Pointer to the thread descriptor. */</span><br><span class="line">    </span><br><span class="line">int multiple_threads;</span><br><span class="line">  </span><br><span class="line">//SYSINFO_OFFSET也就是他的偏移。</span><br><span class="line">    </span><br><span class="line">uintptr_t sysinfo;</span><br><span class="line">    </span><br><span class="line">uintptr_t stack_guard;</span><br><span class="line">    </span><br><span class="line">uintptr_t pointer_guard;</span><br><span class="line">    </span><br><span class="line">int gscope_flag;</span><br><span class="line">  </span><br><span class="line">#ifndef __ASSUME_PRIVATE_FUTEX</span><br><span class="line">    </span><br><span class="line">int private_futex;</span><br><span class="line">  </span><br><span class="line">#else</span><br><span class="line">    </span><br><span class="line">int __unused1;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">    </span><br><span class="line">/\* Reservation of some values for the TM ABI. \*/</span><br><span class="line">    </span><br><span class="line">void *__private_tm[5];</span><br><span class="line">  </span><br><span class="line">&#125; tcbhead_t;</span><br></pre></td></tr></table></figure>
<p>通过上面的计算我们能够得到SYSINFO_OFFSET的值就是0×10,这里也就是调用tcbhead_t的sysinfo的值，而tcbhead_t.sysinfo这个值是在那里赋值的呢，看下面的代码，nptl/sysdeps/i386/tls.h:</p>
<p>这里TLS_INIT_TP是用来初始化一个thread pointer，而其中就将tcb的头进行了初始化，而头的sysinfo域是通过INIT_SYSINFO进行初始化的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">\# define TLS_INIT_TP(thrdescr, secondcall) \</span><br><span class="line">    </span><br><span class="line">(&#123; void *_thrdescr = (thrdescr); \</span><br><span class="line">       </span><br><span class="line">tcbhead_t *_head = _thrdescr; \</span><br><span class="line">       </span><br><span class="line">union user_desc_init _segdescr; \</span><br><span class="line">       </span><br><span class="line">int _result; \</span><br><span class="line">									        </span><br><span class="line">\</span><br><span class="line">       </span><br><span class="line">_head-&gt;tcb = _thrdescr; \</span><br><span class="line">       </span><br><span class="line">/\* For now the thread descriptor is at the same address. \*/ \</span><br><span class="line">       </span><br><span class="line">_head-&gt;self = _thrdescr; \</span><br><span class="line">       </span><br><span class="line">/\* New syscall handling support. \*/ \</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">#if defined NEED_DL_SYSINFO</span><br><span class="line">  </span><br><span class="line">\# define INIT_SYSINFO \</span><br><span class="line">  </span><br><span class="line">//可以看到它的值就是dl_sysinfo的地址</span><br><span class="line">    </span><br><span class="line">_head-&gt;sysinfo = GLRO(dl_sysinfo)</span><br><span class="line">  </span><br><span class="line">#else</span><br><span class="line">  </span><br><span class="line">\# define INIT_SYSINFO</span><br><span class="line">  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>接下来就是dl_sysinfo的值了，它是在函数_dl_sysdep_start （elf/dl-sysdep.c)中被赋值的，而_dl_sysdep_start这个函数是干吗的呢，glibc的注释写的很清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/* Call the OS-dependent function to set up life so we can do things like</span><br><span class="line">  </span><br><span class="line">file access. It will call \`dl_main’ (below) to do all the real work</span><br><span class="line">  </span><br><span class="line">of the dynamic linker, and then unwind our frame and run the user</span><br><span class="line">  </span><br><span class="line">entry point on the same stack we entered on. */</span><br></pre></td></tr></table></figure>
<p>我的理解就是得到一些依赖os的函数的地址(动态库)，然后放到对应的段，以便与后面存取。</p>
<p>下面就是对应的代码片段。这里可以看到它是通过判断函数的类型来进行不同的操作，这里我们节选我们感兴趣的sysinfo部分，这里可以看到sysinfo的类型就是AT_SYSINFO。这里一般来说取的就是ELF auxiliary vectors的值，也就是说内核会把相关的信息放到ELF auxiliary vectors中。而什么是ELF auxiliary vectors，这里介绍的比较详细：</p>
<p><a href="http://articles.manugarg.com/aboutelfauxiliaryvectors.html" target="_blank" rel="noopener">http://articles.manugarg.com/aboutelfauxiliaryvectors.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define AT_SYSINFO 32</span><br><span class="line">  </span><br><span class="line">#ifdef NEED_DL_SYSINFO</span><br><span class="line">        </span><br><span class="line">case AT_SYSINFO:</span><br><span class="line">	  </span><br><span class="line">new_sysinfo = av-&gt;a_un.a_val;</span><br><span class="line">	  </span><br><span class="line">break;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">#if defined NEED_DL_SYSINFO</span><br><span class="line">    </span><br><span class="line">/\* Only set the sysinfo value if we also have the vsyscall DSO. \*/</span><br><span class="line">    </span><br><span class="line">if (GLRO(dl_sysinfo_dso) != 0 &amp;&amp; new_sysinfo)</span><br><span class="line">      </span><br><span class="line">GLRO(dl_sysinfo) = new_sysinfo;</span><br><span class="line">  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>接下来就该到内核了，也就是说AT_SYSINFO类型对应的到底是那里。</p>
<p>在看内核代码之前，我们先来了解下vdso的结构，首先我们随便ldd一个可执行文件，下面是我的机器上的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ldd nginx</span><br><span class="line">	  </span><br><span class="line">linux-gate.so.1 =&gt; (0xb77d9000)</span><br><span class="line">	  </span><br><span class="line">libcrypt.so.1 =&gt; /lib/libcrypt.so.1 (0xb778a000)</span><br><span class="line">	  </span><br><span class="line">libpcre.so.0 =&gt; /lib/libpcre.so.0 (0xb7753000)</span><br><span class="line">	  </span><br><span class="line">libcrypto.so.1.0.0 =&gt; /usr/lib/libcrypto.so.1.0.0 (0xb75d9000)</span><br><span class="line">	  </span><br><span class="line">libz.so.1 =&gt; /usr/lib/libz.so.1 (0xb75c4000)</span><br><span class="line">	  </span><br><span class="line">libperl.so =&gt; /usr/lib/perl5/core_perl/CORE/libperl.so (0xb746c000)</span><br><span class="line">	  </span><br><span class="line">libnsl.so.1 =&gt; /lib/libnsl.so.1 (0xb7455000)</span><br><span class="line">	  </span><br><span class="line">libdl.so.2 =&gt; /lib/libdl.so.2 (0xb7451000)</span><br><span class="line">	  </span><br><span class="line">libm.so.6 =&gt; /lib/libm.so.6 (0xb742c000)</span><br><span class="line">	  </span><br><span class="line">libutil.so.1 =&gt; /lib/libutil.so.1 (0xb7428000)</span><br><span class="line">	  </span><br><span class="line">libpthread.so.0 =&gt; /lib/libpthread.so.0 (0xb740e000)</span><br><span class="line">	  </span><br><span class="line">libc.so.6 =&gt; /lib/libc.so.6 (0xb72c2000)</span><br><span class="line">	  </span><br><span class="line">/lib/ld-linux.so.2 (0xb77da000)</span><br></pre></td></tr></table></figure>
<p>这里我们看到有一个linux-gate.so.1的动态库，这个库其实是不存在的，而它其实就是一块内存，其中包括了vdso生成的系统调用的代码，也就是说内核mmap这块内存(其实这快内存也就是完全遵循elf格式)到用户空间，然后ldd将它作为动态库来处理，此时用户空间就很容易来执行这块内存的代码。</p>
<p>有关vdso的部分这篇也是介绍的不错，可以看看。</p>
<p>在初始化的时候，内核会判断系统之不支持快速系统调用，如果支持的话则将快速系统调用相关的代码拷贝到将要mmap的内存，否则就拷贝软中断指令。来看代码，是在arch/x86/vdso/vdso32-setup.c的sysenter_setup函数。</p>
<p>这个函数就是判断支持那些指令，然后做不同的处理，可以看到最优先处理的就是syscall，然后是sysenter,最后是int80，这里我们主要来看sysenter，这里可以看到是将vdso32_sysenter_start的地址付给vsyscall ，然后将vsyscall的内容拷贝到对应的页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">int __init sysenter_setup(void)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">void \*syscall_page = (void \*)get_zeroed_page(GFP_ATOMIC);</span><br><span class="line">	  </span><br><span class="line">const void *vsyscall;</span><br><span class="line">	  </span><br><span class="line">size_t vsyscall_len;</span><br><span class="line">  </span><br><span class="line">//得到对应的页</span><br><span class="line">	  </span><br><span class="line">vdso32_pages[0] = virt_to_page(syscall_page);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">	  </span><br><span class="line">gate_vma_init();</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//开始决定使用那种方式</span><br><span class="line">	  </span><br><span class="line">if (vdso32_syscall()) &#123;</span><br><span class="line">		  </span><br><span class="line">vsyscall = &amp;vdso32_syscall_start;</span><br><span class="line">		  </span><br><span class="line">vsyscall_len = &amp;vdso32_syscall_end &amp;#8211; &amp;vdso32_syscall_start;</span><br><span class="line">	  </span><br><span class="line">&#125; else if (vdso32_sysenter())&#123;</span><br><span class="line">		  </span><br><span class="line">vsyscall = &amp;vdso32_sysenter_start;</span><br><span class="line">		  </span><br><span class="line">vsyscall_len = &amp;vdso32_sysenter_end &amp;#8211; &amp;vdso32_sysenter_start;</span><br><span class="line">	  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">		  </span><br><span class="line">vsyscall = &amp;vdso32_int80_start;</span><br><span class="line">		  </span><br><span class="line">vsyscall_len = &amp;vdso32_int80_end &amp;#8211; &amp;vdso32_int80_start;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拷贝到对应的页</span><br><span class="line">	  </span><br><span class="line">memcpy(syscall_page, vsyscall, vsyscall_len);</span><br><span class="line">  </span><br><span class="line">//重定向。</span><br><span class="line">	  </span><br><span class="line">relocate_vdso(syscall_page);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是来看vdso32_sysenter_start到底是什么东西，它的定义是在arch/x86/vdso/vdso32.S中的。可以看到这里vdso32_sysenter_start代表的内容也就是vdso32-sysenter.so，也就是说上面代码就是拷贝vdso32-sysenter.so到对应的页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">vdso32_sysenter_start:</span><br><span class="line">	  </span><br><span class="line">.incbin &amp;quot;arch/x86/vdso/vdso32-sysenter.so&amp;quot;</span><br></pre></td></tr></table></figure>
<p>然后就是在fs/binfmt_elf.c文件的load_elf_binary函数中加载对应的vdso32-sysenter.so文件到内存，然后调用arch_setup_additional_pages将vsdo映射到用户空间，因此我们来看arch_setup_additional_pages这个函数，这个函数很简单就是映射上面copy的页的内容到用户空间。</p>
<p>这里有个需要注意的就是VDSO_HIGH_BASE这个值，其实我们上面拷贝完so之后会有一个重定向(relocate_vdso)，这个重定向会将vdso的地址重定向到这里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">int arch_setup_additional_pages(struct linux_binprm *bprm, int uses_interp)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct mm_struct *mm = current-&gt;mm;</span><br><span class="line">	  </span><br><span class="line">unsigned long addr;</span><br><span class="line">	  </span><br><span class="line">int ret = 0;</span><br><span class="line">	  </span><br><span class="line">bool compat;</span><br><span class="line"></span><br><span class="line">if (vdso_enabled == VDSO_DISABLED)</span><br><span class="line">		  </span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">down_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">/* Test compat mode once here, in case someone</span><br><span class="line">	     </span><br><span class="line">changes it via sysctl */</span><br><span class="line">	  </span><br><span class="line">compat = (vdso_enabled == VDSO_COMPAT);</span><br><span class="line"></span><br><span class="line">map_compat_vdso(compat);</span><br><span class="line"></span><br><span class="line">if (compat)</span><br><span class="line">		  </span><br><span class="line">addr = VDSO_HIGH_BASE;</span><br><span class="line">	  </span><br><span class="line">else &#123;</span><br><span class="line">		  </span><br><span class="line">addr = get_unmapped_area(NULL, 0, PAGE_SIZE, 0, 0);</span><br><span class="line">		  </span><br><span class="line">if (IS_ERR_VALUE(addr)) &#123;</span><br><span class="line">			  </span><br><span class="line">ret = addr;</span><br><span class="line">			  </span><br><span class="line">goto up_fail;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置vdso的地址为addr也就是我们前面设置的VDSO_HIGH_BASE</span><br><span class="line">	  </span><br><span class="line">current-&gt;mm-&gt;context.vdso = (void *)addr;</span><br><span class="line"></span><br><span class="line">if (compat_uses_vma || !compat) &#123;</span><br><span class="line">		  </span><br><span class="line">/*</span><br><span class="line">		   </span><br><span class="line">* MAYWRITE to allow gdb to COW and set breakpoints</span><br><span class="line">		   </span><br><span class="line">*</span><br><span class="line">		   </span><br><span class="line">* Make sure the vDSO gets into every core dump.</span><br><span class="line">		   </span><br><span class="line">* Dumping its contents makes post-mortem fully</span><br><span class="line">		   </span><br><span class="line">* interpretable later without matching up the same</span><br><span class="line">		   </span><br><span class="line">* kernel and hardware config to see what PC values</span><br><span class="line">		   </span><br><span class="line">* meant.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">ret = install_special_mapping(mm, addr, PAGE_SIZE,</span><br><span class="line">					        </span><br><span class="line">VM_READ|VM_EXEC|</span><br><span class="line">					        </span><br><span class="line">VM_MAYREAD|VM_MAYWRITE|VM_MAYEXEC|</span><br><span class="line">					        </span><br><span class="line">VM_ALWAYSDUMP,</span><br><span class="line">					        </span><br><span class="line">vdso32_pages);</span><br><span class="line"></span><br><span class="line">if (ret)</span><br><span class="line">			  </span><br><span class="line">goto up_fail;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current_thread_info()-&gt;sysenter_return =</span><br><span class="line">		  </span><br><span class="line">VDSO32_SYMBOL(addr, SYSENTER_RETURN);</span><br><span class="line"></span><br><span class="line">up_fail:</span><br><span class="line">	  </span><br><span class="line">if (ret)</span><br><span class="line">		  </span><br><span class="line">current-&gt;mm-&gt;context.vdso = NULL;</span><br><span class="line"></span><br><span class="line">up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而最关键的部分就是系统调用的实现部分是在arch/x86/vdso/vdso32/sysenter.S中的，也就是__kernel_vsyscall，linux会编译(可以看vdso下面的Makefile)它为一个so，然后供上面使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">.globl __kernel_vsyscall</span><br><span class="line">	  </span><br><span class="line">.type __kernel_vsyscall,@function</span><br><span class="line">	  </span><br><span class="line">ALIGN</span><br><span class="line">  </span><br><span class="line">__kernel_vsyscall:</span><br><span class="line">  </span><br><span class="line">.LSTART_vsyscall:</span><br><span class="line">	  </span><br><span class="line">push %ecx</span><br><span class="line">  </span><br><span class="line">.Lpush_ecx:</span><br><span class="line">	  </span><br><span class="line">push %edx</span><br><span class="line">  </span><br><span class="line">.Lpush_edx:</span><br><span class="line">	  </span><br><span class="line">push %ebp</span><br><span class="line">  </span><br><span class="line">.Lenter_kernel:</span><br><span class="line">	  </span><br><span class="line">movl %esp,%ebp</span><br><span class="line">	  </span><br><span class="line">sysenter</span><br></pre></td></tr></table></figure>
<p>然后是arch/x86/vdso/vdso32/vdso32.ld.S中的也就是定义上面的__kernel_vsyscall为VDSO32_vsyscall这个名字，这里其实就是个别名了，到后面这个别名会用到，也就是在动态库中使用的就是VDSO32_vsyscall表示调用系统调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">VDSO32_PRELINK = VDSO_PRELINK;</span><br><span class="line">  </span><br><span class="line">VDSO32_vsyscall = __kernel_vsyscall;</span><br><span class="line">  </span><br><span class="line">VDSO32_sigreturn = __kernel_sigreturn;</span><br><span class="line">  </span><br><span class="line">VDSO32_rt_sigreturn = __kernel_rt_sigreturn;</span><br></pre></td></tr></table></figure>
<p>然后我们就来看内核和glibc库如何关联起来，这里关键也就是类型AT_SYSINFO对应的内容是什么，因此我们搜索内核代码，发现了下面这部分，这个宏也就是设置类型为AT_SYSINFO的内容以便与用户空间存取。</p>
<p>这里的原理是这样的，内核在装载镜像的时候会将这快(系统调用相关的)拷贝到用户空间，然后将对应的地址拷贝到ELF auxiliary vectors以供用户空间使用。</p>
<p>内核会将所需要的信息比如sysinfo地址放到ELF auxiliary vectors(一般来说都是键值对)，然后用户空间就可以很简单的取到所需要的函数的地址，而这里NEW_AUX_ENT就是将类型地址的键值对放到ELF auxiliary vectors。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define ARCH_DLINFO_IA32(vdso_enabled) \</span><br><span class="line">  </span><br><span class="line">do &#123; \</span><br><span class="line">	  </span><br><span class="line">if (vdso_enabled) &#123; \</span><br><span class="line">		  </span><br><span class="line">NEW_AUX_ENT(AT_SYSINFO, VDSO_ENTRY); \</span><br><span class="line">		  </span><br><span class="line">NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_CURRENT_BASE); \</span><br><span class="line">	  </span><br><span class="line">&#125; \</span><br><span class="line">  </span><br><span class="line">&#125; while (0)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">  </span><br><span class="line">//x86_32调用ARCH_DLINFO_IA32。</span><br><span class="line">  </span><br><span class="line">#define ARCH_DLINFO ARCH_DLINFO_IA32(vdso_enabled)</span><br></pre></td></tr></table></figure>
<p>然后来看NEW_AUX_ENT是干吗的，这个宏主要是将对应的信息按照elf的格式进行设置。而它的定义的地方和ARCH_DLINFO调用的地方一致，那就是create_elf_fdpic_tables中。</p>
<p>可以看到NEW_AUX_ENT很简单，就是拷贝对应的值到用户空间的ELF auxiliary vectors。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int create_elf_fdpic_tables(struct linux_binprm *bprm,</span><br><span class="line">				     </span><br><span class="line">struct mm_struct *mm,</span><br><span class="line">				     </span><br><span class="line">struct elf_fdpic_params *exec_params,</span><br><span class="line">				     </span><br><span class="line">struct elf_fdpic_params *interp_params)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">#define NEW_AUX_ENT(id, val) \</span><br><span class="line">	  </span><br><span class="line">do &#123; \</span><br><span class="line">		  </span><br><span class="line">struct &#123; unsigned long _id, _val; &#125; __user *ent; \</span><br><span class="line">									  </span><br><span class="line">\</span><br><span class="line">		  </span><br><span class="line">ent = (void __user *) csp; \</span><br><span class="line">  </span><br><span class="line">//拷贝对应的id和value到用户空间.</span><br><span class="line">		  </span><br><span class="line">__put_user((id), &amp;ent[nr]._id); \</span><br><span class="line">		  </span><br><span class="line">__put_user((val), &amp;ent[nr]._val); \</span><br><span class="line">		  </span><br><span class="line">nr++; \</span><br><span class="line">	  </span><br><span class="line">&#125; while (0)</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">	  </span><br><span class="line">NEW_AUX_ENT(AT_EGID, (elf_addr_t) cred-&gt;egid);</span><br><span class="line">	  </span><br><span class="line">NEW_AUX_ENT(AT_SECURE, security_bprm_secureexec(bprm));</span><br><span class="line">	  </span><br><span class="line">NEW_AUX_ENT(AT_EXECFN, bprm-&gt;exec);</span><br><span class="line"></span><br><span class="line">#ifdef ARCH_DLINFO</span><br><span class="line">	  </span><br><span class="line">nr = 0;</span><br><span class="line">	  </span><br><span class="line">csp -= AT_VECTOR_SIZE_ARCH \* 2 \* sizeof(unsigned long);</span><br><span class="line"></span><br><span class="line">/* ARCH_DLINFO must come last so platform specific code can enforce</span><br><span class="line">	   </span><br><span class="line">* special alignment requirements on the AUXV if necessary (eg. PPC).</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">  </span><br><span class="line">//调用ARCH_DLINFO完成sysinfo的拷贝</span><br><span class="line">	  </span><br><span class="line">ARCH_DLINFO;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br></pre></td></tr></table></figure>
<p>最后我们就来看拷贝的是什么东西。可以看到上面的参数是AT_SYSINFO, VDSO_ENTRY第一个是id，第二个是VDSO_ENTRY，第一个我们知道就是glibc中的type，而第二个呢，来看内核的代码，其实很简单VDSO_ENTRY就是表示VDSO32_vsyscall这个符号的地址，而这个符号我们知道就是__kernel_vsyscall，也就是系统调用的实现函数。这下完全清楚了，那就是上面的glibc的ENTER_KERNEL最终调用的就是内核的__kernel_vsyscall。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define VDSO_ENTRY \</span><br><span class="line">	  </span><br><span class="line">((unsigned long)VDSO32_SYMBOL(VDSO_CURRENT_BASE, vsyscall))</span><br><span class="line"></span><br><span class="line">#define VDSO32_SYMBOL(base, name) \</span><br><span class="line">  </span><br><span class="line">(&#123; \</span><br><span class="line">	  </span><br><span class="line">extern const char VDSO32_##name[]; \</span><br><span class="line">	  </span><br><span class="line">(void *)(VDSO32_##name &amp;#8211; VDSO32_PRELINK + (unsigned long)(base)); \</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>总结一下，大体的过程是这样子的，内核在运行的时候会动态加载一个so到物理页，然后会将这个物理页映射到用户空间，并且会将里面的函数根据类型设置到ELF Auxiliary Vectors，然后glibc调用的时候就可以通过ELF Auxiliary Vectors来取得对应系统调用函数。</p>
</div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/glibc/">glibc</a><a href="/tags/systemcall/">systemcall</a></div><div class="post-nav"><a class="pre" href="/2010/10/14/.html">linux kernel 2.6.35中RFS特性详解</a><a class="next" href="/2010/10/02/.html">linux kernel中如何得到当前的进程信息</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/design-and-implementation-of-redo-log-in-innodb-(i).html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>