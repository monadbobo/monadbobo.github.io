<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>linux kernel 2.6.35中RFS特性详解 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux kernel 2.6.35中RFS特性详解</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux kernel 2.6.35中RFS特性详解</h1><div class="post-meta">Oct 14, 2010<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a></span></div><div class="post-content"><p>前面我介绍过google对内核协议栈的patch，RPS,它主要是为了软中断的负载均衡，这次继续来介绍google 的对RPS的增强path RFS(receive flow steering),RPS是把软中断map到对应cpu，而这个时候还会有另外的性能影响，那就是如果应用程序所在的cpu和软中断处理的cpu不是同一个，此时对于cpu cache的影响会很大。 这里要注意，在kernel 的2.6.35中 这两个patch已经加入了。</p>
<p>ok,先来描述下它是怎么做的，其实这个补丁很简单，想对于rps来说就是添加了一个cpu的选择，也就是说我们需要根据应用程序的cpu来选择软中断需要被处理的cpu。这里做法是当调用recvmsg的时候，应用程序的cpu会被存储在一个hash table中，而索引是根据socket的rxhash进行计算的。而这个rxhash就是RPS中计算得出的那个skb的hash值.</p>
<p>可是这里会有一个问题，那就是当多个线程或者进程读取相同的socket的时候，此时就会导致cpu id不停的变化，从而导致大量的OOO的数据包(这是因为cpu id变化，导致下面软中断不停的切换到不同的cpu，此时就会导致大量的乱序的包).</p>
<a id="more"></a>
<p>而RFS是如何解决这个问题的呢，它做了两个表rps_sock_flow_table和rps_dev_flow_table，其中第一个rps_sock_flow_table是一个全局的hash表，这个表针对socket的，映射了socket对应的cpu，这里的cpu就是应用层期待软中断所在的cpu。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct rps_sock_flow_table &#123;</span><br><span class="line">	  </span><br><span class="line">unsigned int mask;</span><br><span class="line">  </span><br><span class="line">//hash表</span><br><span class="line">	  </span><br><span class="line">u16 ents[0];</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到它有两个域，其中第一个是掩码，用于来计算hash表的索引，而ents就是保存了对应socket的cpu。</p>
<p>然后是rps_dev_flow_table,这个是针对设备的，每个设备队列都含有一个rps_dev_flow_table(这个表主要是保存了上次处理相同链接上的skb所在的cpu),这个hash表中每一个元素包含了一个cpu id，一个tail queue的计数器，这个值是一个很关键的值，它主要就是用来解决上面大量OOO的数据包的问题的，它保存了当前的dev flow table需要处理的数据包的尾部计数。接下来我们会详细分析这个东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct netdev_rx_queue &#123;</span><br><span class="line">	  </span><br><span class="line">struct rps_map *rps_map;</span><br><span class="line">  </span><br><span class="line">//每个设备的队列保存了一个rps_dev_flow_table</span><br><span class="line">	  </span><br><span class="line">struct rps_dev_flow_table *rps_flow_table;</span><br><span class="line">	  </span><br><span class="line">struct kobject kobj;</span><br><span class="line">	  </span><br><span class="line">struct netdev_rx_queue *first;</span><br><span class="line">	  </span><br><span class="line">atomic_t count;</span><br><span class="line">  </span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">struct rps_dev_flow_table &#123;</span><br><span class="line">	  </span><br><span class="line">unsigned int mask;</span><br><span class="line">	  </span><br><span class="line">struct rcu_head rcu;</span><br><span class="line">	  </span><br><span class="line">struct work_struct free_work;</span><br><span class="line">  </span><br><span class="line">//hash表</span><br><span class="line">	  </span><br><span class="line">struct rps_dev_flow flows[0];</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct rps_dev_flow &#123;</span><br><span class="line">	  </span><br><span class="line">u16 cpu;</span><br><span class="line">	  </span><br><span class="line">u16 fill;</span><br><span class="line">  </span><br><span class="line">//tail计数。</span><br><span class="line">	  </span><br><span class="line">unsigned int last_qtail;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先我们知道，大量的OOO的数据包的引起是因为多个进程同时请求相同的socket，而此时会导致这个socket对应的cpu id不停的切换，然后软中断如果不做处理，只是简单的调度软中断到不同的cpu，就会导致顺序的数据包被分发到不同的cpu，由于是smp，因此会导致大量的OOO的数据包，而在RFS中是这样解决这个问题的，在soft_net中添加了2个域,input_queue_head和input_queue_tail，然后在设备队列中添加了rps_flow_table，而rps_flow_table中的元素rps_dev_flow包含有一个last_qtail，RFS就通过这3个域来控制乱序的数据包。</p>
<p>这里为什么需要3个值呢，这是因为每个cpu上的队列的个数input_queue_tail是一直增加的，而设备每一个队列中的flow table对应的skb则是有可能会被调度到另外的cpu，而dev flow table的last_qtail表示当前的flow table所需要处理的数据包队列(backlog queue)的尾部队列计数,也就是说当input_queue_head大于等于它的时候说明当前的flow table可以切换了，否则的话不能切换到进程期待的cpu。</p>
<p>不过这里还要注意就是最好能够绑定进程到指定的cpu(配合rps和rfs的参数设置)，这样的话，rfs和rps的效率会更好，所以我认为像erlang这种在rfs和rps下性能应该提高非常大的.</p>
<p>下面就是softnet_data 的结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct softnet_data &#123;</span><br><span class="line">	  </span><br><span class="line">struct Qdisc *output_queue;</span><br><span class="line">	  </span><br><span class="line">struct Qdisc **output_queue_tailp;</span><br><span class="line">	  </span><br><span class="line">struct list_head poll_list;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *completion_queue;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff_head process_queue;</span><br><span class="line"></span><br><span class="line">/\* stats \*/</span><br><span class="line">	  </span><br><span class="line">unsigned int processed;</span><br><span class="line">	  </span><br><span class="line">unsigned int time_squeeze;</span><br><span class="line">	  </span><br><span class="line">unsigned int cpu_collision;</span><br><span class="line">	  </span><br><span class="line">unsigned int received_rps;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_RPS</span><br><span class="line">	  </span><br><span class="line">struct softnet_data *rps_ipi_list;</span><br><span class="line"></span><br><span class="line">/\* Elements below can be accessed between CPUs for RPS \*/</span><br><span class="line">	  </span><br><span class="line">struct call_single_data csd ____cacheline_aligned_in_smp;</span><br><span class="line">	  </span><br><span class="line">struct softnet_data *rps_ipi_next;</span><br><span class="line">	  </span><br><span class="line">unsigned int cpu;</span><br><span class="line">  </span><br><span class="line">//最关键的两个域</span><br><span class="line">	  </span><br><span class="line">unsigned int input_queue_head;</span><br><span class="line">	  </span><br><span class="line">unsigned int input_queue_tail;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">	  </span><br><span class="line">unsigned dropped;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff_head input_pkt_queue;</span><br><span class="line">	  </span><br><span class="line">struct napi_struct backlog;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来我们来看代码，来看内核是如何实现的，先来看inet_recvmsg,也就是调用rcvmsg时，内核会调用的函数,这个函数比较简单，就是多加了一行代码sock_rps_record_flow,这个函数主要是将本socket和cpu设置到rps_sock_flow_table这个hash表中。</p>
<p>首先要提一下，这里这两个flow table的初始化都是放在sys中初始化的，不过sys部分相关的代码我就不分析了，因为具体的逻辑和原理都是在协议栈部分实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">int inet_recvmsg(struct kiocb \*iocb, struct socket \*sock, struct msghdr *msg,</span><br><span class="line">		   </span><br><span class="line">size_t size, int flags)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct sock *sk = sock-&gt;sk;</span><br><span class="line">	  </span><br><span class="line">int addr_len = 0;</span><br><span class="line">	  </span><br><span class="line">int err;</span><br><span class="line">  </span><br><span class="line">//设置hash表</span><br><span class="line">	  </span><br><span class="line">sock_rps_record_flow(sk);</span><br><span class="line"></span><br><span class="line">err = sk-&gt;sk_prot-&gt;recvmsg(iocb, sk, msg, size, flags &amp; MSG_DONTWAIT,</span><br><span class="line">				     </span><br><span class="line">flags &amp; ~MSG_DONTWAIT, &amp;addr_len);</span><br><span class="line">	  </span><br><span class="line">if (err &gt;= 0)</span><br><span class="line">		  </span><br><span class="line">msg-&gt;msg_namelen = addr_len;</span><br><span class="line">	  </span><br><span class="line">return err;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是rps_record_sock_flow，这个函数主要是得到全局的rps_sock_flow_table，然后调用rps_record_sock_flow来对rps_sock_flow_table进行设置，这里会将socket的sk_rxhash传递进去当作hash的索引，而这个sk_rxhash其实就是skb里面的rxhash，skb的rxhash就是rps中设置的hash值，这个值是根据四元组进行hash的。这里用这个当索引一个是为了相同的socket都能落入一个index。而且下面的软中断上下文也比较容易存取这个hash表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct rps_sock_flow_table *rps_sock_flow_table __read_mostly;</span><br><span class="line">  </span><br><span class="line">static inline void sock_rps_record_flow(const struct sock *sk)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">#ifdef CONFIG_RPS</span><br><span class="line">	  </span><br><span class="line">struct rps_sock_flow_table *sock_flow_table;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">	  </span><br><span class="line">sock_flow_table = rcu_dereference(rps_sock_flow_table);</span><br><span class="line">  </span><br><span class="line">//设置hash表</span><br><span class="line">	  </span><br><span class="line">rps_record_sock_flow(sock_flow_table, sk-&gt;sk_rxhash);</span><br><span class="line">	  </span><br><span class="line">rcu_read_unlock();</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实所有的事情都是rps_record_sock_flow中做的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static inline void rps_record_sock_flow(struct rps_sock_flow_table *table,</span><br><span class="line">					  </span><br><span class="line">u32 hash)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">if (table &amp;&amp; hash) &#123;</span><br><span class="line">  </span><br><span class="line">//获取索引。</span><br><span class="line">		  </span><br><span class="line">unsigned int cpu, index = hash &amp; table-&gt;mask;</span><br><span class="line"></span><br><span class="line">/\* We only give a hint, preemption can change cpu under us \*/</span><br><span class="line">  </span><br><span class="line">//获取cpu</span><br><span class="line">		  </span><br><span class="line">cpu = raw_smp_processor_id();</span><br><span class="line">  </span><br><span class="line">//保存对应的cpu,如果等于当前cpu，则说明已经设置过了。</span><br><span class="line">		  </span><br><span class="line">if (table-&gt;ents[index] != cpu)</span><br><span class="line">  </span><br><span class="line">//否则设置cpu</span><br><span class="line">			  </span><br><span class="line">table-&gt;ents[index] = cpu;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是进程上下文做的事情，也就是设置对应的进程所期待的cpu，它用的是rps_sock_flow_table，而接下来就是软中断上下文了，rfs这个patch主要的工作都是在软中断上下文做的。不过看这里的代码之前最好能够了解下RPS补丁，因为RFS就是对rps做了一点小改动。</p>
<p>主要是两个函数，第一个是enqueue_to_backlog，这个函数我们知道是用来将skb挂在到对应cpu的input queue上的，这里我们就关注他的一个函数就是input_queue_tail_incr_save，他就是更新设备的input_queue_tail以及softnet_data的input_queue_tail。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">		  </span><br><span class="line">if (skb_queue_len(&amp;sd-&gt;input_pkt_queue)) &#123;</span><br><span class="line">  </span><br><span class="line">enqueue:</span><br><span class="line">			  </span><br><span class="line">__skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb);</span><br><span class="line">  </span><br><span class="line">//这个函数更新对应设备的rps_dev_flow_table中的input_queue_tail以及dev flow table的last_qtail</span><br><span class="line">			  </span><br><span class="line">input_queue_tail_incr_save(sd, qtail);</span><br><span class="line">			  </span><br><span class="line">rps_unlock(sd);</span><br><span class="line">			  </span><br><span class="line">local_irq_restore(flags);</span><br><span class="line">			  </span><br><span class="line">return NET_RX_SUCCESS;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个是get_rps_cpu，这个函数我们知道就是得到软中断应该运行的cpu，这里我们就看RFS添加的部分,这里它是这样计算的，首先会得到两个flow table，一个是sock_flow_table,另一个是设备的rps_flow_table(skb对应的设备队列中对应的flow table)，这里的逻辑是这样子的取出来两个cpu，一个是根据rps计算数据包前一次被调度过的cpu(tcpu)，一个是应用程序期望的cpu(next_cpu)，然后比较这两个值，如果 1 tcpu未设置(等于RPS_NO_CPU） 2 tcpu是离线的 3 tcpu的input_queue_head大于rps_flow_table中的last_qtail 的话就调度这个skb到next_cpu.</p>
<p>而这里第三点input_queue_head大于rps_flow_table则说明在当前的dev flow table中的数据包已经发送完毕，否则的话为了避免乱序就还是继续使用tcpu.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">got_hash:</span><br><span class="line">	  </span><br><span class="line">flow_table = rcu_dereference(rxqueue-&gt;rps_flow_table);</span><br><span class="line">	  </span><br><span class="line">sock_flow_table = rcu_dereference(rps_sock_flow_table);</span><br><span class="line">	  </span><br><span class="line">if (flow_table &amp;&amp; sock_flow_table) &#123;</span><br><span class="line">		  </span><br><span class="line">u16 next_cpu;</span><br><span class="line">		  </span><br><span class="line">struct rps_dev_flow *rflow;</span><br><span class="line">  </span><br><span class="line">//得到flow table</span><br><span class="line">		  </span><br><span class="line">rflow = &amp;flow_table-&gt;flows[skb-&gt;rxhash &amp; flow_table-&gt;mask];</span><br><span class="line">		  </span><br><span class="line">tcpu = rflow-&gt;cpu;</span><br><span class="line">  </span><br><span class="line">/得到next_cpu</span><br><span class="line">		  </span><br><span class="line">next_cpu = sock_flow_table-&gt;ents[skb-&gt;rxhash &amp;</span><br><span class="line">		      </span><br><span class="line">sock_flow_table-&gt;mask];</span><br><span class="line"></span><br><span class="line">//条件</span><br><span class="line">		  </span><br><span class="line">if (unlikely(tcpu != next_cpu) &amp;&amp;</span><br><span class="line">		      </span><br><span class="line">(tcpu == RPS_NO_CPU || !cpu_online(tcpu) ||</span><br><span class="line">		       </span><br><span class="line">((int)(per_cpu(softnet_data, tcpu).input_queue_head &amp;#8211;</span><br><span class="line">		        </span><br><span class="line">rflow-&gt;last_qtail)) &gt;= 0)) &#123;</span><br><span class="line">  </span><br><span class="line">//设置tcpu</span><br><span class="line">			  </span><br><span class="line">tcpu = rflow-&gt;cpu = next_cpu;</span><br><span class="line">			  </span><br><span class="line">if (tcpu != RPS_NO_CPU)</span><br><span class="line">  </span><br><span class="line">//更新last_qtail</span><br><span class="line">				  </span><br><span class="line">rflow-&gt;last_qtail = per_cpu(softnet_data,</span><br><span class="line">				      </span><br><span class="line">tcpu).input_queue_head;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">		  </span><br><span class="line">if (tcpu != RPS_NO_CPU &amp;&amp; cpu_online(tcpu)) &#123;</span><br><span class="line">			  </span><br><span class="line">*rflowp = rflow;</span><br><span class="line">  </span><br><span class="line">//设置返回cpu，以供软中断重新调度</span><br><span class="line">			  </span><br><span class="line">cpu = tcpu;</span><br><span class="line">			  </span><br><span class="line">goto done;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br></pre></td></tr></table></figure>
<p>最后我们来分析下第一次数据包到达协议栈而应用程序还没有调用rcvmsg读取数据包，此时会发生什么问题，当第一次进来时tcpu是RPS_NO_CPU,并且next_cpu也是RPS_NO_CPU，此时会导致跳过rfs处理，而是直接使用rps的处理,也就是上面代码的紧接着的部分,下面这段代码前面rps时已经分析过了，这里就不分析了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">map = rcu_dereference(rxqueue-&gt;rps_map);</span><br><span class="line">	  </span><br><span class="line">if (map) &#123;</span><br><span class="line">		  </span><br><span class="line">tcpu = map-&gt;cpus[((u64) skb-&gt;rxhash * map-&gt;len) &gt;&gt; 32];</span><br><span class="line"></span><br><span class="line">if (cpu_online(tcpu)) &#123;</span><br><span class="line">			  </span><br><span class="line">cpu = tcpu;</span><br><span class="line">			  </span><br><span class="line">goto done;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/tcp-ip/">tcp/ip</a><a href="/tags/google/">google</a><a href="/tags/rfs/">rfs</a></div><div class="post-nav"><a class="pre" href="/2010/10/20/nginx's-handling-of-static-file-cache.html">nginx对静态文件cache的处理</a><a class="next" href="/2010/10/09/implementation-of-system-call-under-linux.html">linux下系统调用的实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>