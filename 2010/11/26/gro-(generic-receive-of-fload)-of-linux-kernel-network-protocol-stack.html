<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>linux kernel 网络协议栈之GRO(Generic receive offload) | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux kernel 网络协议栈之GRO(Generic receive offload)</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux kernel 网络协议栈之GRO(Generic receive offload)</h1><div class="post-meta">Nov 26, 2010<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a></span></div><div class="post-content"><p>GRO(Generic receive offload)在内核2.6.29之后合并进去的，作者是一个华裔Herbert Xu ,GRO的简介可以看这里：</p>
<p><a href="http://lwn.net/Articles/358910/" target="_blank" rel="noopener">http://lwn.net/Articles/358910/</a></p>
<p>先来描述一下GRO的作用，GRO是针对网络接受包的处理的，并且只是针对NAPI类型的驱动，因此如果要支持GRO，不仅要内核支持，而且驱动也必须调用相应的借口，用ethtool -K gro on来设置，如果报错就说明网卡驱动本身就不支持GRO。</p>
<p>GRO类似tso，可是tso只支持发送数据包，这样你tcp层大的段会在网卡被切包，然后再传递给对端，而如果没有gro，则小的段会被一个个送到协议栈，有了gro之后，就会在接收端做一个反向的操作(想对于tso).也就是将tso切好的数据包组合成大包再传递给协议栈。</p>
<p>如果实现了GRO支持的驱动是这样子处理数据的，在NAPI的回调poll方法中读取数据包，然后调用GRO的接口napi_gro_receive或者napi_gro_frags来将数据包feed进协议栈。而具体GRO的工作就是在这两个函数中进行的，他们最终都会调用<strong>napi_gro_receive。下面就是napi_gro_receive，它最终会调用napi_skb_finish以及</strong>napi_gro_receive。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">gro_result_t napi_gro_receive(struct napi_struct \*napi, struct sk_buff \*skb)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">skb_gro_reset_offset(skb);</span><br><span class="line"></span><br><span class="line">return napi_skb_finish(__napi_gro_receive(napi, skb), skb);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后GRO什么时候会将数据feed进协议栈呢，这里会有两个退出点，一个是在napi_skb_finish里，他会通过判断__napi_gro_receive的返回值，来决定是需要将数据包立即feed进协议栈还是保存起来，还有一个点是当napi的循环执行完毕时，也就是执行napi_complete的时候，先来看napi_skb_finish,napi_complete我们后面会详细介绍。</p>
<p>在NAPI驱动中，直接调用netif_receive_skb会将数据feed 进协议栈，因此这里如果返回值是NORMAL，则直接调用netif_receive_skb来将数据送进协议栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">gro_result_t napi_skb_finish(gro_result_t ret, struct sk_buff *skb)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">switch (ret) &#123;</span><br><span class="line">	  </span><br><span class="line">case GRO_NORMAL:</span><br><span class="line">  </span><br><span class="line">//将数据包送进协议栈</span><br><span class="line">		  </span><br><span class="line">if (netif_receive_skb(skb))</span><br><span class="line">			  </span><br><span class="line">ret = GRO_DROP;</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">  </span><br><span class="line">//表示skb可以被free，因为gro已经将skb合并并保存起来。</span><br><span class="line">	  </span><br><span class="line">case GRO_DROP:</span><br><span class="line">	  </span><br><span class="line">case GRO_MERGED_FREE:</span><br><span class="line">  </span><br><span class="line">//free skb</span><br><span class="line">		  </span><br><span class="line">kfree_skb(skb);</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">  </span><br><span class="line">//这个表示当前数据已经被gro保存起来，但是并没有进行合并，因此skb还需要保存。</span><br><span class="line">	  </span><br><span class="line">case GRO_HELD:</span><br><span class="line">	  </span><br><span class="line">case GRO_MERGED:</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GRO的主要思想就是，组合一些类似的数据包(基于一些数据域，后面会介绍到)为一个大的数据包(一个skb)，然后feed给协议栈，这里主要是利用Scatter-gather IO，也就是skb的struct skb_shared_info域(我前面的blog讲述ip分片的时候有详细介绍这个域)来合并数据包。</p>
<p>在每个NAPI的实例都会包括一个域叫gro_list,保存了我们积攒的数据包(将要被merge的).然后每次进来的skb都会在这个链表里面进行查找，看是否需要merge。而gro_count表示当前的gro_list中的skb的个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct napi_struct &#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">  </span><br><span class="line">//个数</span><br><span class="line">	  </span><br><span class="line">unsigned int gro_count;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">//积攒的数据包</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *gro_list;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *skb;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>紧接着是gro最核心的一个数据结构napi_gro_cb,它是保存在skb的cb域中，它保存了gro要使用到的一些上下文，这里每个域kernel的注释都比较清楚。到后面我们会看到这些域的具体用途。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct napi_gro_cb &#123;</span><br><span class="line">	  </span><br><span class="line">/\* Virtual address of skb_shinfo(skb)-&gt;frags[0].page + offset. \*/</span><br><span class="line">	  </span><br><span class="line">void *frag0;</span><br><span class="line"></span><br><span class="line">/\* Length of frag0. \*/</span><br><span class="line">	  </span><br><span class="line">unsigned int frag0_len;</span><br><span class="line"></span><br><span class="line">/\* This indicates where we are processing relative to skb-&gt;data. \*/</span><br><span class="line">	  </span><br><span class="line">int data_offset;</span><br><span class="line"></span><br><span class="line">/\* This is non-zero if the packet may be of the same flow. \*/</span><br><span class="line">	  </span><br><span class="line">int same_flow;</span><br><span class="line"></span><br><span class="line">/\* This is non-zero if the packet cannot be merged with the new skb. \*/</span><br><span class="line">	  </span><br><span class="line">int flush;</span><br><span class="line"></span><br><span class="line">/\* Number of segments aggregated. \*/</span><br><span class="line">	  </span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">/\* Free the skb? \*/</span><br><span class="line">	  </span><br><span class="line">int free;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一层协议都实现了自己的gro回调函数，gro_receive和gro_complete，gro系统会根据协议来调用对应回调函数，其中gro_receive是将输入skb尽量合并到我们gro_list中。而gro_complete则是当我们需要提交gro合并的数据包到协议栈时被调用的。</p>
<p>下面就是ip层和tcp层对应的回调方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static const struct net_protocol tcp_protocol = &#123;</span><br><span class="line">	  </span><br><span class="line">.handler = tcp_v4_rcv,</span><br><span class="line">	  </span><br><span class="line">.err_handler = tcp_v4_err,</span><br><span class="line">	  </span><br><span class="line">.gso_send_check = tcp_v4_gso_send_check,</span><br><span class="line">	  </span><br><span class="line">.gso_segment = tcp_tso_segment,</span><br><span class="line">  </span><br><span class="line">//gso回调</span><br><span class="line">	  </span><br><span class="line">.gro_receive = tcp4_gro_receive,</span><br><span class="line">	  </span><br><span class="line">.gro_complete = tcp4_gro_complete,</span><br><span class="line">	  </span><br><span class="line">.no_policy = 1,</span><br><span class="line">	  </span><br><span class="line">.netns_ok = 1,</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct packet_type ip_packet_type __read_mostly = &#123;</span><br><span class="line">	  </span><br><span class="line">.type = cpu_to_be16(ETH_P_IP),</span><br><span class="line">	  </span><br><span class="line">.func = ip_rcv,</span><br><span class="line">	  </span><br><span class="line">.gso_send_check = inet_gso_send_check,</span><br><span class="line">	  </span><br><span class="line">.gso_segment = inet_gso_segment,</span><br><span class="line">  </span><br><span class="line">//gso回调</span><br><span class="line">	  </span><br><span class="line">.gro_receive = inet_gro_receive,</span><br><span class="line">	  </span><br><span class="line">.gro_complete = inet_gro_complete,</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>gro的入口函数是napi_gro_receive，它的实现很简单，就是将skb包含的gro上下文reset，然后调用__napi_gro_receive,最终通过napi_skb_finis来判断是否需要讲数据包feed进协议栈。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">gro_result_t napi_gro_receive(struct napi_struct \*napi, struct sk_buff \*skb)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">//reset gro对应的域</span><br><span class="line">	  </span><br><span class="line">skb_gro_reset_offset(skb);</span><br><span class="line"></span><br><span class="line">return napi_skb_finish(__napi_gro_receive(napi, skb), skb);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>napi_skb_finish一开始已经介绍过了，这个函数主要是通过判断传递进来的ret(__napi_gro_receive的返回值),来决定是否需要feed数据进协议栈。它的第二个参数是前面处理过的skb。</p>
<p>这里再来看下skb_gro_reset_offset，首先要知道一种情况，那就是skb本身不包含数据(包括头也没有),而所有的数据都保存在skb_shared_info中(支持S/G的网卡有可能会这么做).此时我们如果想要合并的话，就需要将包头这些信息取出来，也就是从skb_shared_info的frags[0]中去的，在 skb_gro_reset_offset中就有做这个事情,而这里就会把头的信息保存到napi_gro_cb 的frags0中。并且此时frags必然不会在high mem,要么是线性区，要么是dma(S/G io)。 来看skb_gro_reset_offset。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void skb_gro_reset_offset(struct sk_buff *skb)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;data_offset = 0;</span><br><span class="line">	  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;frag0 = NULL;</span><br><span class="line">	  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;frag0_len = 0;</span><br><span class="line">  </span><br><span class="line">//如果mac_header和skb-&gt;tail相等并且地址不在高端内存，则说明包头保存在skb_shinfo中，所以我们需要从frags中取得对应的数据包</span><br><span class="line">	  </span><br><span class="line">if (skb-&gt;mac_header == skb-&gt;tail &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">!PageHighMem(skb_shinfo(skb)-&gt;frags[0].page)) &#123;</span><br><span class="line">  </span><br><span class="line">//可以看到frag0保存的就是对应的skb的frags的第一个元素的地址</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;frag0 =</span><br><span class="line">			  </span><br><span class="line">page_address(skb_shinfo(skb)-&gt;frags[0].page) +</span><br><span class="line">			  </span><br><span class="line">skb_shinfo(skb)-&gt;frags[0].page_offset;</span><br><span class="line">  </span><br><span class="line">//然后保存对应的大小。</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;frag0_len = skb_shinfo(skb)-&gt;frags[0].size;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是__napi_gro_receive，它主要是遍历gro_list,然后给same_flow赋值，这里要注意，same_flow是一个标记，表示某个skb是否有可能会和当前要处理的skb是相同的流,而这里的相同会在每层都进行判断，也就是在设备层，ip层，tcp层都会判断，这里就是设备层的判断了。这里的判断很简单，有2个条件：</p>
<p>1 设备是否相同</p>
<p>2 mac的头必须相等</p>
<p>如果上面两个条件都满足，则说明两个skb有可能是相同的flow，所以设置same_flow,以便与我们后面合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static gro_result_t</span><br><span class="line">  </span><br><span class="line">__napi_gro_receive(struct napi_struct \*napi, struct sk_buff \*skb)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *p;</span><br><span class="line"></span><br><span class="line">if (netpoll_rx_on(skb))</span><br><span class="line">		  </span><br><span class="line">return GRO_NORMAL;</span><br><span class="line">  </span><br><span class="line">//遍历gro_list,然后判断是否有可能两个skb 相似。</span><br><span class="line">	  </span><br><span class="line">for (p = napi-&gt;gro_list; p; p = p-&gt;next) &#123;</span><br><span class="line">  </span><br><span class="line">//给same_flow赋值</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(p)-&gt;same_flow =</span><br><span class="line">			  </span><br><span class="line">(p-&gt;dev == skb-&gt;dev) &amp;&amp;</span><br><span class="line">			  </span><br><span class="line">!compare_ether_header(skb_mac_header(p),</span><br><span class="line">					        </span><br><span class="line">skb_gro_mac_header(skb));</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(p)-&gt;flush = 0;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//调用dev_gro_receiv</span><br><span class="line">	  </span><br><span class="line">return dev_gro_receive(napi, skb);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来来看dev_gro_receive，这个函数我们分做两部分来看，第一部分是正常处理部分，第二部份是处理frag0的部分。</p>
<p>来看如何判断是否支持GRO，这里每个设备的features会在驱动初始化的时候被初始化，然后如果支持GRO，则会包括NETIF_F_GRO。 还有要注意的就是，gro不支持切片的ip包，因为ip切片的组包在内核的ip会做一遍，因此这里gro如果合并的话，没有多大意义，而且还增加复杂度。</p>
<p>在dev_gro_receive中会遍历对应的ptype(也就是协议的类链表，以前的blog有详细介绍),然后调用对应的回调函数，一般来说这里会调用文章开始说的ip_packet_type，也就是 inet_gro_receive。</p>
<p>而 inet_gro_receive的返回值表示我们需要立刻feed 进协议栈的数据包，如果为空，则说明不需要feed数据包进协议栈。后面会分析到这里他的详细算法。</p>
<p>而如果当inet_gro_receive正确返回后，如果same_flow没有被设置，则说明gro list中不存在能和当前的skb合并的项，因此此时需要将skb插入到gro list中。这个时候的返回值就是HELD。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">enum gro_result dev_gro_receive(struct napi_struct \*napi, struct sk_buff \*skb)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff **pp = NULL;</span><br><span class="line">	  </span><br><span class="line">struct packet_type *ptype;</span><br><span class="line">	  </span><br><span class="line">__be16 type = skb-&gt;protocol;</span><br><span class="line">	  </span><br><span class="line">struct list_head *head = &amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK];</span><br><span class="line">	  </span><br><span class="line">int same_flow;</span><br><span class="line">	  </span><br><span class="line">int mac_len;</span><br><span class="line">	  </span><br><span class="line">enum gro_result ret;</span><br><span class="line">  </span><br><span class="line">//判断是否支持gro</span><br><span class="line">	  </span><br><span class="line">if (!(skb-&gt;dev-&gt;features &amp; NETIF_F_GRO))</span><br><span class="line">		  </span><br><span class="line">goto normal;</span><br><span class="line">  </span><br><span class="line">//判断是否为切片的ip包</span><br><span class="line">	  </span><br><span class="line">if (skb_is_gso(skb) || skb_has_frags(skb))</span><br><span class="line">		  </span><br><span class="line">goto normal;</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">  </span><br><span class="line">//开始遍历对应的协议表</span><br><span class="line">	  </span><br><span class="line">list_for_each_entry_rcu(ptype, head, list) &#123;</span><br><span class="line">		  </span><br><span class="line">if (ptype-&gt;type != type || ptype-&gt;dev || !ptype-&gt;gro_receive)</span><br><span class="line">			  </span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">skb_set_network_header(skb, skb_gro_offset(skb));</span><br><span class="line">		  </span><br><span class="line">mac_len = skb-&gt;network_header &amp;#8211; skb-&gt;mac_header;</span><br><span class="line">		  </span><br><span class="line">skb-&gt;mac_len = mac_len;</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;same_flow = 0;</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;flush = 0;</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;free = 0;</span><br><span class="line">  </span><br><span class="line">//调用对应的gro接收函数</span><br><span class="line">		  </span><br><span class="line">pp = ptype-&gt;gro_receive(&amp;napi-&gt;gro_list, skb);</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">rcu_read_unlock();</span><br><span class="line">  </span><br><span class="line">//如果是没有实现gro的协议则也直接调到normal处理</span><br><span class="line">	  </span><br><span class="line">if (&amp;ptype-&gt;list == head)</span><br><span class="line">		  </span><br><span class="line">goto normal;</span><br><span class="line"></span><br><span class="line">//到达这里，则说明gro_receive已经调用过了，因此进行后续的处理</span><br><span class="line"></span><br><span class="line">//得到same_flow</span><br><span class="line">	  </span><br><span class="line">same_flow = NAPI_GRO_CB(skb)-&gt;same_flow;</span><br><span class="line">  </span><br><span class="line">//看是否有需要free对应的skb</span><br><span class="line">	  </span><br><span class="line">ret = NAPI_GRO_CB(skb)-&gt;free ? GRO_MERGED_FREE : GRO_MERGED;</span><br><span class="line">  </span><br><span class="line">//如果返回值pp部位空，则说明pp需要马上被feed进协议栈</span><br><span class="line">	  </span><br><span class="line">if (pp) &#123;</span><br><span class="line">		  </span><br><span class="line">struct sk_buff \*nskb = \*pp;</span><br><span class="line"></span><br><span class="line">*pp = nskb-&gt;next;</span><br><span class="line">		  </span><br><span class="line">nskb-&gt;next = NULL;</span><br><span class="line">  </span><br><span class="line">//调用napi_gro_complete 将pp刷进协议栈</span><br><span class="line">		  </span><br><span class="line">napi_gro_complete(nskb);</span><br><span class="line">		  </span><br><span class="line">napi-&gt;gro_count&amp;#8211;;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果same_flow有设置，则说明skb已经被正确的合并，因此直接返回。</span><br><span class="line">	  </span><br><span class="line">if (same_flow)</span><br><span class="line">		  </span><br><span class="line">goto ok;</span><br><span class="line">  </span><br><span class="line">//查看是否有设置flush和gro list的个数是否已经超过限制</span><br><span class="line">	  </span><br><span class="line">if (NAPI_GRO_CB(skb)-&gt;flush || napi-&gt;gro_count &gt;= MAX_GRO_SKBS)</span><br><span class="line">		  </span><br><span class="line">goto normal;</span><br><span class="line"></span><br><span class="line">//到达这里说明skb对应gro list来说是一个新的skb，也就是说当前的gro list并不存在可以和skb合并的数据包，因此此时将这个skb插入到gro_list的头。</span><br><span class="line">	  </span><br><span class="line">napi-&gt;gro_count++;</span><br><span class="line">	  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;count = 1;</span><br><span class="line">	  </span><br><span class="line">skb_shinfo(skb)-&gt;gso_size = skb_gro_len(skb);</span><br><span class="line">  </span><br><span class="line">//将skb插入到gro list的头</span><br><span class="line">	  </span><br><span class="line">skb-&gt;next = napi-&gt;gro_list;</span><br><span class="line">	  </span><br><span class="line">napi-&gt;gro_list = skb;</span><br><span class="line">  </span><br><span class="line">//设置返回值</span><br><span class="line">	  </span><br><span class="line">ret = GRO_HELD;</span><br></pre></td></tr></table></figure>
<p>然后就是处理frag0的部分，以及不支持gro的处理。</p>
<p>这里要需要对skb_shinfo的结构比较了解，我在以前的blog对这个有很详细的介绍，可以去查阅。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">pull:</span><br><span class="line">  </span><br><span class="line">//是否需要拷贝头</span><br><span class="line">	  </span><br><span class="line">if (skb_headlen(skb) &lt; skb_gro_offset(skb)) &#123;</span><br><span class="line">  </span><br><span class="line">//得到对应的头的大小</span><br><span class="line">		  </span><br><span class="line">int grow = skb_gro_offset(skb) &amp;#8211; skb_headlen(skb);</span><br><span class="line"></span><br><span class="line">BUG_ON(skb-&gt;end &amp;#8211; skb-&gt;tail &lt; grow);</span><br><span class="line">  </span><br><span class="line">//开始拷贝</span><br><span class="line">		  </span><br><span class="line">memcpy(skb_tail_pointer(skb), NAPI_GRO_CB(skb)-&gt;frag0, grow);</span><br><span class="line"></span><br><span class="line">skb-&gt;tail += grow;</span><br><span class="line">		  </span><br><span class="line">skb-&gt;data_len -= grow;</span><br><span class="line">  </span><br><span class="line">//更新对应的frags[0]</span><br><span class="line">		  </span><br><span class="line">skb_shinfo(skb)-&gt;frags[0].page_offset += grow;</span><br><span class="line">		  </span><br><span class="line">skb_shinfo(skb)-&gt;frags[0].size -= grow;</span><br><span class="line">  </span><br><span class="line">//如果size为0了，则说明第一个页全部包含头，因此需要将后面的页全部移动到前面。</span><br><span class="line">		  </span><br><span class="line">if (unlikely(!skb_shinfo(skb)-&gt;frags[0].size)) &#123;</span><br><span class="line">			  </span><br><span class="line">put_page(skb_shinfo(skb)-&gt;frags[0].page);</span><br><span class="line">  </span><br><span class="line">//开始移动。</span><br><span class="line">			  </span><br><span class="line">memmove(skb_shinfo(skb)-&gt;frags,</span><br><span class="line">				  </span><br><span class="line">skb_shinfo(skb)-&gt;frags + 1,</span><br><span class="line">				  </span><br><span class="line">&amp;#8211;skb_shinfo(skb)-&gt;nr_frags * sizeof(skb_frag_t));</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">	  </span><br><span class="line">return ret;</span><br><span class="line"></span><br><span class="line">normal:</span><br><span class="line">	  </span><br><span class="line">ret = GRO_NORMAL;</span><br><span class="line">	  </span><br><span class="line">goto pull;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是inet_gro_receive，这个函数是ip层的gro receive回调函数，函数很简单，首先取得ip头，然后判断是否需要从frag复制数据，如果需要则复制数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//得到偏移</span><br><span class="line">		  </span><br><span class="line">off = skb_gro_offset(skb);</span><br><span class="line">  </span><br><span class="line">//得到头的整个长度(mac+ip)</span><br><span class="line">	  </span><br><span class="line">hlen = off + sizeof(*iph);</span><br><span class="line">  </span><br><span class="line">//得到ip头</span><br><span class="line">	  </span><br><span class="line">iph = skb_gro_header_fast(skb, off);</span><br><span class="line">  </span><br><span class="line">//是否需要复制</span><br><span class="line">	  </span><br><span class="line">if (skb_gro_header_hard(skb, hlen)) &#123;</span><br><span class="line">		  </span><br><span class="line">iph = skb_gro_header_slow(skb, hlen, off);</span><br><span class="line">		  </span><br><span class="line">if (unlikely(!iph))</span><br><span class="line">			  </span><br><span class="line">goto out;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是一些校验工作，比如协议是否支持gro_reveive,ip头是否合法等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">proto = iph-&gt;protocol &amp; (MAX_INET_PROTOS &amp;#8211; 1);</span><br><span class="line"></span><br><span class="line">rcu_read_lock();</span><br><span class="line">	  </span><br><span class="line">ops = rcu_dereference(inet_protos[proto]);</span><br><span class="line">  </span><br><span class="line">//是否支持gro</span><br><span class="line">	  </span><br><span class="line">if (!ops || !ops-&gt;gro_receive)</span><br><span class="line">		  </span><br><span class="line">goto out_unlock;</span><br><span class="line">  </span><br><span class="line">//ip头是否合法</span><br><span class="line">	  </span><br><span class="line">if (\*(u8 \*)iph != 0x45)</span><br><span class="line">		  </span><br><span class="line">goto out_unlock;</span><br><span class="line">  </span><br><span class="line">//ip头教研</span><br><span class="line">	  </span><br><span class="line">if (unlikely(ip_fast_csum((u8 *)iph, iph-&gt;ihl)))</span><br><span class="line">		  </span><br><span class="line">goto out_unlock;</span><br></pre></td></tr></table></figure>
<p>然后就是核心的处理部分，它会遍历整个gro_list,然后进行same_flow和是否需要flush的判断。</p>
<p>这里ip层设置same_flow是根据下面的规则的:</p>
<p>1 4层的协议必须相同</p>
<p>2 tos域必须相同</p>
<p>3 源，目的地址必须相同</p>
<p>如果3个条件一个不满足，则会设置same_flow为0。</p>
<p>这里还有一个就是判断是否需要flush 对应的skb到协议栈，这里的判断条件是这样子的。</p>
<p>1 ip包的ttl不一样</p>
<p>2 ip包的id顺序不对</p>
<p>3 如果是切片包</p>
<p>如果上面两个条件某一个满足，则说明skb需要被flush出gro。</p>
<p>不过这里要注意只有两个数据包是same flow的情况下，才会进行flush判断。原因很简单，都不是有可能进行merge的包，自然没必要进行flush了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//取出id</span><br><span class="line">	  </span><br><span class="line">id = ntohl(\*(__be32 \*)&amp;iph-&gt;id);</span><br><span class="line">  </span><br><span class="line">//判断是否需要切片</span><br><span class="line">	  </span><br><span class="line">flush = (u16)((ntohl(\*(__be32 \*)iph) ^ skb_gro_len(skb)) | (id ^ IP_DF));</span><br><span class="line">	  </span><br><span class="line">id &gt;&gt;= 16;</span><br><span class="line">  </span><br><span class="line">//开始遍历gro list</span><br><span class="line">	  </span><br><span class="line">for (p = *head; p; p = p-&gt;next) &#123;</span><br><span class="line">		  </span><br><span class="line">struct iphdr *iph2;</span><br><span class="line">  </span><br><span class="line">//如果上一层已经不可能same flow则直接继续下一个</span><br><span class="line">		  </span><br><span class="line">if (!NAPI_GRO_CB(p)-&gt;same_flow)</span><br><span class="line">			  </span><br><span class="line">continue;</span><br><span class="line">  </span><br><span class="line">//取出ip头</span><br><span class="line">		  </span><br><span class="line">iph2 = ip_hdr(p);</span><br><span class="line">  </span><br><span class="line">//开始same flow的判断</span><br><span class="line">		  </span><br><span class="line">if ((iph-&gt;protocol ^ iph2-&gt;protocol) |</span><br><span class="line">		      </span><br><span class="line">(iph-&gt;tos ^ iph2-&gt;tos) |</span><br><span class="line">		      </span><br><span class="line">((__force u32)iph-&gt;saddr ^ (__force u32)iph2-&gt;saddr) |</span><br><span class="line">		      </span><br><span class="line">((__force u32)iph-&gt;daddr ^ (__force u32)iph2-&gt;daddr)) &#123;</span><br><span class="line">			  </span><br><span class="line">NAPI_GRO_CB(p)-&gt;same_flow = 0;</span><br><span class="line">			  </span><br><span class="line">continue;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//开始flush的判断。这里注意如果不是same_flow的话，就没必要进行flush的判断。</span><br><span class="line">		  </span><br><span class="line">/\* All fields must match except length and checksum. \*/</span><br><span class="line">		  </span><br><span class="line">NAPI_GRO_CB(p)-&gt;flush |=</span><br><span class="line">			  </span><br><span class="line">(iph-&gt;ttl ^ iph2-&gt;ttl) |</span><br><span class="line">			  </span><br><span class="line">((u16)(ntohs(iph2-&gt;id) + NAPI_GRO_CB(p)-&gt;count) ^ id);</span><br><span class="line"></span><br><span class="line">NAPI_GRO_CB(p)-&gt;flush |= flush;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NAPI_GRO_CB(skb)-&gt;flush |= flush;</span><br><span class="line">  </span><br><span class="line">//pull ip头进gro，这里更新data_offset</span><br><span class="line">	  </span><br><span class="line">skb_gro_pull(skb, sizeof(*iph));</span><br><span class="line">  </span><br><span class="line">//设置传输层的头的位置</span><br><span class="line">	  </span><br><span class="line">skb_set_transport_header(skb, skb_gro_offset(skb));</span><br><span class="line">  </span><br><span class="line">//调用传输层的reveive方法。</span><br><span class="line">	  </span><br><span class="line">pp = ops-&gt;gro_receive(head, skb);</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	  </span><br><span class="line">rcu_read_unlock();</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;flush |= flush;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是tcp层的gro方法，它的主要实现函数是tcp_gro_receive，他的流程和inet_gro_receiv类似，就是取得tcp的头，然后对gro list进行遍历，最终会调用合并方法。</p>
<p>首先来看gro list遍历的部分,它对same flow的要求就是source必须相同，如果不同则设置same flow为0.如果相同则跳到found部分，进行合并处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//遍历gro list</span><br><span class="line">	  </span><br><span class="line">for (; (p = *head); head = &amp;p-&gt;next) &#123;</span><br><span class="line">  </span><br><span class="line">//如果ip层已经不可能same flow则直接进行下一次匹配</span><br><span class="line">		  </span><br><span class="line">if (!NAPI_GRO_CB(p)-&gt;same_flow)</span><br><span class="line">			  </span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">th2 = tcp_hdr(p);</span><br><span class="line">  </span><br><span class="line">//判断源地址</span><br><span class="line">		  </span><br><span class="line">if (\*(u32 \*)&amp;th-&gt;source ^ \*(u32 \*)&amp;th2-&gt;source) &#123;</span><br><span class="line">			  </span><br><span class="line">NAPI_GRO_CB(p)-&gt;same_flow = 0;</span><br><span class="line">			  </span><br><span class="line">continue;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goto found;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是当找到能够合并的skb的时候的处理，这里首先来看flush的设置,这里会有4个条件：</p>
<p>1 拥塞状态被设置(TCP_FLAG_CWR).</p>
<p>2 tcp的ack的序列号不匹配 (这是肯定的，因为它只是对tso或者说gso进行反向操作)</p>
<p>3 skb的flag和从gro list中查找到要合并skb的flag 如果他们中的不同位 不包括TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH，这三个任意一个域。</p>
<p>4 tcp的option域不同</p>
<p>如果上面4个条件有一个满足，则会设置flush为1，也就是找到的这个skb(gro list中)必须被刷出到协议栈。</p>
<p>这里谈一下flags域的设置问题首先如果当前的skb设置了cwr，也就是发生了拥塞，那么自然前面被缓存的数据包需要马上被刷到协议栈，以便与tcp的拥塞控制马上进行。</p>
<p>而FIN和PSH这两个flag自然不需要一致，因为这两个和其他的不是互斥的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">found:</span><br><span class="line">	  </span><br><span class="line">flush = NAPI_GRO_CB(p)-&gt;flush;</span><br><span class="line">  </span><br><span class="line">//如果设置拥塞，则肯定需要刷出skb到协议栈</span><br><span class="line">	  </span><br><span class="line">flush |= (__force int)(flags &amp; TCP_FLAG_CWR);</span><br><span class="line">  </span><br><span class="line">//如果相差的域是除了这3个中的，就需要flush出skb</span><br><span class="line">	  </span><br><span class="line">flush |= (__force int)((flags ^ tcp_flag_word(th2)) &amp;</span><br><span class="line">		    </span><br><span class="line">~(TCP_FLAG_CWR | TCP_FLAG_FIN | TCP_FLAG_PSH));</span><br><span class="line">  </span><br><span class="line">//ack的序列号必须一致</span><br><span class="line">	  </span><br><span class="line">flush |= (__force int)(th-&gt;ack_seq ^ th2-&gt;ack_seq);</span><br><span class="line">  </span><br><span class="line">//tcp的option头必须一致</span><br><span class="line">	  </span><br><span class="line">for (i = sizeof(*th); i &lt; thlen; i += 4)</span><br><span class="line">		  </span><br><span class="line">flush |= \*(u32 \*)((u8 *)th + i) ^</span><br><span class="line">			   </span><br><span class="line">\*(u32 \*)((u8 *)th2 + i);</span><br><span class="line"></span><br><span class="line">mss = skb_shinfo(p)-&gt;gso_size;</span><br><span class="line"></span><br><span class="line">flush |= (len &amp;#8211; 1) &gt;= mss;</span><br><span class="line">	  </span><br><span class="line">flush |= (ntohl(th2-&gt;seq) + skb_gro_len(p)) ^ ntohl(th-&gt;seq);</span><br><span class="line">  </span><br><span class="line">//如果flush有设置则不会调用 skb_gro_receive，也就是不需要进行合并，否则调用skb_gro_receive进行数据包合并</span><br><span class="line">	  </span><br><span class="line">if (flush || skb_gro_receive(head, skb)) &#123;</span><br><span class="line">		  </span><br><span class="line">mss = 1;</span><br><span class="line">		  </span><br><span class="line">goto out_check_final;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = *head;</span><br><span class="line">	  </span><br><span class="line">th2 = tcp_hdr(p);</span><br><span class="line">  </span><br><span class="line">//更新p的头。到达这里说明合并完毕，因此需要更新合并完的新包的头。</span><br><span class="line">	  </span><br><span class="line">tcp_flag_word(th2) |= flags &amp; (TCP_FLAG_FIN | TCP_FLAG_PSH);</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到如果tcp的包被设置了一些特殊的flag比如PSH，SYN这类的就必须马上把数据包刷出到协议栈。</p>
<p>下面就是最终的一些flags判断,比如第一个数据包进来都会到这里来判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">out_check_final:</span><br><span class="line">	  </span><br><span class="line">flush = len &lt; mss;</span><br><span class="line">  </span><br><span class="line">//根据flag得到flush</span><br><span class="line">	  </span><br><span class="line">flush |= (__force int)(flags &amp; (TCP_FLAG_URG | TCP_FLAG_PSH |</span><br><span class="line">					  </span><br><span class="line">TCP_FLAG_RST | TCP_FLAG_SYN |</span><br><span class="line">					  </span><br><span class="line">TCP_FLAG_FIN));</span><br><span class="line"></span><br><span class="line">if (p &amp;&amp; (!NAPI_GRO_CB(skb)-&gt;same_flow || flush))</span><br><span class="line">		  </span><br><span class="line">pp = head;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	  </span><br><span class="line">NAPI_GRO_CB(skb)-&gt;flush |= flush;</span><br></pre></td></tr></table></figure>
<p>这里要知道每次我们只会刷出gro list中的一个skb节点，这是因为每次进来的数据包我们也只会匹配一个。因此如果遇到需要刷出的数据包，会在dev_gro_receive中先刷出gro list中的，然后再将当前的skb feed进协议栈。</p>
<p>最后就是gro最核心的一个函数skb_gro_receive，它的主要工作就是合并，它有2个参数，第一个是gro list中和当前处理的skb是same flow的skb，第二个就是我们需要合并的skb。</p>
<p>这里要注意就是farg_list,其实gro对待skb_shared_info和ip层切片，组包很类似，就是frags放Scatter-Gather I/O的数据包，frag_list放线性数据。这里gro 也是这样的，如果过来的skb支持Scatter-Gather I/O并且数据是只放在frags中，则会合并frags，如果过来的skb不支持Scatter-Gather I/O(数据头还是保存在skb中)，则合并很简单，就是新建一个skb然后拷贝当前的skb，并将gro list中的skb直接挂载到farg_list。</p>
<p>先来看支持Scatter-Gather I/O的处理部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//一些需要用到的变量</span><br><span class="line">	  </span><br><span class="line">struct sk_buff \*p = \*head;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *nskb;</span><br><span class="line">  </span><br><span class="line">//当前的skb的 share_ino</span><br><span class="line">	  </span><br><span class="line">struct skb_shared_info *skbinfo = skb_shinfo(skb);</span><br><span class="line">  </span><br><span class="line">//当前的gro list中的要合并的skb的share_info</span><br><span class="line">	  </span><br><span class="line">struct skb_shared_info *pinfo = skb_shinfo(p);</span><br><span class="line">	  </span><br><span class="line">unsigned int headroom;</span><br><span class="line">	  </span><br><span class="line">unsigned int len = skb_gro_len(skb);</span><br><span class="line">	  </span><br><span class="line">unsigned int offset = skb_gro_offset(skb);</span><br><span class="line">	  </span><br><span class="line">unsigned int headlen = skb_headlen(skb);</span><br><span class="line">  </span><br><span class="line">//如果有frag_list的话，则直接去非Scatter-Gather I/O部分处理，也就是合并到frag_list.</span><br><span class="line">	  </span><br><span class="line">if (pinfo-&gt;frag_list)</span><br><span class="line">		  </span><br><span class="line">goto merge;</span><br><span class="line">	  </span><br><span class="line">else if (headlen &lt;= offset) &#123;</span><br><span class="line">  </span><br><span class="line">//支持Scatter-Gather I/O的处理</span><br><span class="line">		  </span><br><span class="line">skb_frag_t *frag;</span><br><span class="line">		  </span><br><span class="line">skb_frag_t *frag2;</span><br><span class="line">		  </span><br><span class="line">int i = skbinfo-&gt;nr_frags;</span><br><span class="line">  </span><br><span class="line">//这里遍历是从后向前。</span><br><span class="line">		  </span><br><span class="line">int nr_frags = pinfo-&gt;nr_frags + i;</span><br><span class="line"></span><br><span class="line">offset -= headlen;</span><br><span class="line"></span><br><span class="line">if (nr_frags &gt; MAX_SKB_FRAGS)</span><br><span class="line">			  </span><br><span class="line">return -E2BIG;</span><br><span class="line">  </span><br><span class="line">//设置pinfo的frags的大小，可以看到就是加上skb的frags的大小</span><br><span class="line">		  </span><br><span class="line">pinfo-&gt;nr_frags = nr_frags;</span><br><span class="line">		  </span><br><span class="line">skbinfo-&gt;nr_frags = 0;</span><br><span class="line"></span><br><span class="line">frag = pinfo-&gt;frags + nr_frags;</span><br><span class="line">		  </span><br><span class="line">frag2 = skbinfo-&gt;frags + i;</span><br><span class="line">  </span><br><span class="line">//遍历赋值，其实就是地址赋值，这里就是将skb的frag加到pinfo的frgas后面。</span><br><span class="line">		  </span><br><span class="line">do &#123;</span><br><span class="line">			  </span><br><span class="line">\*&amp;#8211;frag = \*&amp;#8211;frag2;</span><br><span class="line">		  </span><br><span class="line">&#125; while (&amp;#8211;i);</span><br><span class="line">  </span><br><span class="line">//更改page_offet的值</span><br><span class="line">		  </span><br><span class="line">frag-&gt;page_offset += offset;</span><br><span class="line">  </span><br><span class="line">//修改size大小</span><br><span class="line">		  </span><br><span class="line">frag-&gt;size -= offset;</span><br><span class="line">  </span><br><span class="line">//更新skb的相关值</span><br><span class="line">		  </span><br><span class="line">skb-&gt;truesize -= skb-&gt;data_len;</span><br><span class="line">		  </span><br><span class="line">skb-&gt;len -= skb-&gt;data_len;</span><br><span class="line">		  </span><br><span class="line">skb-&gt;data_len = 0;</span><br><span class="line"></span><br><span class="line">NAPI_GRO_CB(skb)-&gt;free = 1;</span><br><span class="line">  </span><br><span class="line">//最终完成</span><br><span class="line">		  </span><br><span class="line">goto done;</span><br><span class="line">	  </span><br><span class="line">&#125; else if (skb_gro_len(p) != pinfo-&gt;gso_size)</span><br><span class="line">		  </span><br><span class="line">return -E2BIG;</span><br></pre></td></tr></table></figure>
<p>这里gro list中的要被合并的skb我们叫做skb_s.</p>
<p>接下来就是不支持支持Scatter-Gather I/O(skb的头放在skb中)的处理。这里处理也比较简单，就是复制一个新的nskb，然后它的头和skb_s一样，然后将skb_s挂载到nskb的frag_list上，并且把新建的nskb挂在到gro list中，代替skb_s的位置，而当前的skb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">headroom = skb_headroom(p);</span><br><span class="line">	  </span><br><span class="line">nskb = alloc_skb(headroom + skb_gro_offset(p), GFP_ATOMIC);</span><br><span class="line">	  </span><br><span class="line">if (unlikely(!nskb))</span><br><span class="line">		  </span><br><span class="line">return -ENOMEM;</span><br><span class="line">  </span><br><span class="line">//复制头</span><br><span class="line">	  </span><br><span class="line">__copy_skb_header(nskb, p);</span><br><span class="line">	  </span><br><span class="line">nskb-&gt;mac_len = p-&gt;mac_len;</span><br><span class="line"></span><br><span class="line">skb_reserve(nskb, headroom);</span><br><span class="line">	  </span><br><span class="line">__skb_put(nskb, skb_gro_offset(p));</span><br><span class="line">  </span><br><span class="line">//设置各层的头</span><br><span class="line">	  </span><br><span class="line">skb_set_mac_header(nskb, skb_mac_header(p) &amp;#8211; p-&gt;data);</span><br><span class="line">	  </span><br><span class="line">skb_set_network_header(nskb, skb_network_offset(p));</span><br><span class="line">	  </span><br><span class="line">skb_set_transport_header(nskb, skb_transport_offset(p));</span><br><span class="line"></span><br><span class="line">__skb_pull(p, skb_gro_offset(p));</span><br><span class="line">  </span><br><span class="line">//复制数据</span><br><span class="line">	  </span><br><span class="line">memcpy(skb_mac_header(nskb), skb_mac_header(p),</span><br><span class="line">	         </span><br><span class="line">p-&gt;data &amp;#8211; skb_mac_header(p));</span><br><span class="line">  </span><br><span class="line">//对应的gro 域的赋值</span><br><span class="line">	  </span><br><span class="line">\*NAPI_GRO_CB(nskb) = \*NAPI_GRO_CB(p);</span><br><span class="line">  </span><br><span class="line">//可以看到frag_list被赋值</span><br><span class="line">	  </span><br><span class="line">skb_shinfo(nskb)-&gt;frag_list = p;</span><br><span class="line">	  </span><br><span class="line">skb_shinfo(nskb)-&gt;gso_size = pinfo-&gt;gso_size;</span><br><span class="line">	  </span><br><span class="line">pinfo-&gt;gso_size = 0;</span><br><span class="line">	  </span><br><span class="line">skb_header_release(p);</span><br><span class="line">	  </span><br><span class="line">nskb-&gt;prev = p;</span><br><span class="line">  </span><br><span class="line">//更新新的skb的数据段</span><br><span class="line">	  </span><br><span class="line">nskb-&gt;data_len += p-&gt;len;</span><br><span class="line">	  </span><br><span class="line">nskb-&gt;truesize += p-&gt;len;</span><br><span class="line">	  </span><br><span class="line">nskb-&gt;len += p-&gt;len;</span><br><span class="line">  </span><br><span class="line">//将新的skb插入到gro list中</span><br><span class="line">	  </span><br><span class="line">*head = nskb;</span><br><span class="line">	  </span><br><span class="line">nskb-&gt;next = p-&gt;next;</span><br><span class="line">	  </span><br><span class="line">p-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">p = nskb;</span><br><span class="line"></span><br><span class="line">merge:</span><br><span class="line">	  </span><br><span class="line">if (offset &gt; headlen) &#123;</span><br><span class="line">		  </span><br><span class="line">skbinfo-&gt;frags[0].page_offset += offset &amp;#8211; headlen;</span><br><span class="line">		  </span><br><span class="line">skbinfo-&gt;frags[0].size -= offset &amp;#8211; headlen;</span><br><span class="line">		  </span><br><span class="line">offset = headlen;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__skb_pull(skb, offset);</span><br><span class="line">  </span><br><span class="line">//将skb插入新的skb的(或者老的skb，当frag list本身存在)fraglist</span><br><span class="line">	  </span><br><span class="line">p-&gt;prev-&gt;next = skb;</span><br><span class="line">	  </span><br><span class="line">p-&gt;prev = skb;</span><br><span class="line">	  </span><br><span class="line">skb_header_release(skb);</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/tcp-ip/">tcp/ip</a><a href="/tags/gro/">gro</a></div><div class="post-nav"><a class="pre" href="/2010/12/12/xps-characteristics-of-linux-kernel-network-protocol-stack.html">linux kernel 网络协议栈之xps特性详解</a><a class="next" href="/2010/11/19/cubic-algorithm-for-linux-kernel-tcp-congestion-processing.html">linux kernel tcp拥塞处理之cubic算法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/introduction-to-mysql.-rocksdb.-manifest-file.html">MySQL · RocksDB · MANIFEST文件介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>