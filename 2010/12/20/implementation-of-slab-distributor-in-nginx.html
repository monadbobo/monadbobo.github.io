<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nginx中slab分配器的实现 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nginx中slab分配器的实现</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">nginx中slab分配器的实现</h1><div class="post-meta">Dec 20, 2010<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a><a href="/categories/nginx/server/">server</a><a href="/categories/nginx/server/源码阅读/">源码阅读</a></span></div><div class="post-content"><p>nginx的slab分配器主要用于共享内存部分的内存分配，代码包含在core/slab.c和core/slab.h中。slab是针对小于1页的内存的fenpei 它的大体思想和jeff的那篇paper中描述的一致，因此可以先看看jeff的那篇关于slab的论文。有关于slab的优点也可以去看jeff的paper，这里就不描述了。</p>
<p>下面就是nginx的slab的内存图.</p>
<p><a href="http://www.flickr.com/photos/67458145@N00/5322876207/" title="slab in nginx by Minibobo, on Flickr" target="_blank" rel="noopener"><img src="http://farm6.static.flickr.com/5087/5322876207_701b0080d3_z.jpg" width="426" height="640" alt="slab in nginx"></a></p>
<a id="more"></a>
<p>下面就是管理slab的核心的数据结构ngx_slab_pool_t，这里我只是简单的注释，紧接着我会详细的介绍实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct &#123;</span><br><span class="line">      </span><br><span class="line">ngx_atomic_t lock;</span><br><span class="line"></span><br><span class="line">size_t min_size;</span><br><span class="line">      </span><br><span class="line">size_t min_shift;</span><br><span class="line">  </span><br><span class="line">//管理页数组</span><br><span class="line">      </span><br><span class="line">ngx_slab_page_t *pages;</span><br><span class="line">  </span><br><span class="line">//管理free的页数组</span><br><span class="line">      </span><br><span class="line">ngx_slab_page_t free;</span><br><span class="line">  </span><br><span class="line">//数据区的起始地址</span><br><span class="line">      </span><br><span class="line">u_char *start;</span><br><span class="line">  </span><br><span class="line">//数据区的结束地址</span><br><span class="line">      </span><br><span class="line">u_char *end;</span><br><span class="line"></span><br><span class="line">ngx_shmtx_t mutex;</span><br><span class="line"></span><br><span class="line">u_char *log_ctx;</span><br><span class="line">      </span><br><span class="line">u_char zero;</span><br><span class="line"></span><br><span class="line">void *data;</span><br><span class="line">      </span><br><span class="line">void *addr;</span><br><span class="line">  </span><br><span class="line">&#125; ngx_slab_pool_t;</span><br></pre></td></tr></table></figure>
<p>然后描述下nginx中的slab是怎么实现的，一个slab管理了很多个相似大小的块，而nginx会通过两种方式来管理内存，它是根据所请求的大小进行划分，小于ngx_slab_max_size的都会通过一个slots数组来进行管理(可以看我上面的内存图)，然后每次进来的size都会根据它的shift来划分到对应的数组的位置，下面就是数组的位置，size以及shift的对应关系，可以看到这里分配的大小都是向上对其的，也就是说你申请35字节那么会返还给你64字节。</p>
<p><code>&lt;br /&gt;
slot        size        shift&lt;br /&gt;
0        &lt;= 8        3
1        9 ~ 16        4
2        17 ~ 32        5
3        33 ~ 64        6
4        65 ~ 128    7
5        129 ~ 256    8
6        257 ~ 512    9
7        513 ~ 1024    10
8        1025 ~ 2047    11</code></p>
<p>然后就是大于ngx_slab_max_size的情况，如果大于它则会从page数组分配，因为这个值是页大小的一半，大于它则说明我们需要直接返回一个页或者几个页，此时就不需要象小的块那样需要一个复杂的管理块的东西，因此此时直接通过一个pages数组来进行管理，而数组元素的位置是紧跟着slot部分。</p>
<p>下面就是相关的代码，下面的代码都是在slab_init中，首先是第一部分下面这段主要是设置一些限定值，比如ngx_slab_max_size和ngx_slab_exact_size。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (ngx_slab_max_size == 0) &#123;</span><br><span class="line">  </span><br><span class="line">//可以看到这里ngx_slab_max_size的大小是半页，也就是1页以上我们就用pages来管理</span><br><span class="line">          </span><br><span class="line">ngx_slab_max_size = ngx_pagesize / 2;</span><br><span class="line">  </span><br><span class="line">//这里计算一页用uintptr_t类型来表示所有块，那么每块是多大</span><br><span class="line">          </span><br><span class="line">ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));</span><br><span class="line">  </span><br><span class="line">//计算shift</span><br><span class="line">          </span><br><span class="line">for (n = ngx_slab_exact_size; n &gt;&gt;= 1; ngx_slab_exact_shift++) &#123;</span><br><span class="line">              </span><br><span class="line">/\* void \*/</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是初始化ngx_slab_pool_t部分，主要是初始化slot数组和pages数组。</p>
<p>默认是每个slot数组的next指向自己，这个表明当前的slot数组还没有管理对应的页。具体的结构可以看我一开始的内存图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">pool-&gt;min_size = 1 &lt;&lt; pool-&gt;min_shift;</span><br><span class="line">  </span><br><span class="line">//这个时候p指向pool_t的末尾</span><br><span class="line">      </span><br><span class="line">p = (u_char *) pool + sizeof(ngx_slab_pool_t);</span><br><span class="line">  </span><br><span class="line">//计算大小，可以看到是除了ngx_slab_pool_t的大小</span><br><span class="line">      </span><br><span class="line">size = pool-&gt;end - p;</span><br><span class="line"></span><br><span class="line">ngx_slab_junk(p, size);</span><br><span class="line"></span><br><span class="line">slots = (ngx_slab_page_t *) p;</span><br><span class="line">  </span><br><span class="line">//计算需要多大的数组</span><br><span class="line">      </span><br><span class="line">n = ngx_pagesize_shift - pool-&gt;min_shift;</span><br><span class="line">  </span><br><span class="line">//初始化slot数组</span><br><span class="line">      </span><br><span class="line">for (i = 0; i &lt; n; i++) &#123;</span><br><span class="line">          </span><br><span class="line">slots[i].slab = 0;</span><br><span class="line">          </span><br><span class="line">slots[i].next = &amp;slots[i];</span><br><span class="line">          </span><br><span class="line">slots[i].prev = 0;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//此时指向pages数组</span><br><span class="line">      </span><br><span class="line">p += n * sizeof(ngx_slab_page_t);</span><br><span class="line">  </span><br><span class="line">//计算一共能够保存多少个页，加上ngx_slab_page_t,是因为每一个页都会有一个ngx_slab_page_t来表示相关信息。</span><br><span class="line">      </span><br><span class="line">pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));</span><br><span class="line"></span><br><span class="line">ngx_memzero(p, pages * sizeof(ngx_slab_page_t));</span><br><span class="line">  </span><br><span class="line">//设置pages指针</span><br><span class="line">      </span><br><span class="line">pool-&gt;pages = (ngx_slab_page_t *) p;</span><br><span class="line">  </span><br><span class="line">//free的next初始值指向第一个没有被使用page。</span><br><span class="line">      </span><br><span class="line">pool-&gt;free.prev = 0;</span><br><span class="line">      </span><br><span class="line">pool-&gt;free.next = (ngx_slab_page_t *) p;</span><br><span class="line">  </span><br><span class="line">//设置pages的属性</span><br><span class="line">      </span><br><span class="line">pool-&gt;pages-&gt;slab = pages;</span><br><span class="line">      </span><br><span class="line">pool-&gt;pages-&gt;next = &amp;pool-&gt;free;</span><br><span class="line">      </span><br><span class="line">pool-&gt;pages-&gt;prev = (uintptr_t) &amp;pool-&gt;free;</span><br><span class="line">  </span><br><span class="line">//设置起始值，这里刚好是跳过slot和page部分。</span><br><span class="line">      </span><br><span class="line">pool-&gt;start = (u_char *)</span><br><span class="line">                    </span><br><span class="line">ngx_align_ptr((uintptr_t) p + pages * sizeof(ngx_slab_page_t),</span><br><span class="line">                                   </span><br><span class="line">ngx_pagesize);</span><br></pre></td></tr></table></figure>
<p>而小于ngx_slab_max_size又分为3种情况，这里也是按照请求的大小来进行划分，分界线是ngx_slab_exact_shift，由于一个slab将会管理很多个块，此时就需要一个东西来表示每个块的具体情况，这里这个数值就是用来控制使用什么样的方式来表示每个块的使用情况，当等于ngx_slab_exact_shift的话，nginx会直接使用一个域叫做slab(uintptr_t类型 )，它的每一位表示每一个块的使用情况，这里会提前算好slab域最多能表示多少个块的使用情况，这个值就成为我们这里的exact。当小于ngx_slab_exact_shift，则说明slab域无法表示完全所有的块，这个时候会在数据区域的head加上一个bitmap的数组，这个数组就保存了当前slab的所有块的使用情况，而当大于ngx_slab_exact_shift,此时slab保存信息绰绰有余，并且我们必须知道当前的shift在一页能够分配多少个块，因此我们还需要存储当前的shift，于是nginx在slab的低16位或者32位(64位平台),来保存当前页的shift。</p>
<p>紧接着就是free域，这个域一直指向第一个没有被使用的页面。因此每次分配页面都会从free开始，而free页面则会将页面返还给free。</p>
<p>来看对应的代码，这部分的代码都在ngx_slab_alloc_locked中,这个是slab的分配函数，首先它会判断请求的大小是否大于ngx_slab_max_size,如果大于它则说明需要从pages数组进行分配，因此会先计算需要分配的页数量，然后从page数组汇总返回对应的page slab位置，最终从start计算偏移然后返回给用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (size &gt;= ngx_slab_max_size) &#123;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, ngx_cycle-&gt;log, 0,</span><br><span class="line">                         </span><br><span class="line">&quot;slab alloc: %uz&quot;, size);</span><br><span class="line">  </span><br><span class="line">//得到对应的page，也就是page数组的对应元素。</span><br><span class="line">          </span><br><span class="line">page = ngx_slab_alloc_pages(pool, (size + ngx_pagesize - 1)</span><br><span class="line">                                            </span><br><span class="line">&gt;&gt; ngx_pagesize_shift);</span><br><span class="line">          </span><br><span class="line">if (page) &#123;</span><br><span class="line">  </span><br><span class="line">//得到想对于start的偏移。</span><br><span class="line">              </span><br><span class="line">p = (page - pool-&gt;pages) &lt;&lt; ngx_pagesize_shift;</span><br><span class="line">              </span><br><span class="line">p += (uintptr_t) pool-&gt;start;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">              </span><br><span class="line">p = 0;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goto done;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来主要来看当第一次分配内存的情况，也就是当前的slot为空，并没有对应的页面。此时需要alloc一个页面，然后根据大小来对块进行管理。</p>
<p>首先是请求大小小于ngx_slab_exact_shift的情况，这时候需要内存前放一个header来保存位图，而位图数组的个数计算是这样的，首先计算需要多少字节（(1 &lt;&lt; (ngx_pagesize_shift - shift)），然后再来计算需要多少数量(除上sizeof(uintptr_t) * 8). 这里要注意prev指针,这里prev指针的后2位会被用来保存当前的page对应的类型(也就是对应ngx_slab_exact_shift的分割). <figure class="highlight plain"><figcaption><span>(shift < ngx_slab_exact_shift) &#123;</span><a href="//得到对应的偏移">p </a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>if (page-&gt;slab == NGX_SLAB_BUSY) {</p>
<p>//取出prev指针，这里要清除尾部保存的shift</p>
<p>prev = (ngx_slab_page_t *)</p>
<p>(page-&gt;prev &amp; ~NGX_SLAB_PAGE_MASK);</p>
<p>prev-&gt;next = page-&gt;next;</p>
<p>page-&gt;next-&gt;prev = page-&gt;prev;</p>
<p>page-&gt;next = NULL;</p>
<p>page-&gt;prev = NGX_SLAB_EXACT;</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后就是上面很重要的一个函数，ngx_slab_alloc_pages，这个函数主要是用来分配一定数量page，然后返回。它的实现是这样的，遍历free，找到适合的page，然后返回对应的page。这里要注意每一个free掉的page最终都会挂载到free上。</span><br></pre></td></tr></table></figure>
<p>static ngx_slab_page_t *</p>
<p>ngx_slab_alloc_pages(ngx_slab_pool_t *pool, ngx_uint_t pages)</p>
<p>{</p>
<p>ngx_slab_page_t *page, *p;</p>
<p>//开始遍历free指针。</p>
<p>for (page = pool-&gt;free.next; page != &amp;pool-&gt;free; page = page-&gt;next) {</p>
<p>//判断slab值，也就是看还能分配多少page。</p>
<p>if (page-&gt;slab &gt;= pages) {</p>
<p>//如果是远远大于pages，则直接分配对应的page，然后将当前的要分配的page从free中去除。</p>
<p>if (page-&gt;slab &gt; pages) {</p>
<p>//更新page的属性。</p>
<p>page[pages].slab = page-&gt;slab - pages;</p>
<p>page[pages].next = page-&gt;next;</p>
<p>page[pages].prev = page-&gt;prev;</p>
<p>//从free中去除</p>
<p>p = (ngx_slab_page_t *) page-&gt;prev;</p>
<p>p-&gt;next = &amp;page[pages];</p>
<p>page-&gt;next-&gt;prev = (uintptr_t) &amp;page[pages];</p>
<p>} else {</p>
<p>p = (ngx_slab_page_t *) page-&gt;prev;</p>
<p>p-&gt;next = page-&gt;next;</p>
<p>page-&gt;next-&gt;prev = page-&gt;prev;</p>
<p>}</p>
<p>//设置slab</p>
<p>page-&gt;slab = pages | NGX_SLAB_PAGE_START;</p>
<p>page-&gt;next = NULL;</p>
<p>page-&gt;prev = NGX_SLAB_PAGE;</p>
<p>//如果只是分配一个page，则直接返回</p>
<p>if (–pages == 0) {</p>
<p>return page;</p>
<p>}</p>
<p>//否则需要将已经分配的页的slab全部设置为busy。</p>
<p>for (p = page + 1; pages; pages–) {</p>
<p>p-&gt;slab = NGX_SLAB_PAGE_BUSY;</p>
<p>p-&gt;next = NULL;</p>
<p>p-&gt;prev = NGX_SLAB_PAGE;</p>
<p>p++;</p>
<p>}</p>
<p>return page;</p>
<p>}</p>
<p>}</p>
<p>ngx_slab_error(pool, NGX_LOG_CRIT, “ngx_slab_alloc() failed: no memory”);</p>
<p>return NULL;</p>
<p>}</p>
<p><code>`</code></p>
</div><div class="tags"><a href="/tags/nginx/">nginx</a><a href="/tags/server，mm/">server，mm</a></div><div class="post-nav"><a class="pre" href="/2010/12/31/goodbye-2010.html">再见2010</a><a class="next" href="/2010/12/12/xps-characteristics-of-linux-kernel-network-protocol-stack.html">linux kernel 网络协议栈之xps特性详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>