<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nginx中upstream的设计和实现(四) | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nginx中upstream的设计和实现(四)</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">nginx中upstream的设计和实现(四)</h1><div class="post-meta">Aug 6, 2011<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a><a href="/categories/nginx/server/">server</a></span></div><div class="post-content"><p>这此主要是分析发送数据到客户端的部分以及buffering状态下，nginx接收upstream数据的部分，这也是upstream的最复杂的部分，这里我还是忽略了cache部分，以后我会专门写blog来分析nginx的cache部分。</p>
<p>这部分的函数入口是ngx_http_upstream_send_response，这里有一个很重要的标记，那就是u-&gt;buffering，这个标记的含义就是nginx是否会尽可能多的读取upstream的数据。如果关闭，则就是一个同步的发送，也就是接收多少，发送给客户端多少。默认这个是打开的。也就是nginx会buf住upstream发送的数据。</p>
<p>不管buffering是否打开，后端发送的头都不会被buffer，首先会发送header，然后才是body的发送，而body的发送就需要区分buffering选项了。如下图所示：</p>
<p><a href="http://www.flickr.com/photos/67458145@N00/6015131336/" title="upstream_ac by Minibobo, on Flickr" target="_blank" rel="noopener"><img src="http://farm7.static.flickr.com/6013/6015131336_7fcfe4edba.jpg" width="500" height="163" alt="upstream_ac"></a></p>
<a id="more"></a>



<p>下面这部分就是开始发送header，通过调用 ngx_http_send_header最终进入header filter的处理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">rc = ngx_http_send_header(r);</span><br><span class="line"></span><br><span class="line">if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;post_action) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, rc);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是发送body部分，这里我们先来看buffering被关闭的情况，这里有两个要注意的回调函数，分别是input_filter/input_filter_init,这个filter回调指的是对upstream发送给nginx的数据将要发送前的filter(严格来说是一个body filter).这里如果input_filter没有被设置，则nginx会有默认的回调.后面我们会分析这个默认的filter，以及这个filter具体是需要操作那个数据。要注意，这两个回调都只是针对buffering被关闭的情况，而对应buffering打开的时候的情况，有另外的hook，我们后面会分析到.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (!u-&gt;buffering) &#123;</span><br><span class="line">  </span><br><span class="line">//如果input_filter为空，则设置默认的filter</span><br><span class="line">          </span><br><span class="line">if (u-&gt;input_filter == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">u-&gt;input_filter_init = ngx_http_upstream_non_buffered_filter_init;</span><br><span class="line">              </span><br><span class="line">u-&gt;input_filter = ngx_http_upstream_non_buffered_filter;</span><br><span class="line">              </span><br><span class="line">u-&gt;input_filter_ctx = r;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置读写函数</span><br><span class="line">          </span><br><span class="line">u-&gt;read_event_handler = ngx_http_upstream_process_non_buffered_upstream;</span><br><span class="line">          </span><br><span class="line">r-&gt;write_event_handler =</span><br><span class="line">                               </span><br><span class="line">ngx_http_upstream_process_non_buffered_downstream;</span><br><span class="line"></span><br><span class="line">r-&gt;limit_rate = 0;</span><br><span class="line">  </span><br><span class="line">//调用input filter 初始化函数</span><br><span class="line">          </span><br><span class="line">if (u-&gt;input_filter_init(u-&gt;input_filter_ctx) == NGX_ERROR) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//打开nodelay，准备将数据完全发送出去</span><br><span class="line">          </span><br><span class="line">if (clcf-&gt;tcp_nodelay &amp;&amp; c-&gt;tcp_nodelay == NGX_TCP_NODELAY_UNSET) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, &quot;tcp_nodelay&quot;);</span><br><span class="line"></span><br><span class="line">tcp_nodelay = 1;</span><br><span class="line"></span><br><span class="line">if (setsockopt(c-&gt;fd, IPPROTO_TCP, TCP_NODELAY,</span><br><span class="line">                                 </span><br><span class="line">(const void *) &amp;tcp_nodelay, sizeof(int)) == -1)</span><br><span class="line">              </span><br><span class="line">&#123;</span><br><span class="line">                  </span><br><span class="line">ngx_connection_error(c, ngx_socket_errno,</span><br><span class="line">                                       </span><br><span class="line">&quot;setsockopt(TCP_NODELAY) failed&quot;);</span><br><span class="line">                  </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c-&gt;tcp_nodelay = NGX_TCP_NODELAY_SET;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//得到将要发送的数据的大小</span><br><span class="line">          </span><br><span class="line">n = u-&gt;buffer.last &amp;#8211; u-&gt;buffer.pos;</span><br><span class="line"></span><br><span class="line">if (n) &#123;</span><br><span class="line">  </span><br><span class="line">//注意这里，可以看到buffer被reset了。</span><br><span class="line">              </span><br><span class="line">u-&gt;buffer.last = u-&gt;buffer.pos;</span><br><span class="line">  </span><br><span class="line">//设置将要发送的数据大小</span><br><span class="line">              </span><br><span class="line">u-&gt;state-&gt;response_length += n;</span><br><span class="line">  </span><br><span class="line">//调用input filter</span><br><span class="line">              </span><br><span class="line">if (u-&gt;input_filter(u-&gt;input_filter_ctx, n) == NGX_ERROR) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//最终开始发送数据到downstream</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_process_non_buffered_downstream(r);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//说明buffer是空</span><br><span class="line">              </span><br><span class="line">u-&gt;buffer.pos = u-&gt;buffer.start;</span><br><span class="line">              </span><br><span class="line">u-&gt;buffer.last = u-&gt;buffer.start;</span><br><span class="line">  </span><br><span class="line">//此时刷新数据到client</span><br><span class="line">              </span><br><span class="line">if (ngx_http_send_special(r, NGX_HTTP_FLUSH) == NGX_ERROR) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果可读，则继续读取upstream的数据.</span><br><span class="line">              </span><br><span class="line">if (u-&gt;peer.connection-&gt;read-&gt;ready) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_http_upstream_process_non_buffered_upstream(r, u);</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的部分我们有2个函数需要详细分析下，一个是input filter的hook，一个是ngx_http_upstream_process_non_buffered_downstream，一个个来，先是input filter的book。</p>
<p>u-&gt;input_filter hook主要是对upstream发送的body进行一些处理，类似body filter， 上面的分析中我们可以看到当调用u-&gt;input_filter之前将u-&gt;buffer.last重置为pos，这个做法我有些不太理解， 我的猜测是让代码更清晰一些，因为在u-&gt;input_filter中我们会真正更新u-&gt;buffer.last.</p>
<p>在u-&gt;input_filter中，主要是会分配一个chain，然后挂载到u-&gt;out_bufs上，因为最终nginx会发送u-&gt;out_bufs这个chain(后面的代码会看到).并且u-&gt;buffer的last也会被更新，我们来看使用最多，也就是默认的u-&gt;input_filter的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static ngx_int_t</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_non_buffered_filter(void *data, ssize_t bytes)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_http_request_t *r = data;</span><br><span class="line"></span><br><span class="line">ngx_buf_t *b;</span><br><span class="line">      </span><br><span class="line">ngx_chain_t \*cl, \**ll;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_t *u;</span><br><span class="line"></span><br><span class="line">u = r-&gt;upstream;</span><br><span class="line">  </span><br><span class="line">//遍历u-&gt;out_bufs</span><br><span class="line">      </span><br><span class="line">for (cl = u-&gt;out_bufs, ll = &amp;u-&gt;out_bufs; cl; cl = cl-&gt;next) &#123;</span><br><span class="line">          </span><br><span class="line">ll = &amp;cl-&gt;next;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cl = ngx_chain_get_free_buf(r-&gt;pool, &amp;u-&gt;free_bufs);</span><br><span class="line">      </span><br><span class="line">if (cl == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*ll = cl;</span><br><span class="line"></span><br><span class="line">cl-&gt;buf-&gt;flush = 1;</span><br><span class="line">      </span><br><span class="line">cl-&gt;buf-&gt;memory = 1;</span><br><span class="line">  </span><br><span class="line">//取出将要发送的buffer</span><br><span class="line">      </span><br><span class="line">b = &amp;u-&gt;buffer;</span><br><span class="line"></span><br><span class="line">cl-&gt;buf-&gt;pos = b-&gt;last;</span><br><span class="line">  </span><br><span class="line">//更新last</span><br><span class="line">      </span><br><span class="line">b-&gt;last += bytes;</span><br><span class="line">      </span><br><span class="line">cl-&gt;buf-&gt;last = b-&gt;last;</span><br><span class="line">      </span><br><span class="line">cl-&gt;buf-&gt;tag = u-&gt;output.tag;</span><br><span class="line">  </span><br><span class="line">//u-&gt;length表示将要发送的数据大小(content_length)如果为NGX_MAX_SIZE_T_VALUE,则说明后端协议并没有指定需要发送的大小，此时我们只需要发送我们接收到的.</span><br><span class="line">      </span><br><span class="line">if (u-&gt;length == NGX_MAX_SIZE_T_VALUE) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_OK;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//更新将要发送的数据大小</span><br><span class="line">      </span><br><span class="line">u-&gt;length -= bytes;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是ngx_http_upstream_process_non_buffered_downstream函数，这个函数用于非buffering状态下发送数据给client，它会调用ngx_http_upstream_process_non_buffered_request来发送数据，因此我们就来详细分析这个函数.</p>
<p>这个函数有两个参数，其中第二个do_write表示是否需要立即发送数据.</p>
<p>主要来看这个函数的下面这部分,这部分主要是调用ngx_http_output_filter输出给body filter，然后根据返回值来更新busy_bufs(没有发送完毕，则保存未发送完毕的bufer到busy),可以看到和http部分的处理很类似.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">b = &amp;u-&gt;buffer;</span><br><span class="line"></span><br><span class="line">do_write = do_write || u-&gt;length == 0;</span><br><span class="line"></span><br><span class="line">for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">if (do_write) &#123;</span><br><span class="line">  </span><br><span class="line">//如果u-&gt;out_bufs不为NULL则说明有需要发送的数据，如果u-&gt;busy_bufs，则说明上次有未发送完毕的数据.</span><br><span class="line">              </span><br><span class="line">if (u-&gt;out_bufs || u-&gt;busy_bufs) &#123;</span><br><span class="line">                  </span><br><span class="line">rc = ngx_http_output_filter(r, u-&gt;out_bufs);</span><br><span class="line"></span><br><span class="line">if (rc == NGX_ERROR) &#123;</span><br><span class="line">                      </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">                      </span><br><span class="line">return;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//更新busy chain</span><br><span class="line">                  </span><br><span class="line">ngx_chain_update_chains(&amp;u-&gt;free_bufs, &amp;u-&gt;busy_bufs,</span><br><span class="line">                                          </span><br><span class="line">&amp;u-&gt;out_bufs, u-&gt;output.tag);</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//这里说明想要发送的数据都已经发送完毕</span><br><span class="line">              </span><br><span class="line">if (u-&gt;busy_bufs == NULL) &#123;</span><br><span class="line">  </span><br><span class="line">//length为0，说明后端这次要发送的数据已经发送完毕</span><br><span class="line">                  </span><br><span class="line">if (u-&gt;length == 0</span><br><span class="line">                      </span><br><span class="line">|| upstream-&gt;read-&gt;eof</span><br><span class="line">                      </span><br><span class="line">|| upstream-&gt;read-&gt;error)</span><br><span class="line">                  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">//此时finalize request，结束这次请求</span><br><span class="line">                      </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">                      </span><br><span class="line">return;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//否则重置u-&gt;buffer,以便与下次使用</span><br><span class="line">                  </span><br><span class="line">b-&gt;pos = b-&gt;start;</span><br><span class="line">                  </span><br><span class="line">b-&gt;last = b-&gt;start;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//得到当前buf的剩余空间</span><br><span class="line">          </span><br><span class="line">size = b-&gt;end &amp;#8211; b-&gt;last;</span><br><span class="line">  </span><br><span class="line">//设置size为将要使用的buffer大小</span><br><span class="line">          </span><br><span class="line">if (size &gt; u-&gt;length) &#123;</span><br><span class="line">              </span><br><span class="line">size = u-&gt;length;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果还有数据需要接受，并且upstream可读，则读取数据</span><br><span class="line">          </span><br><span class="line">if (size &amp;&amp; upstream-&gt;read-&gt;ready) &#123;</span><br><span class="line"></span><br><span class="line">n = upstream-&gt;recv(upstream, b-&gt;last, size);</span><br><span class="line"></span><br><span class="line">if (n == NGX_AGAIN) &#123;</span><br><span class="line">                  </span><br><span class="line">break;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">                  </span><br><span class="line">u-&gt;state-&gt;response_length += n;</span><br><span class="line">  </span><br><span class="line">//再次调用input_filter,这里没有reset u-&gt;buffer.last,这是因为我们这个值并没有更新.</span><br><span class="line">                  </span><br><span class="line">if (u-&gt;input_filter(u-&gt;input_filter_ctx, n) == NGX_ERROR) &#123;</span><br><span class="line">                      </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">                      </span><br><span class="line">return;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置do_write,然后发送数据.</span><br><span class="line">              </span><br><span class="line">do_write = 1;</span><br><span class="line"></span><br><span class="line">continue;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数剩下部分就很简单了，就是挂载事件，删除定时器等一系列操作。</p>
<p>然后我们来看nginx最复杂的一块代码，也就是使用了buffering标记的条件下，nginx如何处理.</p>
<p>这里有一个核心的数据结构ngx_event_pipe_s。接下来，我们就来分析这个结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct ngx_event_pipe_s &#123;</span><br><span class="line">  </span><br><span class="line">//表示nginx和client，以及和后端的两条连接</span><br><span class="line">      </span><br><span class="line">ngx_connection_t *upstream;</span><br><span class="line">      </span><br><span class="line">ngx_connection_t *downstream;</span><br><span class="line">  </span><br><span class="line">//保存了从upstream读取的数据(没有经过任何处理的)，以及缓存的buf.</span><br><span class="line">      </span><br><span class="line">ngx_chain_t *free_raw_bufs;</span><br><span class="line">      </span><br><span class="line">ngx_chain_t *in;</span><br><span class="line">      </span><br><span class="line">ngx_chain_t **last_in;</span><br><span class="line">  </span><br><span class="line">//buf到tempfile的数据会放到out中</span><br><span class="line">      </span><br><span class="line">ngx_chain_t *out;</span><br><span class="line">      </span><br><span class="line">ngx_chain_t **last_out;</span><br><span class="line"></span><br><span class="line">ngx_chain_t *free;</span><br><span class="line">      </span><br><span class="line">ngx_chain_t *busy;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">       </span><br><span class="line">* the input filter i.e. that moves HTTP/1.1 chunks</span><br><span class="line">       </span><br><span class="line">* from the raw bufs to an incoming chain</span><br><span class="line">       </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">ngx_event_pipe_input_filter_pt input_filter;</span><br><span class="line">      </span><br><span class="line">void *input_ctx;</span><br><span class="line">  </span><br><span class="line">//这个filter就是输出内容到client的函数，一般设置为ngx_chain_writer</span><br><span class="line">      </span><br><span class="line">ngx_event_pipe_output_filter_pt output_filter;</span><br><span class="line">      </span><br><span class="line">void *output_ctx;</span><br><span class="line">  </span><br><span class="line">//一些状态以及属性</span><br><span class="line">      </span><br><span class="line">unsigned read:1;</span><br><span class="line">      </span><br><span class="line">unsigned cacheable:1;</span><br><span class="line">      </span><br><span class="line">unsigned single_buf:1;</span><br><span class="line">      </span><br><span class="line">unsigned free_bufs:1;</span><br><span class="line">      </span><br><span class="line">unsigned upstream_done:1;</span><br><span class="line">      </span><br><span class="line">unsigned upstream_error:1;</span><br><span class="line">      </span><br><span class="line">unsigned upstream_eof:1;</span><br><span class="line">      </span><br><span class="line">unsigned upstream_blocked:1;</span><br><span class="line">      </span><br><span class="line">unsigned downstream_done:1;</span><br><span class="line">      </span><br><span class="line">unsigned downstream_error:1;</span><br><span class="line">      </span><br><span class="line">unsigned cyclic_temp_file:1;</span><br><span class="line">  </span><br><span class="line">//配合bufs使用，表示已经分配了的buf的个数</span><br><span class="line">      </span><br><span class="line">ngx_int_t allocated;</span><br><span class="line">  </span><br><span class="line">//对应xxx_buffers,也就是读取后端的数据时的bufer大小以及个数</span><br><span class="line">      </span><br><span class="line">ngx_bufs_t bufs;</span><br><span class="line">      </span><br><span class="line">ngx_buf_tag_t tag;</span><br><span class="line"></span><br><span class="line">ssize_t busy_size;</span><br><span class="line"></span><br><span class="line">off_t read_length;</span><br><span class="line">  </span><br><span class="line">//cache相关，max_temp_file_size表示最大的temp file的大小,temp_file_write_size表示buf将会flush到temp file中的大小.</span><br><span class="line">      </span><br><span class="line">off_t max_temp_file_size;</span><br><span class="line">      </span><br><span class="line">ssize_t temp_file_write_size;</span><br><span class="line">  </span><br><span class="line">//网络相关的参数，定时器，以及lowat</span><br><span class="line">      </span><br><span class="line">ngx_msec_t read_timeout;</span><br><span class="line">      </span><br><span class="line">ngx_msec_t send_timeout;</span><br><span class="line">      </span><br><span class="line">ssize_t send_lowat;</span><br><span class="line"></span><br><span class="line">ngx_pool_t *pool;</span><br><span class="line">      </span><br><span class="line">ngx_log_t *log;</span><br><span class="line">  </span><br><span class="line">//预读的buf以及大小，这里预读是指已经从upstream读取了的buf.</span><br><span class="line">      </span><br><span class="line">ngx_chain_t *preread_bufs;</span><br><span class="line">      </span><br><span class="line">size_t preread_size;</span><br><span class="line">  </span><br><span class="line">//cache相关表示将要cache到文件的buf</span><br><span class="line">      </span><br><span class="line">ngx_buf_t *buf_to_file;</span><br><span class="line">  </span><br><span class="line">//cache相关，表示temp file</span><br><span class="line">      </span><br><span class="line">ngx_temp_file_t *temp_file;</span><br><span class="line"></span><br><span class="line">/\* STUB \*/ int num;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后就是ngx_http_upstream_send_response的剩余部分，这部分主要是初始化event pipe结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">p = u-&gt;pipe;</span><br><span class="line">  </span><br><span class="line">//设置filter，可以看到就是http的输出filter</span><br><span class="line">      </span><br><span class="line">p-&gt;output_filter = (ngx_event_pipe_output_filter_pt) ngx_http_output_filter;</span><br><span class="line">      </span><br><span class="line">p-&gt;output_ctx = r;</span><br><span class="line">      </span><br><span class="line">p-&gt;tag = u-&gt;output.tag;</span><br><span class="line">  </span><br><span class="line">//设置bufs，它就是upstream中设置的bufs</span><br><span class="line">      </span><br><span class="line">p-&gt;bufs = u-&gt;conf-&gt;bufs;</span><br><span class="line">  </span><br><span class="line">//busy buffers的大小</span><br><span class="line">      </span><br><span class="line">p-&gt;busy_size = u-&gt;conf-&gt;busy_buffers_size;</span><br><span class="line">  </span><br><span class="line">//upstream</span><br><span class="line">      </span><br><span class="line">p-&gt;upstream = u-&gt;peer.connection;</span><br><span class="line">      </span><br><span class="line">p-&gt;downstream = c;</span><br><span class="line">      </span><br><span class="line">p-&gt;pool = r-&gt;pool;</span><br><span class="line">      </span><br><span class="line">p-&gt;log = c-&gt;log;</span><br><span class="line">  </span><br><span class="line">//设置是否需要cache</span><br><span class="line">      </span><br><span class="line">p-&gt;cacheable = u-&gt;cacheable || u-&gt;store;</span><br><span class="line">  </span><br><span class="line">//初始化temp_file</span><br><span class="line">      </span><br><span class="line">p-&gt;temp_file = ngx_pcalloc(r-&gt;pool, sizeof(ngx_temp_file_t));</span><br><span class="line">      </span><br><span class="line">if (p-&gt;temp_file == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;temp_file-&gt;file.fd = NGX_INVALID_FILE;</span><br><span class="line">      </span><br><span class="line">p-&gt;temp_file-&gt;file.log = c-&gt;log;</span><br><span class="line">      </span><br><span class="line">p-&gt;temp_file-&gt;path = u-&gt;conf-&gt;temp_path;</span><br><span class="line">      </span><br><span class="line">p-&gt;temp_file-&gt;pool = r-&gt;pool;</span><br><span class="line"></span><br><span class="line">if (p-&gt;cacheable) &#123;</span><br><span class="line">          </span><br><span class="line">p-&gt;temp_file-&gt;persistent = 1;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">          </span><br><span class="line">p-&gt;temp_file-&gt;log_level = NGX_LOG_WARN;</span><br><span class="line">          </span><br><span class="line">p-&gt;temp_file-&gt;warn = &quot;an upstream response is buffered &quot;</span><br><span class="line">                               </span><br><span class="line">&quot;to a temporary file&quot;;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//temp file的相关设置</span><br><span class="line">      </span><br><span class="line">p-&gt;max_temp_file_size = u-&gt;conf-&gt;max_temp_file_size;</span><br><span class="line">      </span><br><span class="line">p-&gt;temp_file_write_size = u-&gt;conf-&gt;temp_file_write_size;</span><br><span class="line">  </span><br><span class="line">//初始化preread bufs</span><br><span class="line">      </span><br><span class="line">p-&gt;preread_bufs = ngx_alloc_chain_link(r-&gt;pool);</span><br><span class="line">      </span><br><span class="line">if (p-&gt;preread_bufs == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;preread_bufs-&gt;buf = &amp;u-&gt;buffer;</span><br><span class="line">      </span><br><span class="line">p-&gt;preread_bufs-&gt;next = NULL;</span><br><span class="line">      </span><br><span class="line">u-&gt;buffer.recycled = 1;</span><br><span class="line"></span><br><span class="line">p-&gt;preread_size = u-&gt;buffer.last &amp;#8211; u-&gt;buffer.pos;</span><br><span class="line">  </span><br><span class="line">//设置cache相关</span><br><span class="line">      </span><br><span class="line">if (u-&gt;cacheable) &#123;</span><br><span class="line"></span><br><span class="line">p-&gt;buf_to_file = ngx_calloc_buf(r-&gt;pool);</span><br><span class="line">          </span><br><span class="line">if (p-&gt;buf_to_file == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;buf_to_file-&gt;pos = u-&gt;buffer.start;</span><br><span class="line">          </span><br><span class="line">p-&gt;buf_to_file-&gt;last = u-&gt;buffer.pos;</span><br><span class="line">          </span><br><span class="line">p-&gt;buf_to_file-&gt;temporary = 1;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ngx_event_flags &amp; NGX_USE_AIO_EVENT) &#123;</span><br><span class="line">          </span><br><span class="line">/\* the posted aio operation may currupt a shadow buffer \*/</span><br><span class="line">          </span><br><span class="line">p-&gt;single_buf = 1;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/\* TODO: p-&gt;free_bufs = 0 if use ngx_create_chain_of_bufs() \*/</span><br><span class="line">      </span><br><span class="line">p-&gt;free_bufs = 1;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">       </span><br><span class="line">* event_pipe would do u-&gt;buffer.last += p-&gt;preread_size</span><br><span class="line">       </span><br><span class="line">* as though these bytes were read</span><br><span class="line">       </span><br><span class="line">*/</span><br><span class="line">      </span><br><span class="line">u-&gt;buffer.last = u-&gt;buffer.pos;</span><br><span class="line"></span><br><span class="line">if (u-&gt;conf-&gt;cyclic_temp_file) &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">           </span><br><span class="line">* we need to disable the use of sendfile() if we use cyclic temp file</span><br><span class="line">           </span><br><span class="line">* because the writing a new data may interfere with sendfile()</span><br><span class="line">           </span><br><span class="line">* that uses the same kernel file pages (at least on FreeBSD)</span><br><span class="line">           </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">p-&gt;cyclic_temp_file = 1;</span><br><span class="line">          </span><br><span class="line">c-&gt;sendfile = 0;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">          </span><br><span class="line">p-&gt;cyclic_temp_file = 0;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//事件相关的初始化</span><br><span class="line">      </span><br><span class="line">p-&gt;read_timeout = u-&gt;conf-&gt;read_timeout;</span><br><span class="line">      </span><br><span class="line">p-&gt;send_timeout = clcf-&gt;send_timeout;</span><br><span class="line">      </span><br><span class="line">p-&gt;send_lowat = clcf-&gt;send_lowat;</span><br><span class="line">  </span><br><span class="line">//挂载读写回调函数，这里注意一个是upstream的读回调，一个是r(client)的写回调</span><br><span class="line">      </span><br><span class="line">u-&gt;read_event_handler = ngx_http_upstream_process_upstream;</span><br><span class="line">      </span><br><span class="line">r-&gt;write_event_handler = ngx_http_upstream_process_downstream;</span><br><span class="line">  </span><br><span class="line">//进入upstream的操作</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_process_upstream(r, u);</span><br></pre></td></tr></table></figure>

<p>通过上面我们可以看到主要操作都在两个回调函数中，一个是upstream的读handler，一个是downstream的写handler，我们一个个看，先来看upstream的读handler。</p>
<p>这个函数首先会判断是否超时，如果超时则设置错误，否则调用ngx_event_pipe进入pipe的读处理，然后调用ngx_http_upstream_process_request对upstream进行处理，比如退出等一系列操作，因此这里最核心的函数就是ngx_event_pipe。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_process_upstream(ngx_http_request_t *r,</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_t *u)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_connection_t *c;</span><br><span class="line"></span><br><span class="line">c = u-&gt;peer.connection;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0,</span><br><span class="line">                     </span><br><span class="line">&quot;http upstream process upstream&quot;);</span><br><span class="line"></span><br><span class="line">c-&gt;log-&gt;action = &quot;reading upstream&quot;;</span><br><span class="line">  </span><br><span class="line">//判断超时</span><br><span class="line">      </span><br><span class="line">if (c-&gt;read-&gt;timedout) &#123;</span><br><span class="line">          </span><br><span class="line">u-&gt;pipe-&gt;upstream_error = 1;</span><br><span class="line">          </span><br><span class="line">ngx_connection_error(c, NGX_ETIMEDOUT, &quot;upstream timed out&quot;);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//调用event_pipe进对读取数据进行处理.</span><br><span class="line">          </span><br><span class="line">if (ngx_event_pipe(u-&gt;pipe, 0) == NGX_ABORT) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u, 0);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_http_upstream_process_request(r);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来看ngx_event_pipe的源代码，ngx_event_pipe第二个参数是do_write,表示是否需要将数据立即写到downstream,也就是client.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ngx_int_t</span><br><span class="line">  </span><br><span class="line">ngx_event_pipe(ngx_event_pipe_t *p, ngx_int_t do_write)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">u_int flags;</span><br><span class="line">      </span><br><span class="line">ngx_int_t rc;</span><br><span class="line">      </span><br><span class="line">ngx_event_t \*rev, \*wev;</span><br><span class="line"></span><br><span class="line">for ( ;; ) &#123;</span><br><span class="line">  </span><br><span class="line">//判断是否需要将数据写到downstream.</span><br><span class="line">          </span><br><span class="line">if (do_write) &#123;</span><br><span class="line">              </span><br><span class="line">p-&gt;log-&gt;action = &quot;sending to client&quot;;</span><br><span class="line">  </span><br><span class="line">//写数据到downstream</span><br><span class="line">              </span><br><span class="line">rc = ngx_event_pipe_write_to_downstream(p);</span><br><span class="line"></span><br><span class="line">if (rc == NGX_ABORT) &#123;</span><br><span class="line">                  </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (rc == NGX_BUSY) &#123;</span><br><span class="line">                  </span><br><span class="line">return NGX_OK;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;read = 0;</span><br><span class="line">          </span><br><span class="line">p-&gt;upstream_blocked = 0;</span><br><span class="line"></span><br><span class="line">p-&gt;log-&gt;action = &quot;reading upstream&quot;;</span><br><span class="line">  </span><br><span class="line">//读取数据</span><br><span class="line">          </span><br><span class="line">if (ngx_event_pipe_read_upstream(p) == NGX_ABORT) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//判断是否需要退出循环，p-&gt;read表示是否已经读取了upstream的数据，upstream_blocked表示是否downstream可写(后面代码会看到这两个变量的设置)</span><br><span class="line">          </span><br><span class="line">if (!p-&gt;read &amp;&amp; !p-&gt;upstream_blocked) &#123;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//可以看到如果读取了数据就准备写数据到downstream</span><br><span class="line">          </span><br><span class="line">do_write = 1;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//判断是否需要挂载读事件</span><br><span class="line">      </span><br><span class="line">if (p-&gt;upstream-&gt;fd != -1) &#123;</span><br><span class="line">          </span><br><span class="line">rev = p-&gt;upstream-&gt;read;</span><br><span class="line"></span><br><span class="line">flags = (rev-&gt;eof || rev-&gt;error) ? NGX_CLOSE_EVENT : 0;</span><br><span class="line"></span><br><span class="line">if (ngx_handle_read_event(rev, flags) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (rev-&gt;active &amp;&amp; !rev-&gt;ready) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_add_timer(rev, p-&gt;read_timeout);</span><br><span class="line"></span><br><span class="line">&#125; else if (rev-&gt;timer_set) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_del_timer(rev);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//挂载写事件。</span><br><span class="line">      </span><br><span class="line">if (p-&gt;downstream-&gt;fd != -1 &amp;&amp; p-&gt;downstream-&gt;data == p-&gt;output_ctx) &#123;</span><br><span class="line">          </span><br><span class="line">wev = p-&gt;downstream-&gt;write;</span><br><span class="line">          </span><br><span class="line">if (ngx_handle_write_event(wev, p-&gt;send_lowat) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!wev-&gt;delayed) &#123;</span><br><span class="line">              </span><br><span class="line">if (wev-&gt;active &amp;&amp; !wev-&gt;ready) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_add_timer(wev, p-&gt;send_timeout);</span><br><span class="line"></span><br><span class="line">&#125; else if (wev-&gt;timer_set) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_del_timer(wev);</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们能看到核心的函数有这么2个，分别是ngx_event_pipe_read_upstream和ngx_event_pipe_write_to_downstream，这两个 一个是从后端都数据，一个是发送数据到前端。其中read最为复杂，因此我们先来看read回调，这个函数比较长，我们一段段的来。</p>
<p>先来看这个函数的一个基本结构:</p>
<p><a href="http://www.flickr.com/photos/67458145@N00/6015176846/" title="upstream_read by Minibobo, on Flickr" target="_blank" rel="noopener"><img src="http://farm7.static.flickr.com/6028/6015176846_d75c68cb40.jpg" width="469" height="363" alt="upstream_read"></a></p>
<p>这个函数的主要处理都在一个for循环里面，这个for循环比较长，因此我们就来分段分析这个for循环。这个for循环的主要作用就是从后端读取数据。</p>
<p>因此它首先需要做的就是分配buf，以便于从后端接收数据，可是如果第一次我们接收头的时候，多接收了一些buf，此时我们就先处理这部分buf，然后再接收新的buf.</p>
<p>下面这段主要是进行状态判断，以及当preread_bufs存在的情况的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//判断upstream的状态</span><br><span class="line">          </span><br><span class="line">if (p-&gt;upstream_eof || p-&gt;upstream_error || p-&gt;upstream_done) &#123;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果preread_bufs为空(上面的初始化中这个buf也就是upstream读取头的时候，解析完头，然后剩余的buf),并且upstream并不可读，此时则说明对数据也没有任何操作和读取的必要，因此退出循环.</span><br><span class="line">          </span><br><span class="line">if (p-&gt;preread_bufs == NULL &amp;&amp; !p-&gt;upstream-&gt;read-&gt;ready) &#123;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果preread_bufs存在</span><br><span class="line">          </span><br><span class="line">if (p-&gt;preread_bufs) &#123;</span><br><span class="line"></span><br><span class="line">/\* use the pre-read bufs if they exist \*/</span><br><span class="line">  </span><br><span class="line">//使用preread_bufs</span><br><span class="line">              </span><br><span class="line">chain = p-&gt;preread_bufs;</span><br><span class="line">  </span><br><span class="line">//可以看到设置preread_bufs为空，这样子，下次循环，则会进入另外的处理，也就是需要从upstream读取数据</span><br><span class="line">              </span><br><span class="line">p-&gt;preread_bufs = NULL;</span><br><span class="line">  </span><br><span class="line">//n也就是u-&gt;buf的大小</span><br><span class="line">              </span><br><span class="line">n = p-&gt;preread_size;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0,</span><br><span class="line">                             </span><br><span class="line">&quot;pipe preread: %z&quot;, n);</span><br><span class="line"></span><br><span class="line">if (n) &#123;</span><br><span class="line">  </span><br><span class="line">//设置read，也就是当前upstream中存在读取还没发送的数据.</span><br><span class="line">                  </span><br><span class="line">p-&gt;read = 1;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后下面这段代码就是当p-&gt;preread_bufs为空的情况，此时就需要从upstream来读取数据，而读取之前则需要分配buf，以供upstream使用，因此下面这段代码，就是用来分配buf的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">else &#123;</span><br><span class="line">  </span><br><span class="line">//首先是看free_raw_bufs是否存在，如果存在，则直接使用它。</span><br><span class="line">              </span><br><span class="line">if (p-&gt;free_raw_bufs) &#123;</span><br><span class="line"></span><br><span class="line">/\* use the free bufs if they exist \*/</span><br><span class="line"></span><br><span class="line">chain = p-&gt;free_raw_bufs;</span><br><span class="line">                  </span><br><span class="line">if (p-&gt;single_buf) &#123;</span><br><span class="line">                      </span><br><span class="line">p-&gt;free_raw_bufs = p-&gt;free_raw_bufs-&gt;next;</span><br><span class="line">                      </span><br><span class="line">chain-&gt;next = NULL;</span><br><span class="line">                  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">                      </span><br><span class="line">p-&gt;free_raw_bufs = NULL;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else if (p-&gt;allocated &lt; p-&gt;bufs.num) &#123;</span><br><span class="line">  </span><br><span class="line">//如果free_raw_bufs不存在，并且分配的buf数量没有超过bufs的个数，此时则创建新的buf</span><br><span class="line">                  </span><br><span class="line">/\* allocate a new buf if it&amp;#8217;s still allowed \*/</span><br><span class="line"></span><br><span class="line">b = ngx_create_temp_buf(p-&gt;pool, p-&gt;bufs.size);</span><br><span class="line">                  </span><br><span class="line">if (b == NULL) &#123;</span><br><span class="line">                      </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;allocated++;</span><br><span class="line"></span><br><span class="line">chain = ngx_alloc_chain_link(p-&gt;pool);</span><br><span class="line">                  </span><br><span class="line">if (chain == NULL) &#123;</span><br><span class="line">                      </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chain-&gt;buf = b;</span><br><span class="line">                  </span><br><span class="line">chain-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">&#125; else if (!p-&gt;cacheable</span><br><span class="line">                         </span><br><span class="line">&amp;&amp; p-&gt;downstream-&gt;data == p-&gt;output_ctx</span><br><span class="line">                         </span><br><span class="line">&amp;&amp; p-&gt;downstream-&gt;write-&gt;ready</span><br><span class="line">                         </span><br><span class="line">&amp;&amp; !p-&gt;downstream-&gt;write-&gt;delayed)</span><br><span class="line">              </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">//如果已经分配的bufs的个数大于预设定的个数，并且没有打开cache，而且downstream可写，则设置upstream_blocked，准备写数据到upstream(这个是为了发送数据之后，数据buf能够被使用读)</span><br><span class="line">                  </span><br><span class="line">p-&gt;upstream_blocked = 1;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0,</span><br><span class="line">                                 </span><br><span class="line">&quot;pipe downstream ready&quot;);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">&#125; else if (p-&gt;cacheable</span><br><span class="line">                         </span><br><span class="line">|| p-&gt;temp_file-&gt;offset &lt; p-&gt;max_temp_file_size)</span><br><span class="line">              </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">//到达这里有两个情况，一个是cacheable打开，一个是当buf不够用了，此时就会将一部分数据buf到temp file中。这个函数我下篇blog会详细分析，这次之需要知道这个将会将数据buf到temp file，然后绑定到p-&gt;out中。</span><br><span class="line">                  </span><br><span class="line">rc = ngx_event_pipe_write_chain_to_temp_file(p);</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0,</span><br><span class="line">                                 </span><br><span class="line">&quot;pipe temp offset: %O&quot;, p-&gt;temp_file-&gt;offset);</span><br><span class="line">  </span><br><span class="line">//处理返回值</span><br><span class="line">                  </span><br><span class="line">if (rc == NGX_BUSY) &#123;</span><br><span class="line">                      </span><br><span class="line">break;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (rc == NGX_AGAIN) &#123;</span><br><span class="line">                      </span><br><span class="line">if (ngx_event_flags &amp; NGX_USE_LEVEL_EVENT</span><br><span class="line">                          </span><br><span class="line">&amp;&amp; p-&gt;upstream-&gt;read-&gt;active</span><br><span class="line">                          </span><br><span class="line">&amp;&amp; p-&gt;upstream-&gt;read-&gt;ready)</span><br><span class="line">                      </span><br><span class="line">&#123;</span><br><span class="line">                          </span><br><span class="line">if (ngx_del_event(p-&gt;upstream-&gt;read, NGX_READ_EVENT, 0)</span><br><span class="line">                              </span><br><span class="line">== NGX_ERROR)</span><br><span class="line">                          </span><br><span class="line">&#123;</span><br><span class="line">                              </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">                          </span><br><span class="line">&#125;</span><br><span class="line">                      </span><br><span class="line">&#125;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (rc != NGX_OK) &#123;</span><br><span class="line">                      </span><br><span class="line">return rc;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//说明写成功，此时free_raw_bufs已经被重新赋值，也就是我们可以使用，所以类似上面free_raw_bufs存在的处理</span><br><span class="line">                  </span><br><span class="line">chain = p-&gt;free_raw_bufs;</span><br><span class="line">                  </span><br><span class="line">if (p-&gt;single_buf) &#123;</span><br><span class="line">                      </span><br><span class="line">p-&gt;free_raw_bufs = p-&gt;free_raw_bufs-&gt;next;</span><br><span class="line">                      </span><br><span class="line">chain-&gt;next = NULL;</span><br><span class="line">                  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">                      </span><br><span class="line">p-&gt;free_raw_bufs = NULL;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">/\* there are no bufs to read in \*/</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0,</span><br><span class="line">                                 </span><br><span class="line">&quot;no pipe bufs to read in&quot;);</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//开始从后端读取数据，可以看到数据被读取进chain，n表示读到的字节数</span><br><span class="line">              </span><br><span class="line">n = p-&gt;upstream-&gt;recv_chain(p-&gt;upstream, chain);</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0,</span><br><span class="line">                             </span><br><span class="line">&quot;pipe recv chain: %z&quot;, n);</span><br><span class="line">  </span><br><span class="line">//如果将chain添加到free_raw_bufs的开头</span><br><span class="line">              </span><br><span class="line">if (p-&gt;free_raw_bufs) &#123;</span><br><span class="line">                  </span><br><span class="line">chain-&gt;next = p-&gt;free_raw_bufs;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line">p-&gt;free_raw_bufs = chain;</span><br><span class="line">  </span><br><span class="line">//设置error</span><br><span class="line">              </span><br><span class="line">if (n == NGX_ERROR) &#123;</span><br><span class="line">                  </span><br><span class="line">p-&gt;upstream_error = 1;</span><br><span class="line">                  </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (n == NGX_AGAIN) &#123;</span><br><span class="line">                  </span><br><span class="line">if (p-&gt;single_buf) &#123;</span><br><span class="line">                      </span><br><span class="line">ngx_event_pipe_remove_shadow_links(chain-&gt;buf);</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置read，表示已经读取了数据</span><br><span class="line">              </span><br><span class="line">p-&gt;read = 1;</span><br><span class="line">  </span><br><span class="line">//如果返回0，则说明对端关闭了连接</span><br><span class="line">              </span><br><span class="line">if (n == 0) &#123;</span><br><span class="line">                  </span><br><span class="line">p-&gt;upstream_eof = 1;</span><br><span class="line">                  </span><br><span class="line">break;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是for循环的最后一段，到达这一段说明从后端的数据已经读取到了chain中，然后n为已经读取的数据，于是开始遍历已经读取的chain。</p>
<p>它会遍历chain，然后调用input_filter来将buf拷贝到 p-&gt;in/last_in 中，最后将chain free掉。这里buf 会有一个shadow 的域，在遍历chain的时候，需要将对应buf的shadow删除掉。</p>
<p>对于shadow域我是这么理解的，就是每次我们在input_filter中拷贝cl-&gt;buf的域到p-&gt;in/last_in的buf域的时候，也就是制造了一个cl-&gt;buf的影子，而他们是共享对应的内存。此时这两个buf就是互相shadow的。他们的shadow域都是指向对方。不过这个域我觉得并不是很必须，上次在邮件列表也看到igor说不喜欢这东西，不过不知道什么时候能删掉它.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//更新已经读取了的字节数</span><br><span class="line">          </span><br><span class="line">p-&gt;read_length += n;</span><br><span class="line">          </span><br><span class="line">cl = chain;</span><br><span class="line">          </span><br><span class="line">p-&gt;free_raw_bufs = NULL;</span><br><span class="line">  </span><br><span class="line">//开始遍历chain，</span><br><span class="line">          </span><br><span class="line">while (cl &amp;&amp; n &gt; 0) &#123;</span><br><span class="line">  </span><br><span class="line">//首先remove shadow buf</span><br><span class="line">              </span><br><span class="line">ngx_event_pipe_remove_shadow_links(cl-&gt;buf);</span><br><span class="line">  </span><br><span class="line">//得到当前的chain buf的空间大小（因为读取数据，是从cl-&gt;buf-&gt;last开始的)</span><br><span class="line">              </span><br><span class="line">size = cl-&gt;buf-&gt;end &amp;#8211; cl-&gt;buf-&gt;last;</span><br><span class="line">  </span><br><span class="line">//如果已经读取的字节数大于等于chain buf，则对当前的buf进行更新。</span><br><span class="line">              </span><br><span class="line">if (n &gt;= size) &#123;</span><br><span class="line">  </span><br><span class="line">//更新last</span><br><span class="line">                  </span><br><span class="line">cl-&gt;buf-&gt;last = cl-&gt;buf-&gt;end;</span><br><span class="line"></span><br><span class="line">/\* STUB \*/ cl-&gt;buf-&gt;num = p-&gt;num++;</span><br><span class="line">  </span><br><span class="line">//调用input_filter</span><br><span class="line">                  </span><br><span class="line">if (p-&gt;input_filter(p, cl-&gt;buf) == NGX_ERROR) &#123;</span><br><span class="line">                      </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//更新n/cl 最终free chain</span><br><span class="line">                  </span><br><span class="line">n -= size;</span><br><span class="line">                  </span><br><span class="line">ln = cl;</span><br><span class="line">                  </span><br><span class="line">cl = cl-&gt;next;</span><br><span class="line">                  </span><br><span class="line">ngx_free_chain(p-&gt;pool, ln);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//否则则说明当前的chain是最后一个chain，因此更新last，然后设置n，以便与退出循环。这里要注意，可以看到nginx并没有调用input_filter,这是因为，nginx会尽量的使cl-&gt;buf最大情况下调用p-&gt;input_filter,不过这里会有个问题，当cl-&gt;buf没有最大，此时后端断开连接，这时就会少调用一次p-&gt;input_filter.不过nginx在最后会处理这个问题的。</span><br><span class="line">                  </span><br><span class="line">cl-&gt;buf-&gt;last += n;</span><br><span class="line">                  </span><br><span class="line">n = 0;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果cl还存在，则说明我们开始设置的chain，只有一部分被使用了，因此此时将这写chain保存到free_raw_bufs中。可以看到如果chain只有一部分被使用，然后当再次循环，则使用的chain会直接使用free_raw_bufs,也就是我们前一次没有使用完全的chain</span><br><span class="line">          </span><br><span class="line">if (cl) &#123;</span><br><span class="line">              </span><br><span class="line">for (ln = cl; ln-&gt;next; ln = ln-&gt;next) &#123; /\* void \*/ &#125;</span><br><span class="line"></span><br><span class="line">ln-&gt;next = p-&gt;free_raw_bufs;</span><br><span class="line">              </span><br><span class="line">p-&gt;free_raw_bufs = cl;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的p-&gt;input_filter我们后面再分析，先来看函数剩余的部分剩余的这一部分主要是处理free_raw_bufs，调用p-&gt;input_filter，将free_raw_bufs中的数据保存发送chain中，这个就是为了解决前面少调用一次p-&gt;input_filter的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if ((p-&gt;upstream_eof || p-&gt;upstream_error) &amp;&amp; p-&gt;free_raw_bufs) &#123;</span><br><span class="line"></span><br><span class="line">/\* STUB \*/ p-&gt;free_raw_bufs-&gt;buf-&gt;num = p-&gt;num++;</span><br><span class="line">  </span><br><span class="line">//调用input_filter.</span><br><span class="line">          </span><br><span class="line">if (p-&gt;input_filter(p, p-&gt;free_raw_bufs-&gt;buf) == NGX_ERROR) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;free_raw_bufs = p-&gt;free_raw_bufs-&gt;next;</span><br><span class="line">  </span><br><span class="line">//遍历，然后</span><br><span class="line">          </span><br><span class="line">if (p-&gt;free_bufs &amp;&amp; p-&gt;buf_to_file == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">for (cl = p-&gt;free_raw_bufs; cl; cl = cl-&gt;next) &#123;</span><br><span class="line">                  </span><br><span class="line">if (cl-&gt;buf-&gt;shadow == NULL) &#123;</span><br><span class="line">                      </span><br><span class="line">ngx_pfree(p-&gt;pool, cl-&gt;buf-&gt;start);</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果cache打开，并且p-&gt;in存在(也就是有读取的数据),则写数据到temp file。</span><br><span class="line">      </span><br><span class="line">if (p-&gt;cacheable &amp;&amp; p-&gt;in) &#123;</span><br><span class="line">          </span><br><span class="line">if (ngx_event_pipe_write_chain_to_temp_file(p) == NGX_ABORT) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_ABORT;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来看p-&gt;input_filter的实现，这里我们就来分析，nginx默认实现的一个ngx_event_pipe_copy_input_filter，其中proxy等模块都是调用这个filter。它主要是拷贝buf(不是buf的内容，只是buf的属性)到p-&gt;in或者p-&gt;last_in,这两个域都是用来和write数据的时候交互用的。这两个域的区别是这样子的</p>
<p>p-&gt;in只能保存一个chain，而p-&gt;in这条链上的剩余的chain都保存在p-&gt;last_in中，这么做的原因还不太清楚，而且搜索了下代码，last_in也没有被使用到.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ngx_int_t</span><br><span class="line">  </span><br><span class="line">ngx_event_pipe_copy_input_filter(ngx_event_pipe_t \*p, ngx_buf_t \*buf)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_buf_t *b;</span><br><span class="line">      </span><br><span class="line">ngx_chain_t *cl;</span><br><span class="line"></span><br><span class="line">if (buf-&gt;pos == buf-&gt;last) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_OK;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果free存在，则从free中取得缓存的buf</span><br><span class="line">      </span><br><span class="line">if (p-&gt;free) &#123;</span><br><span class="line">          </span><br><span class="line">cl = p-&gt;free;</span><br><span class="line">          </span><br><span class="line">b = cl-&gt;buf;</span><br><span class="line">          </span><br><span class="line">p-&gt;free = cl-&gt;next;</span><br><span class="line">          </span><br><span class="line">ngx_free_chain(p-&gt;pool, cl);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//否则分配buf</span><br><span class="line">          </span><br><span class="line">b = ngx_alloc_buf(p-&gt;pool);</span><br><span class="line">          </span><br><span class="line">if (b == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//拷贝buf的属性</span><br><span class="line">      </span><br><span class="line">ngx_memcpy(b, buf, sizeof(ngx_buf_t));</span><br><span class="line">      </span><br><span class="line">b-&gt;shadow = buf;</span><br><span class="line">      </span><br><span class="line">b-&gt;tag = p-&gt;tag;</span><br><span class="line">      </span><br><span class="line">b-&gt;last_shadow = 1;</span><br><span class="line">      </span><br><span class="line">b-&gt;recycled = 1;</span><br><span class="line">      </span><br><span class="line">buf-&gt;shadow = b;</span><br><span class="line">  </span><br><span class="line">//分配chain</span><br><span class="line">      </span><br><span class="line">cl = ngx_alloc_chain_link(p-&gt;pool);</span><br><span class="line">      </span><br><span class="line">if (cl == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cl-&gt;buf = b;</span><br><span class="line">      </span><br><span class="line">cl-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, p-&gt;log, 0, &quot;input buf #%d&quot;, b-&gt;num);</span><br><span class="line"></span><br><span class="line">if (p-&gt;in) &#123;</span><br><span class="line">          </span><br><span class="line">*p-&gt;last_in = cl;</span><br><span class="line">      </span><br><span class="line">&#125; else &#123;</span><br><span class="line">          </span><br><span class="line">p-&gt;in = cl;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">p-&gt;last_in = &amp;cl-&gt;next;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次就分析到这里，下次将会分析upstream的数据发送的部分。</p>
</div><div class="tags"><a href="/tags/nginx/">nginx</a></div><div class="post-nav"><a class="pre" href="/2011/08/17/design-and-implementation-of-upstream-in-nginx-5.html">nginx中upstream的设计和实现(五)</a><a class="next" href="/2011/07/30/c-reference-manual-reading-notes-three.html">c reference manual读书笔记(三)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/redo-log-design-and-implementation-in-innodb-1.html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/mtr-minitransaction-design-and-implementation.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-·-rocksdb-data-reading-2.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-·-rocksdb-data-reading-1.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-·-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-·-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/mysql-·-rocksdb-memtable-write.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/mysql-·-rocksdb-implementation-of-write-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>