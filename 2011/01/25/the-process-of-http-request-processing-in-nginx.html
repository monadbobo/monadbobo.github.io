<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nginx中http request处理的流程 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nginx中http request处理的流程</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">nginx中http request处理的流程</h1><div class="post-meta">Jan 25, 2011<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a><a href="/categories/nginx/server/">server</a></span></div><div class="post-content"><p>这次主要来看nginx如何处理一个http的流程，也就是接收请求，解析，然后接收完毕，然后开始发送数据，这一系列是如何流转起来的，通过上2篇，我们知道了nginx初始化完毕之后会休眠在epoll(或者kqueue等等).</p>
<p>下面就是nginx的事件处理流程图.</p>
<p><a href="http://www.flickr.com/photos/67458145@N00/5386896447/" title="ngx_request by Minibobo, on Flickr" target="_blank" rel="noopener"><img src="http://farm6.static.flickr.com/5217/5386896447_3876b7bcd7.jpg" width="217" height="500" alt="ngx_request"></a></p>
<a id="more"></a>

<p>然后我们就来看ngx_event_accept函数，这个函数被调用是当listen 句柄有可读事件之后才被调用，它会accept到一个新的句柄，然后设置新的句柄的回调，然后再次返回。而这个新的句柄的回调将会进入nginx的整个http的处理机。</p>
<p>这个函数也是比较长的，我们来一段段的看。</p>
<p>首先下面这段就是accpet 句柄 ,这里我要得瑟一下，accept4 这个系统调用，是我给nginx发的patch，然后被igor吸收加到nginx的0.9 develop里面的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          </span><br><span class="line">socklen = NGX_SOCKADDRLEN;</span><br><span class="line">  </span><br><span class="line">//开始accept句柄</span><br><span class="line">  </span><br><span class="line">#if (NGX_HAVE_ACCEPT4)</span><br><span class="line">          </span><br><span class="line">s = accept4(lc-&gt;fd, (struct sockaddr *) sa, &amp;socklen, SOCK_NONBLOCK);</span><br><span class="line">  </span><br><span class="line">#else</span><br><span class="line">          </span><br><span class="line">s = accept(lc-&gt;fd, (struct sockaddr *) sa, &amp;socklen);</span><br><span class="line">  </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>接下来就是从连接池取得连接，然后创建连接里面包含的数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">          </span><br><span class="line">c = ngx_get_connection(s, ev-&gt;log);</span><br><span class="line"></span><br><span class="line">if (c == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">if (ngx_close_socket(s) == -1) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_log_error(NGX_LOG_ALERT, ev-&gt;log, ngx_socket_errno,</span><br><span class="line">                                </span><br><span class="line">ngx_close_socket_n &quot; failed&quot;);</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if (NGX_STAT_STUB)</span><br><span class="line">          </span><br><span class="line">(void) ngx_atomic_fetch_add(ngx_stat_active, 1);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">//创建内存池</span><br><span class="line">          </span><br><span class="line">c-&gt;pool = ngx_create_pool(ls-&gt;pool_size, ev-&gt;log);</span><br><span class="line">          </span><br><span class="line">if (c-&gt;pool == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_close_accepted_connection(c);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//分配客户端地址</span><br><span class="line">          </span><br><span class="line">c-&gt;sockaddr = ngx_palloc(c-&gt;pool, socklen);</span><br><span class="line">          </span><br><span class="line">if (c-&gt;sockaddr == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_close_accepted_connection(c);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_memcpy(c-&gt;sockaddr, sa, socklen);</span><br><span class="line">  </span><br><span class="line">//分配log</span><br><span class="line">          </span><br><span class="line">log = ngx_palloc(c-&gt;pool, sizeof(ngx_log_t));</span><br><span class="line">          </span><br><span class="line">if (log == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_close_accepted_connection(c);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是初始化从来连接池取出来的连接。主要是发送，接受回调，以及客户端地址等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">          </span><br><span class="line">*log = ls-&gt;log;</span><br><span class="line">  </span><br><span class="line">//设置读取的回调，这里依赖于操作系统。以后会详细介绍nginx的event框架</span><br><span class="line">          </span><br><span class="line">c-&gt;recv = ngx_recv;</span><br><span class="line">          </span><br><span class="line">c-&gt;send = ngx_send;</span><br><span class="line">          </span><br><span class="line">c-&gt;recv_chain = ngx_recv_chain;</span><br><span class="line">          </span><br><span class="line">c-&gt;send_chain = ngx_send_chain;</span><br><span class="line"></span><br><span class="line">c-&gt;log = log;</span><br><span class="line">          </span><br><span class="line">c-&gt;pool-&gt;log = log;</span><br><span class="line">  </span><br><span class="line">//设置client的ip地址</span><br><span class="line">          </span><br><span class="line">c-&gt;socklen = socklen;</span><br><span class="line">          </span><br><span class="line">c-&gt;listening = ls;</span><br><span class="line">          </span><br><span class="line">c-&gt;local_sockaddr = ls-&gt;sockaddr;</span><br><span class="line"></span><br><span class="line">c-&gt;unexpected_eof = 1;</span><br><span class="line"></span><br><span class="line">#if (NGX_HAVE_UNIX_DOMAIN)</span><br><span class="line">          </span><br><span class="line">if (c-&gt;sockaddr-&gt;sa_family == AF_UNIX) &#123;</span><br><span class="line">              </span><br><span class="line">c-&gt;tcp_nopush = NGX_TCP_NOPUSH_DISABLED;</span><br><span class="line">              </span><br><span class="line">c-&gt;tcp_nodelay = NGX_TCP_NODELAY_DISABLED;</span><br><span class="line">  </span><br><span class="line">#if (NGX_SOLARIS)</span><br><span class="line">              </span><br><span class="line">/\* Solaris&amp;#8217;s sendfilev() supports AF_NCA, AF_INET, and AF_INET6 \*/</span><br><span class="line">              </span><br><span class="line">c-&gt;sendfile = 0;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">//准备设置读写的结构</span><br><span class="line">          </span><br><span class="line">rev = c-&gt;read;</span><br><span class="line">          </span><br><span class="line">wev = c-&gt;write;</span><br><span class="line"></span><br><span class="line">wev-&gt;ready = 1;</span><br><span class="line"></span><br><span class="line">if (ngx_event_flags &amp; (NGX_USE_AIO_EVENT|NGX_USE_RTSIG_EVENT)) &#123;</span><br><span class="line">              </span><br><span class="line">/\* rtsig, aio, iocp \*/</span><br><span class="line">              </span><br><span class="line">rev-&gt;ready = 1;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (ev-&gt;deferred_accept) &#123;</span><br><span class="line">              </span><br><span class="line">rev-&gt;ready = 1;</span><br><span class="line">  </span><br><span class="line">#if (NGX_HAVE_KQUEUE)</span><br><span class="line">              </span><br><span class="line">rev-&gt;available = 1;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置log</span><br><span class="line">          </span><br><span class="line">rev-&gt;log = log;</span><br><span class="line">          </span><br><span class="line">wev-&gt;log = log;</span><br></pre></td></tr></table></figure>

<p>最后一部分就是最关键的一部分，到达这里说明连接已经初始化完毕，句柄已经取到，按照一般的想法，这个时候就需要将连接加入到事件驱动器中，并且需要设置新的句柄的一些回调处理函数。可是nginx并没有这么做，它只是先设置回调函数，可是并不加事件到epoll中。</p>
<p>这里可以看到是调用ls-&gt;handler(c)，而这个handler 前两篇blog 我们知道是被初始化为ngx_http_init_connection，也就是最终会调用这个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//如果不是epoll的话，就调用add_conn</span><br><span class="line">          </span><br><span class="line">if (ngx_add_conn &amp;&amp; (ngx_event_flags &amp; NGX_USE_EPOLL_EVENT) == 0) &#123;</span><br><span class="line">              </span><br><span class="line">if (ngx_add_conn(c) == NGX_ERROR) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_close_accepted_connection(c);</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log-&gt;data = NULL;</span><br><span class="line">          </span><br><span class="line">log-&gt;handler = NULL;</span><br><span class="line">  </span><br><span class="line">//调用回调</span><br><span class="line">          </span><br><span class="line">ls-&gt;handler(c);</span><br><span class="line"></span><br><span class="line">if (ngx_event_flags &amp; NGX_USE_KQUEUE_EVENT) &#123;</span><br><span class="line">              </span><br><span class="line">ev-&gt;available&amp;#8211;;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是ngx_http_init_connection函数了，这个函数主要是设置当前句柄的读handler，如果数据可读，则直接调用request handler，如果数据不可读，则设置定时器(超时定时器),并将这个句柄挂载到事件处理器上。</p>
<p>这里有一个需要注意的地方，那就是如果使用了ngx_use_accept_mutex锁的话，那么就不能够立即处理request，因为处理request是一个非常耗时的操作，而现在在锁里面，所以此时之需要将这个读事件挂载到ngx_posted_events队列，等退出锁之后再进行处理。</p>
<p>而一般来说默认都会使用mutex锁，因此此时就将rev加到post_events队列中，然后直接返回，那么可能就要问了，什么时候会把事件挂载到epoll中呢，这个我们接下来会分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ngx_http_init_connection(ngx_connection_t *c)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_event_t *rev;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line"></span><br><span class="line">c-&gt;log_error = NGX_ERROR_INFO;</span><br><span class="line"></span><br><span class="line">rev = c-&gt;read;</span><br><span class="line">  </span><br><span class="line">//设置读handler.</span><br><span class="line">      </span><br><span class="line">rev-&gt;handler = ngx_http_init_request;</span><br><span class="line">      </span><br><span class="line">c-&gt;write-&gt;handler = ngx_http_empty_handler;</span><br><span class="line"></span><br><span class="line">#if (NGX_STAT_STUB)</span><br><span class="line">      </span><br><span class="line">(void) ngx_atomic_fetch_add(ngx_stat_reading, 1);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">//如果接收准备好了，则直接调用ngx_http_init_request,如果</span><br><span class="line">      </span><br><span class="line">if (rev-&gt;ready) &#123;</span><br><span class="line">          </span><br><span class="line">/\* the deferred accept(), rtsig, aio, iocp \*/</span><br><span class="line">  </span><br><span class="line">//如果使用了mutex锁，则post 这个event，然后返回。</span><br><span class="line">          </span><br><span class="line">if (ngx_use_accept_mutex) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_post_event(rev, &amp;ngx_posted_events);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_http_init_request(rev);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//添加定时器</span><br><span class="line">      </span><br><span class="line">ngx_add_timer(rev, c-&gt;listening-&gt;post_accept_timeout);</span><br><span class="line">  </span><br><span class="line">//将事件挂载到事件处理器</span><br><span class="line">      </span><br><span class="line">if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123;</span><br><span class="line">  </span><br><span class="line">#if (NGX_STAT_STUB)</span><br><span class="line">          </span><br><span class="line">(void) ngx_atomic_fetch_add(ngx_stat_reading, -1);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">          </span><br><span class="line">ngx_http_close_connection(c);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，然后我们来看如果使用了ngx_use_accept_mutex的话，是在那里进入ngx_http_init_request的处理的。</p>
<p>我们回到ngx_process_events_and_timers函数，当我们从ngx_http_init_connection返回时，我们来看nginx接下来会做什么事情。</p>
<p>到达下面的逻辑，此时mutex锁已经被让出，所以此时我们可以处理整个request。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//如果post_event链表存在，则会进入链表的处理</span><br><span class="line">      </span><br><span class="line">if (ngx_posted_events) &#123;</span><br><span class="line">          </span><br><span class="line">if (ngx_threaded) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_wakeup_worker_thread(cycle);</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//处理post event。</span><br><span class="line">              </span><br><span class="line">ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是ngx_event_process_poste函数，这个函数很简单，就是遍历event队列，然后调用event的handler函数，而我们还记得上面在ngx_http_init_connection中设置的handler就是ngx_http_init_request，这样子，我们就再一次进入request的处理，可是此时依旧没有挂载读事件到epoll。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void</span><br><span class="line">  </span><br><span class="line">ngx_event_process_posted(ngx_cycle_t *cycle,</span><br><span class="line">      </span><br><span class="line">ngx_thread_volatile ngx_event_t **posted)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_event_t *ev;</span><br><span class="line"></span><br><span class="line">for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">ev = (ngx_event_t \*) \*posted;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&gt;log, 0,</span><br><span class="line">                        </span><br><span class="line">&quot;posted event %p&quot;, ev);</span><br><span class="line"></span><br><span class="line">if (ev == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_delete_posted_event(ev);</span><br><span class="line">  </span><br><span class="line">//调用handler</span><br><span class="line">          </span><br><span class="line">ev-&gt;handler(ev);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是ngx_http_init_request，进入这个函数，说明客户端有请求过来了，此时我们就需要进入http的协议解析部分了，因此在这个函数主要就是初始化request结构，初始化完毕后进入解析处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_init_request(ngx_event_t *rev)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">//设置handler回调</span><br><span class="line">     </span><br><span class="line">rev-&gt;handler = ngx_http_process_request_line;</span><br><span class="line">      </span><br><span class="line">r-&gt;read_event_handler = ngx_http_block_reading;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">  </span><br><span class="line">//进入解析request 部分。</span><br><span class="line">      </span><br><span class="line">rev-&gt;handler(rev);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后来看ngx_http_process_request_line，这个函数就是对request line进行解析，而解析部分在我以前的blog已经分析过了，这里就不详细分析了。这里要注意一个地方。 我们知道nginx 使用的是epoll的ET模式，而et模式的话，就需要能够判断这次读取的数据是否读完，这里nginx是这样判断的，那就是根据协议来判断，也就是协议驱动，由协议来判断是否有读取完毕。</p>
<p>这里要注意，如果我们使用了mutex锁，那么现在进入这个函数之后，我们会通过ngx_http_read_request_header中来挂载读事件到epoll。</p>
<p>来看代码片段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (rev-&gt;ready) &#123;</span><br><span class="line">          </span><br><span class="line">n = c-&gt;recv(c, r-&gt;header_in-&gt;last,</span><br><span class="line">                      </span><br><span class="line">r-&gt;header_in-&gt;end &amp;#8211; r-&gt;header_in-&gt;last);</span><br><span class="line">      </span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//第一次进来设置n为again</span><br><span class="line">          </span><br><span class="line">n = NGX_AGAIN;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (n == NGX_AGAIN) &#123;</span><br><span class="line">          </span><br><span class="line">if (!rev-&gt;timer_set) &#123;</span><br><span class="line">              </span><br><span class="line">cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);</span><br><span class="line">              </span><br><span class="line">ngx_add_timer(rev, cscf-&gt;client_header_timeout);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//然后挂载读事件.</span><br><span class="line">          </span><br><span class="line">if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">              </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是ngx_http_process_request_line函数，可以看到它会调用ngx_http_read_request_header.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">if (rc == NGX_AGAIN) &#123;</span><br><span class="line">  </span><br><span class="line">//读取request.</span><br><span class="line">              </span><br><span class="line">n = ngx_http_read_request_header(r);</span><br><span class="line"></span><br><span class="line">if (n == NGX_AGAIN || n == NGX_ERROR) &#123;</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//然后开始parse</span><br><span class="line">          </span><br><span class="line">rc = ngx_http_parse_request_line(r, r-&gt;header_in);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后当parse结束后通过rc来判断解析的结果，如果是NGX_OK则说明header解析完毕，如果是NGX_AGAIN,则说明header只解析了一部分。我们这里主要来看NGX_OK的情况，就是当request line完全解析完毕时，nginx做什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          </span><br><span class="line">if (rc == NGX_OK) &#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">              </span><br><span class="line">c-&gt;log-&gt;action = &quot;reading client request headers&quot;;</span><br><span class="line">  </span><br><span class="line">//设置并调用ngx_http_process_request_headers执行后续操作(解析header)</span><br><span class="line">              </span><br><span class="line">rev-&gt;handler = ngx_http_process_request_headers;</span><br><span class="line">              </span><br><span class="line">ngx_http_process_request_headers(rev);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ngx_http_process_request_headers这个函数主要是解析http的request header，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_process_request_headers(ngx_event_t *rev)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">     </span><br><span class="line">rc = NGX_AGAIN;</span><br><span class="line"></span><br><span class="line">for ( ;; ) &#123;</span><br><span class="line"></span><br><span class="line">if (rc == NGX_AGAIN) &#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">              </span><br><span class="line">n = ngx_http_read_request_header(r);</span><br><span class="line"></span><br><span class="line">if (n == NGX_AGAIN || n == NGX_ERROR) &#123;</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">rc = ngx_http_parse_header_line(r, r-&gt;header_in,</span><br><span class="line">                                          </span><br><span class="line">cscf-&gt;underscores_in_headers);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">          </span><br><span class="line">if (rc == NGX_OK) &#123;</span><br><span class="line">  </span><br><span class="line">//这个判断里面会设置request中的预制header(cookie, id_modify_since等等)</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">if (rc == NGX_HTTP_PARSE_HEADER_DONE) &#123;</span><br><span class="line">  </span><br><span class="line">//到达这里说明header解析完毕.</span><br><span class="line">                       </span><br><span class="line">r-&gt;request_length += r-&gt;header_in-&gt;pos &amp;#8211; r-&gt;header_in-&gt;start;</span><br><span class="line"></span><br><span class="line">r-&gt;http_state = NGX_HTTP_PROCESS_REQUEST_STATE;</span><br><span class="line">  </span><br><span class="line">//这里主要是进行一些头的校验</span><br><span class="line">              </span><br><span class="line">rc = ngx_http_process_request_header(r);</span><br><span class="line"></span><br><span class="line">if (rc != NGX_OK) &#123;</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//然后进入nginx的http处理(进入phase处理)</span><br><span class="line">              </span><br><span class="line">ngx_http_process_request(r);</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ngx_http_process_request就不分析了，这个函数在以前分析sub request以及nginx的handler处理的时候都有介绍过。它会调用nginx的handler phase处理链表。</p>
<p>上面的处理结束之后，可以看到nginx并没有挂载可写事件，这是因为可写事件发生是只要内核的写缓冲区大于可写的最小水位就可以写，而http是短连接，因此不可写的情况是很少的，所以nginx会默认第一次就是可写的，于是nginx这里是只有当我们需要写的数据没有写完的情况才会挂载写事件.来看相关代码。</p>
<p>首先在connect结构中有一个buffered的结构，nginx就用这个域来控制是否需要加入可写事件。这个值的设置在ngx_http_write_filter中，它的设置就不详细分析了，我们之需要知道如果当数据没有发送完，这个就会被设置.</p>
<p>来看ngx_http_finalize_request关于write handler的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//如果buffered有设置，则会挂载写事件.</span><br><span class="line">      </span><br><span class="line">if (r-&gt;buffered || c-&gt;buffered || r-&gt;postponed || r-&gt;blocked) &#123;</span><br><span class="line"></span><br><span class="line">if (ngx_http_set_write_handler(r) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_terminate_request(r, 0);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/nginx/">nginx</a><a href="/tags/server/">server</a></div><div class="post-nav"><a class="pre" href="/2011/01/28/introduction-to-linux-kernel-tcpip-procotol-stack.html">introduction to linux kernel tcp/ip procotol stack</a><a class="next" href="/2011/01/21/nginx-startup-process-analysis-2.html">nginx的启动流程分析(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/redo-log-design-and-implementation-in-innodb-1.html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/mtr-minitransaction-design-and-implementation.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-·-rocksdb-data-reading-2.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-·-rocksdb-data-reading-1.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-·-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-·-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/mysql-·-rocksdb-memtable-write.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/mysql-·-rocksdb-implementation-of-write-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>