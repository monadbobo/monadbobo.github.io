<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nginx对keepalive和pipeline请求处理分析 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nginx对keepalive和pipeline请求处理分析</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">nginx对keepalive和pipeline请求处理分析</h1><div class="post-meta">Feb 17, 2011<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a><a href="/categories/nginx/server/">server</a></span></div><div class="post-content"><p>这次主要来看nginx中对keepalive和pipeline的处理，这里概念就不用介绍了。直接来看nginx是如何来做的。</p>
<p>首先来看keepalive的处理。我们知道http 1.1中keepalive是默认的，除非客户端显式的指定connect头为close。下面就是nginx判断是否需要keepalive的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void</span><br><span class="line">  </span><br><span class="line">ngx_http_handler(ngx_http_request_t *r)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">          </span><br><span class="line">switch (r-&gt;headers_in.connection_type) &#123;</span><br><span class="line">          </span><br><span class="line">case 0:</span><br><span class="line">  </span><br><span class="line">//如果版本大于1.0则默认是keepalive</span><br><span class="line">              </span><br><span class="line">r-&gt;keepalive = (r-&gt;http_version &gt; NGX_HTTP_VERSION_10);</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case NGX_HTTP_CONNECTION_CLOSE:</span><br><span class="line">  </span><br><span class="line">//如果指定connection头为close则不需要keepalive</span><br><span class="line">              </span><br><span class="line">r-&gt;keepalive = 0;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case NGX_HTTP_CONNECTION_KEEP_ALIVE:</span><br><span class="line">              </span><br><span class="line">r-&gt;keepalive = 1;</span><br><span class="line">              </span><br><span class="line">break;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后我们知道keepalive也就是当前的http request执行完毕后并不会直接关闭当前的连接，因此nginx的keepalive的相关处理也就是清理request的函数中。</p>
<p>nginx清理requst的函数是ngx_http_finalize_request，这个函数中会调用ngx_http_finalize_connection来释放连接，而keepalive的相关判断就在这个函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_finalize_connection(ngx_http_request_t *r)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_http_core_loc_conf_t *clcf;</span><br><span class="line"></span><br><span class="line">clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">  </span><br><span class="line">//可以看到如果设置了keepalive，并且timeout大于0，就进入keepalive的处理。</span><br><span class="line">      </span><br><span class="line">if (!ngx_terminate</span><br><span class="line">           </span><br><span class="line">&amp;&amp; !ngx_exiting</span><br><span class="line">           </span><br><span class="line">&amp;&amp; r-&gt;keepalive</span><br><span class="line">           </span><br><span class="line">&amp;&amp; clcf-&gt;keepalive_timeout &gt; 0)</span><br><span class="line">      </span><br><span class="line">&#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_set_keepalive(r);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125; else if (r-&gt;lingering_close &amp;&amp; clcf-&gt;lingering_timeout &gt; 0) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_set_lingering_close(r);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_http_close_request(r, 0);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面我们能看到keepalive是通过ngx_http_set_keepalive来进行设置的，接下来我们就来详细的看这个函数。</p>
<p>在这个函数里面会顺带处理pipeline的请求，因此我们一并来看，首先nginx是如何区分pipeline请求的呢，它会假设如果从客户端读取的数据多包含了一些数据，也就是解析完当前的request之后，还有一部分数据，这时，就认为是pipeline请求。</p>
<p>还有一个很重要的地方就是http_connection,我们在前面的blog知道，如果需要alloc large header时候，会先从hc-&gt;free里面取，如果没有的话，会新建，然后交给hc-&gt;busy去管理。而这个buf，就会在这里被重用,因为large buf的话，需要重新alloc第二次，如果这里buf有重用的话，减少一次分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">hc = r-&gt;http_connection;</span><br><span class="line">      </span><br><span class="line">b = r-&gt;header_in;</span><br><span class="line">  </span><br><span class="line">//一般情况下，当解析完header_in之后，pos会设置为last。也就是读取到的数据刚好是一个完整的http请求.当pos小于last，则说明可能是一个pipeline请求。</span><br><span class="line">      </span><br><span class="line">if (b-&gt;pos &lt; b-&gt;last) &#123;</span><br><span class="line"></span><br><span class="line">/\* the pipelined request \*/</span><br><span class="line"></span><br><span class="line">if (b != c-&gt;buffer) &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">               </span><br><span class="line">* If the large header buffers were allocated while the previous</span><br><span class="line">               </span><br><span class="line">* request processing then we do not use c-&gt;buffer for</span><br><span class="line">               </span><br><span class="line">* the pipelined request (see ngx_http_init_request()).</span><br><span class="line">               </span><br><span class="line">*</span><br><span class="line">               </span><br><span class="line">* Now we would move the large header buffers to the free list.</span><br><span class="line">               </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);</span><br><span class="line">  </span><br><span class="line">//如果free为空，则新建</span><br><span class="line">              </span><br><span class="line">if (hc-&gt;free == NULL) &#123;</span><br><span class="line">  </span><br><span class="line">//可以看到是large_client_headers的个数</span><br><span class="line">                  </span><br><span class="line">hc-&gt;free = ngx_palloc(c-&gt;pool,</span><br><span class="line">                    </span><br><span class="line">cscf-&gt;large_client_header_buffers.num \* sizeof(ngx_buf_t \*));</span><br><span class="line"></span><br><span class="line">if (hc-&gt;free == NULL) &#123;</span><br><span class="line">                      </span><br><span class="line">ngx_http_close_request(r, 0);</span><br><span class="line">                      </span><br><span class="line">return;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//然后清理当前的request的busy</span><br><span class="line">              </span><br><span class="line">for (i = 0; i &lt; hc-&gt;nbusy &amp;#8211; 1; i++) &#123;</span><br><span class="line">                  </span><br><span class="line">f = hc-&gt;busy[i];</span><br><span class="line">                  </span><br><span class="line">hc-&gt;free[hc-&gt;nfree++] = f;</span><br><span class="line">                  </span><br><span class="line">f-&gt;pos = f-&gt;start;</span><br><span class="line">                  </span><br><span class="line">f-&gt;last = f-&gt;start;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//保存当前的header_in buf,以便与下次给free使用。</span><br><span class="line">              </span><br><span class="line">hc-&gt;busy[0] = b;</span><br><span class="line">              </span><br><span class="line">hc-&gt;nbusy = 1;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后接下来这部分就是free request，并设置keepalive 定时器.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">r-&gt;keepalive = 0;</span><br><span class="line"></span><br><span class="line">ngx_http_free_request(r, 0);</span><br><span class="line"></span><br><span class="line">c-&gt;data = hc;</span><br><span class="line">  </span><br><span class="line">//设置定时器</span><br><span class="line">      </span><br><span class="line">ngx_add_timer(rev, clcf-&gt;keepalive_timeout);</span><br><span class="line">  </span><br><span class="line">//然后设置可读事件</span><br><span class="line">      </span><br><span class="line">if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_close_connection(c);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wev = c-&gt;write;</span><br><span class="line">      </span><br><span class="line">wev-&gt;handler = ngx_http_empty_handler;</span><br></pre></td></tr></table></figure>
<p>然后接下来这部分就是对pipeline的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (b-&gt;pos &lt; b-&gt;last) &#123;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, &quot;pipelined request&quot;);</span><br><span class="line"></span><br><span class="line">#if (NGX_STAT_STUB)</span><br><span class="line">          </span><br><span class="line">(void) ngx_atomic_fetch_add(ngx_stat_reading, 1);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">//设置标记。</span><br><span class="line">          </span><br><span class="line">hc-&gt;pipeline = 1;</span><br><span class="line">          </span><br><span class="line">c-&gt;log-&gt;action = &quot;reading client pipelined request line&quot;;</span><br><span class="line">  </span><br><span class="line">//然后扔进post queue，继续进行处理.</span><br><span class="line">          </span><br><span class="line">rev-&gt;handler = ngx_http_init_request;</span><br><span class="line">          </span><br><span class="line">ngx_post_event(rev, &amp;ngx_posted_events);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到达下面，则说明不是pipeline的请求，因此就开始对request， http_connection 进行清理工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (ngx_pfree(c-&gt;pool, r) == NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">hc-&gt;request = NULL;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = c-&gt;buffer;</span><br><span class="line"></span><br><span class="line">if (ngx_pfree(c-&gt;pool, b-&gt;start) == NGX_OK) &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">           </span><br><span class="line">* the special note for ngx_http_keepalive_handler() that</span><br><span class="line">           </span><br><span class="line">* c-&gt;buffer&amp;#8217;s memory was freed</span><br><span class="line">           </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">b-&gt;pos = NULL;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">          </span><br><span class="line">b-&gt;pos = b-&gt;start;</span><br><span class="line">          </span><br><span class="line">b-&gt;last = b-&gt;start;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line"></span><br><span class="line">if (hc-&gt;busy) &#123;</span><br><span class="line">          </span><br><span class="line">for (i = 0; i &lt; hc-&gt;nbusy; i++) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_pfree(c-&gt;pool, hc-&gt;busy[i]-&gt;start);</span><br><span class="line">              </span><br><span class="line">hc-&gt;busy[i] = NULL;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hc-&gt;nbusy = 0;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置keepalive的handler。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//后面会详细分析这个函数</span><br><span class="line">      </span><br><span class="line">rev-&gt;handler = ngx_http_keepalive_handler;</span><br><span class="line"></span><br><span class="line">if (wev-&gt;active &amp;&amp; (ngx_event_flags &amp; NGX_USE_LEVEL_EVENT)) &#123;</span><br><span class="line">          </span><br><span class="line">if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_close_connection(c);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是对tcp push的处理，这里暂时我就不介绍了，接下来我会有专门一篇blog来介绍nginx对tcp push的操作。</p>
<p>然后我们来看ngx_http_keepalive_handler函数，这个函数是处理keepalive连接，当在连接上再次有可读的事件的时候，就会调用这个handler。</p>
<p>这个handler比较简单，就是创建新的buf，然后重新开始一个http request的执行(调用ngx_http_init_request)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">b = c-&gt;buffer;</span><br><span class="line">      </span><br><span class="line">size = b-&gt;end &amp;#8211; b-&gt;start;</span><br><span class="line"></span><br><span class="line">if (b-&gt;pos == NULL) &#123;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">           </span><br><span class="line">* The c-&gt;buffer&amp;#8217;s memory was freed by ngx_http_set_keepalive().</span><br><span class="line">           </span><br><span class="line">* However, the c-&gt;buffer-&gt;start and c-&gt;buffer-&gt;end were not changed</span><br><span class="line">           </span><br><span class="line">* to keep the buffer size.</span><br><span class="line">           </span><br><span class="line">*/</span><br><span class="line">  </span><br><span class="line">//重新分配buf</span><br><span class="line">          </span><br><span class="line">b-&gt;pos = ngx_palloc(c-&gt;pool, size);</span><br><span class="line">          </span><br><span class="line">if (b-&gt;pos == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_close_connection(c);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b-&gt;start = b-&gt;pos;</span><br><span class="line">          </span><br><span class="line">b-&gt;last = b-&gt;pos;</span><br><span class="line">          </span><br><span class="line">b-&gt;end = b-&gt;pos + size;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后尝试读取数据，如果没有可读数据，则会将句柄再次加入可读事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">n = c-&gt;recv(c, b-&gt;last, size);</span><br><span class="line">      </span><br><span class="line">c-&gt;log_error = NGX_ERROR_INFO;</span><br><span class="line">      </span><br><span class="line">if (n == NGX_AGAIN) &#123;</span><br><span class="line">          </span><br><span class="line">if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_close_connection(c);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后如果读取了数据，则进入request的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">ngx_http_init_request(rev);</span><br></pre></td></tr></table></figure>
<p>最后我们再来看ngx_http_init_request函数，这次主要来看当时pipeline请求的时候，nginx是如何来重用request的。</p>
<p>这里要注意hc-&gt;busy[0],前面我们知道，如果是pipeline请求，我们会保存前面没有解析完毕的request header_in，这是因为我们可能已经读取了pipeline请求的第二个请求的一些头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//取得request，这里我们知道，在pipeline请求中，我们会保存前一个request.</span><br><span class="line">      </span><br><span class="line">r = hc-&gt;request;</span><br><span class="line"></span><br><span class="line">if (r) &#123;</span><br><span class="line">  </span><br><span class="line">//如果存在，则我们重用前一个request.</span><br><span class="line">          </span><br><span class="line">ngx_memzero(r, sizeof(ngx_http_request_t));</span><br><span class="line"></span><br><span class="line">r-&gt;pipeline = hc-&gt;pipeline;</span><br><span class="line">  </span><br><span class="line">//如果nbusy存在</span><br><span class="line">          </span><br><span class="line">if (hc-&gt;nbusy) &#123;</span><br><span class="line">  </span><br><span class="line">//则保存这个header_in，然后下面直接解析。</span><br><span class="line">              </span><br><span class="line">r-&gt;header_in = hc-&gt;busy[0];</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">          </span><br><span class="line">r = ngx_pcalloc(c-&gt;pool, sizeof(ngx_http_request_t));</span><br><span class="line">          </span><br><span class="line">if (r == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_close_connection(c);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hc-&gt;request = r;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//保存请求</span><br><span class="line">      </span><br><span class="line">c-&gt;data = r;</span><br></pre></td></tr></table></figure>
<p>从上面的代码，然后再结合我前一篇blog，我们就知道large header主要是针对pipeline的了，因为在pipeline中，前一个request如果多读了下一个request的一些头的话，这样子下次解析的时候就有可能会超过本来分配的client_header_buffer_size，此时，我们就需要重新分配一个header，也就是large header了，所以这里httpconnection主要就是针对pipeline的情况，而keepalive的连接并不是pipeline的请求的话，为了节省内存，就把前一个request释放掉了.</p>
</div><div class="tags"><a href="/tags/nginx/">nginx</a><a href="/tags/http/">http</a><a href="/tags/keepalive/">keepalive</a><a href="/tags/pipeline/">pipeline</a></div><div class="post-nav"><a class="pre" href="/2011/02/23/application-of-nginx-to-tcp_cork/tcp_nopush.html">nginx对TCP_CORK/TCP_NOPUSH的使用</a><a class="next" href="/2011/02/09/design-and-implementation-of-request-buf-in-nginx.html">nginx中request buf的设计和实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>