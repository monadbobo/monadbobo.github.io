<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>linux kernel中epoll的设计和实现 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux kernel中epoll的设计和实现</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux kernel中epoll的设计和实现</h1><div class="post-meta">Apr 20, 2011<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a><a href="/categories/kernel/server/">server</a></span></div><div class="post-content"><p>这里就不贴源码了，源码分析的话，网上一大堆，我这里只是简要的描述下epoll的实现和一些关键的代码片段。</p>
<p>相关的文件在 fs/eventpoll.c中,我看的是2.6.38的内核代码.</p>
<p>1 epoll在创建的时候会调用anon_inode_getfd新建一个file instance，也就是epoll可以看成一个文件。因此我们可以看到epoll_create会返回一个fd.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">error = anon_inode_getfd(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep,</span><br><span class="line">				   </span><br><span class="line">O_RDWR | (flags &amp; O_CLOEXEC));</span><br></pre></td></tr></table></figure>
<p>2 epoll所管理的所有的句柄都是放在一个大的结构eventpoll(红黑树)中,而这个结构是保存在file 的private_data域中的(因为epoll本身就是一个文件).这样每次通过epoll fd就可以直接得到eventpoll.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">file = fget(epfd);</span><br><span class="line">	  </span><br><span class="line">/\* Get the &quot;struct file \*&quot; for the target file */</span><br><span class="line">	  </span><br><span class="line">tfile = fget(fd);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">	  </span><br><span class="line">ep = file-&gt;private_data;</span><br></pre></td></tr></table></figure>
<p>3 每一个加入到epoll监听的句柄(也就是红黑树的一个节点)都是一个epitem.它包含了一个 struct eventpoll *ep，也就是它所属于的eventpoll(epoll实例).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">		  </span><br><span class="line">return -ENOMEM;</span><br><span class="line"></span><br><span class="line">/\* Item initialization follow here &amp;#8230; \*/</span><br><span class="line">	  </span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">	  </span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">	  </span><br><span class="line">INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">	  </span><br><span class="line">epi-&gt;ep = ep;</span><br><span class="line">	  </span><br><span class="line">ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">	  </span><br><span class="line">epi-&gt;event = *event;</span><br><span class="line">	  </span><br><span class="line">epi-&gt;nwait = 0;</span><br><span class="line">	  </span><br><span class="line">epi-&gt;next = EP_UNACTIVE_PTR;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>4 在eventpoll中包含两个wait queue，一个是被epoll_wait使用的(wq)，一个是被file-&gt;poll使用的(poll_wait).这两个都是属于eventpoll.而在epitem也有一个wait queue(pwqlist)，这个queue是fd私有的wait queue，所以它是保存在epitem中的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct epitem &#123;</span><br><span class="line">	  </span><br><span class="line">/\* RB tree node used to link this structure to the eventpoll RB tree \*/</span><br><span class="line">	  </span><br><span class="line">struct rb_node rbn;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">	  </span><br><span class="line">/\* List containing poll wait queues \*/</span><br><span class="line">	  </span><br><span class="line">struct list_head pwqlist;</span><br><span class="line"></span><br><span class="line">/\* The &quot;container&quot; of this item \*/</span><br><span class="line">	  </span><br><span class="line">struct eventpoll *ep;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct eventpoll &#123;</span><br><span class="line">	  </span><br><span class="line">/\* Protect the this structure access \*/</span><br><span class="line">	  </span><br><span class="line">spinlock_t lock;</span><br><span class="line">	  </span><br><span class="line">/*</span><br><span class="line">	   </span><br><span class="line">* This mutex is used to ensure that files are not removed</span><br><span class="line">	   </span><br><span class="line">* while epoll is using them. This is held during the event</span><br><span class="line">	   </span><br><span class="line">* collection loop, the file cleanup path, the epoll file exit</span><br><span class="line">	   </span><br><span class="line">* code and the ctl operations.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">struct mutex mtx;</span><br><span class="line"></span><br><span class="line">/\* Wait queue used by sys_epoll_wait() \*/</span><br><span class="line">	  </span><br><span class="line">wait_queue_head_t wq;</span><br><span class="line"></span><br><span class="line">/\* Wait queue used by file-&gt;poll() \*/</span><br><span class="line">	  </span><br><span class="line">wait_queue_head_t poll_wait;</span><br><span class="line"></span><br><span class="line">/\* List of ready file descriptors \*/</span><br><span class="line">	  </span><br><span class="line">struct list_head rdllist;</span><br><span class="line"></span><br><span class="line">/\* RB tree root used to store monitored fd structs \*/</span><br><span class="line">	  </span><br><span class="line">struct rb_root rbr;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	   </span><br><span class="line">* This is a single linked list that chains all the &quot;struct epitem&quot; that</span><br><span class="line">	   </span><br><span class="line">* happened while transfering ready events to userspace w/out</span><br><span class="line">	   </span><br><span class="line">* holding -&gt;lock.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">struct epitem *ovflist;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>5 当我们添加一个句柄到一个epoll fd的时候，默认是会包含POLLERR和POLLHUP事件.并将epitem插入到红黑树中(eventpoll).然后会初始化一个poll_table,然后设置它的回调函数为ep_poll_callback，紧接着调用file-&gt;poll,如果是socket，则会调用tcp_poll,这个函数将会调用ep_poll_callback.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">switch (op) &#123;</span><br><span class="line">	  </span><br><span class="line">case EPOLL_CTL_ADD:</span><br><span class="line">		  </span><br><span class="line">if (!epi) &#123;</span><br><span class="line">			  </span><br><span class="line">epds.events |= POLLERR | POLLHUP;</span><br><span class="line">			  </span><br><span class="line">error = ep_insert(ep, &amp;epds, tfile, fd);</span><br><span class="line">		  </span><br><span class="line">&#125; else</span><br><span class="line">			  </span><br><span class="line">error = -EEXIST;</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br></pre></td></tr></table></figure>
<p>6 ep_poll_callback这个函数主要是绑定epitem的wait queue的回调为ep_poll_callback.也就是对应fd如果有事件，则就会调用ep_poll_callback。</p>
<p>7 epoll中保存了一个read list(rdllist)，所有的已经有通知事件的句柄，都会放到这个list中，而对应的操作就是在ep_poll_callback中，在ep_poll_callback中主要就是由wait queue指针来取得对应的epitem，然后再取得eventpoll，并将这个epitem加入到ready list，唤醒epoll_wait(wq).这里可以看到由于一个句柄只会对应一个epitem，所以在rdllist中，也不会有重复的epitem，在ep_poll_callback会判断是否rdllist中是否已经包含了将要插入的epitem，如果包含，则直接返回.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int ep_poll_callback(wait_queue_t \*wait, unsigned mode, int sync, void \*key)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct epitem *epi = ep_item_from_wait(wait);</span><br><span class="line">	  </span><br><span class="line">struct eventpoll *ep = epi-&gt;ep;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">	  </span><br><span class="line">/\* If this file is already in the ready list we exit soon \*/</span><br><span class="line">	  </span><br><span class="line">if (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">		  </span><br><span class="line">list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br></pre></td></tr></table></figure>
<p>8 当系统调用epoll_wait,如果ready list(rdllist)为空，则休眠等待被唤醒。当被唤醒之后(第7条),将rdllist复制(指针)到一个新的list(主要是针对LT),然后调用ep_send_events_proc对这个新的list进行遍历(对应的会从rdllist中删除这个epitem).遍历完毕后，最终会返回给用户对应的数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">if (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">		  </span><br><span class="line">/*</span><br><span class="line">		   </span><br><span class="line">* We don&amp;#8217;t have any available event to return to the caller.</span><br><span class="line">		   </span><br><span class="line">* We need to sleep here, and we will be wake up by</span><br><span class="line">		   </span><br><span class="line">* ep_poll_callback() when events will become available.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">init_waitqueue_entry(&amp;wait, current);</span><br><span class="line">		  </span><br><span class="line">__add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">			  </span><br><span class="line">/*</span><br><span class="line">			   </span><br><span class="line">* We don&amp;#8217;t want to sleep if the ep_poll_callback() sends us</span><br><span class="line">			   </span><br><span class="line">* a wakeup in between. That&amp;#8217;s why we set the task state</span><br><span class="line">			   </span><br><span class="line">* to TASK_INTERRUPTIBLE before doing the checks.</span><br><span class="line">			   </span><br><span class="line">*/</span><br><span class="line">			  </span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">			  </span><br><span class="line">if (!list_empty(&amp;ep-&gt;rdllist) || timed_out)</span><br><span class="line">				  </span><br><span class="line">break;</span><br><span class="line">			  </span><br><span class="line">if (signal_pending(current)) &#123;</span><br><span class="line">				  </span><br><span class="line">res = -EINTR;</span><br><span class="line">				  </span><br><span class="line">break;</span><br><span class="line">			  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">			  </span><br><span class="line">if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))</span><br><span class="line">				  </span><br><span class="line">timed_out = 1;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">		  </span><br><span class="line">__remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">set_current_state(TASK_RUNNING);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9 LT和ET的区别是在ep_send_events_proc中处理的，如果是LT，不但会将对应的数据返回给用户，并且会将当前的epitem再次加入到rdllist中。这样子，如果下次再次被唤醒就会给用户空间再次返回事件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int ep_send_events_proc(struct eventpoll \*ep, struct list_head \*head,</span><br><span class="line">			         </span><br><span class="line">void *priv)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">			  </span><br><span class="line">if (__put_user(revents, &amp;uevent-&gt;events) ||</span><br><span class="line">			      </span><br><span class="line">__put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;</span><br><span class="line">				  </span><br><span class="line">list_add(&amp;epi-&gt;rdllink, head);</span><br><span class="line">				  </span><br><span class="line">return eventcnt ? eventcnt : -EFAULT;</span><br><span class="line">			  </span><br><span class="line">&#125;</span><br><span class="line">			  </span><br><span class="line">eventcnt++;</span><br><span class="line">			  </span><br><span class="line">uevent++;</span><br><span class="line">			  </span><br><span class="line">if (epi-&gt;event.events &amp; EPOLLONESHOT)</span><br><span class="line">				  </span><br><span class="line">epi-&gt;event.events &amp;= EP_PRIVATE_BITS;</span><br><span class="line">			  </span><br><span class="line">else if (!(epi-&gt;event.events &amp; EPOLLET)) &#123;</span><br><span class="line">				  </span><br><span class="line">/*</span><br><span class="line">				   </span><br><span class="line">* If this file has been added with Level</span><br><span class="line">				   </span><br><span class="line">* Trigger mode, we need to insert back inside</span><br><span class="line">				   </span><br><span class="line">* the ready list, so that the next call to</span><br><span class="line">				   </span><br><span class="line">* epoll_wait() will check again the events</span><br><span class="line">				   </span><br><span class="line">* availability. At this point, noone can insert</span><br><span class="line">				   </span><br><span class="line">* into ep-&gt;rdllist besides us. The epoll_ctl()</span><br><span class="line">				   </span><br><span class="line">* callers are locked out by</span><br><span class="line">				   </span><br><span class="line">* ep_scan_ready_list() holding &quot;mtx&quot; and the</span><br><span class="line">				   </span><br><span class="line">* poll callback will queue them in ep-&gt;ovflist.</span><br><span class="line">				   </span><br><span class="line">*/</span><br><span class="line">				  </span><br><span class="line">list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">			  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>10 eventpol还有一个list，叫做ovflist，主要是解决当内核在传输数据给用户空间(ep_send_events_proc)时的锁(eventpoll-&gt;mtx)，此时epoll就是将这个时候传递上来的事件保存到ovflist中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int ep_poll_callback(wait_queue_t \*wait, unsigned mode, int sync, void \*key)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">	  </span><br><span class="line">/*</span><br><span class="line">	   </span><br><span class="line">* If we are trasfering events to userspace, we can hold no locks</span><br><span class="line">	   </span><br><span class="line">* (because we&amp;#8217;re accessing user memory, and because of linux f_op-&gt;poll()</span><br><span class="line">	   </span><br><span class="line">* semantics). All the events that happens during that period of time are</span><br><span class="line">	   </span><br><span class="line">* chained in ep-&gt;ovflist and requeued later on.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">if (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">		  </span><br><span class="line">if (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">			  </span><br><span class="line">epi-&gt;next = ep-&gt;ovflist;</span><br><span class="line">			  </span><br><span class="line">ep-&gt;ovflist = epi;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">		  </span><br><span class="line">goto out_unlock;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11 当从ep_send_events_proc返回(ep_scan_ready_list)后，会遍历ovflist，然后将ready的epitem保存到rdllist,以便与下次再次被唤醒时进行操作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int ep_scan_ready_list(struct eventpoll *ep,</span><br><span class="line">			        </span><br><span class="line">int (\*sproc)(struct eventpoll \*,</span><br><span class="line">					     </span><br><span class="line">struct list_head \*, void \*),</span><br><span class="line">			        </span><br><span class="line">void *priv)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">	  </span><br><span class="line">/*</span><br><span class="line">	   </span><br><span class="line">* During the time we spent inside the &quot;sproc&quot; callback, some</span><br><span class="line">	   </span><br><span class="line">* other events might have been queued by the poll callback.</span><br><span class="line">	   </span><br><span class="line">* We re-insert them inside the main ready-list here.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">for (nepi = ep-&gt;ovflist; (epi = nepi) != NULL;</span><br><span class="line">	       </span><br><span class="line">nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;</span><br><span class="line">		  </span><br><span class="line">/*</span><br><span class="line">		   </span><br><span class="line">* We need to check if the item is already in the list.</span><br><span class="line">		   </span><br><span class="line">* During the &quot;sproc&quot; callback execution time, items are</span><br><span class="line">		   </span><br><span class="line">* queued into -&gt;ovflist but the &quot;txlist&quot; might already</span><br><span class="line">		   </span><br><span class="line">* contain them, and the list_splice() below takes care of them.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">if (!ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">			  </span><br><span class="line">list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/epoll/">epoll</a></div><div class="post-nav"><a class="pre" href="/2011/04/27/design-and-implementation-of-upstream-in-nginx-(3).html">nginx中upstream的设计和实现(三)</a><a class="next" href="/2011/04/14/design-and-implementation-of-upstream-in-nginx-(2).html">nginx中upstream的设计和实现(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>