<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nginx中upstream的设计和实现(二) | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nginx中upstream的设计和实现(二)</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">nginx中upstream的设计和实现(二)</h1><div class="post-meta">Apr 14, 2011<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a><a href="/categories/nginx/server/">server</a></span></div><div class="post-content"><p>这次主要来看upstream的几个相关的hook函数。</p>
<p>首先要知道，对于upstream，同时有两个连接，一个时client和nginx，一个是nginx和upstream，这个时候就会有两个回调，然后上篇blog中，我们能看到在upstream中，会改变read_event_handler和write_event_handler,不过这里有三个条件，分别是</p>
<p>1 没有使用cache，</p>
<p>2 不忽略client的提前终止</p>
<p>3 不是post_action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//条件赋值</span><br><span class="line">      </span><br><span class="line">if (!u-&gt;store &amp;&amp; !r-&gt;post_action &amp;&amp; !u-&gt;conf-&gt;ignore_client_abort) &#123;</span><br><span class="line">  </span><br><span class="line">//然后给读写handler赋值</span><br><span class="line">          </span><br><span class="line">r-&gt;read_event_handler = ngx_http_upstream_rd_check_broken_connection;</span><br><span class="line">          </span><br><span class="line">r-&gt;write_event_handler = ngx_http_upstream_wr_check_broken_connection;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后我们来看这个两个函数，这两个都会调用ngx_http_upstream_check_broken_connection，因此我们就先来详细分析这个函数。</p>
<p>这个函数主要是用来检测client的连接是否完好。因此它使用了MSG_PEEK这个参数，也就是预读，然后通过recv的返回值来判断是否连接已经断开。</p>
<p>这里的代码分为两部分，第一部分是本身连接在进入这个回调函数之前连接都已经有错误了，这个时候如果是水平触发，则删除事件，然后finalize这个upstream(没有cache&#8217;的情况下），否则就直接finalize这个upstream。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">c = r-&gt;connection;</span><br><span class="line">      </span><br><span class="line">u = r-&gt;upstream;</span><br><span class="line">  </span><br><span class="line">//如果连接已经出现错误。</span><br><span class="line">      </span><br><span class="line">if (c-&gt;error) &#123;</span><br><span class="line">  </span><br><span class="line">//如果是水平触发</span><br><span class="line">          </span><br><span class="line">if ((ngx_event_flags &amp; NGX_USE_LEVEL_EVENT) &amp;&amp; ev-&gt;active) &#123;</span><br><span class="line"></span><br><span class="line">event = ev-&gt;write ? NGX_WRITE_EVENT : NGX_READ_EVENT;</span><br><span class="line">  </span><br><span class="line">//删除事件</span><br><span class="line">              </span><br><span class="line">if (ngx_del_event(ev, event, 0) != NGX_OK) &#123;</span><br><span class="line">                  </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">                  </span><br><span class="line">return;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!u-&gt;cacheable) &#123;</span><br><span class="line">  </span><br><span class="line">//清理upstream　request</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_CLIENT_CLOSED_REQUEST);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着就是第二部分，这部分的工作就是预读取１个字节，然后来判断是否连接已经被client断掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//读取１个字节</span><br><span class="line">      </span><br><span class="line">n = recv(c-&gt;fd, buf, 1, MSG_PEEK);</span><br><span class="line"></span><br><span class="line">err = ngx_socket_errno;</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_HTTP, ev-&gt;log, err,</span><br><span class="line">                     </span><br><span class="line">&quot;http upstream recv(): %d&quot;, n);</span><br><span class="line"></span><br><span class="line">if (ev-&gt;write &amp;&amp; (n &gt;= 0 || err == NGX_EAGAIN)) &#123;</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果水平触发则删除事件</span><br><span class="line">      </span><br><span class="line">if ((ngx_event_flags &amp; NGX_USE_LEVEL_EVENT) &amp;&amp; ev-&gt;active) &#123;</span><br><span class="line"></span><br><span class="line">event = ev-&gt;write ? NGX_WRITE_EVENT : NGX_READ_EVENT;</span><br><span class="line"></span><br><span class="line">if (ngx_del_event(ev, event, 0) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果还有数据，则直接返回</span><br><span class="line">      </span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (n == -1) &#123;</span><br><span class="line">          </span><br><span class="line">if (err == NGX_EAGAIN) &#123;</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ev-&gt;error = 1;</span><br><span class="line"></span><br><span class="line">&#125; else &#123; /\* n == 0 \*/</span><br><span class="line">          </span><br><span class="line">err = 0;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//到达这里说明有错误产生了</span><br><span class="line">      </span><br><span class="line">ev-&gt;eof = 1;</span><br><span class="line">  </span><br><span class="line">//设置错误，可以看到这个值在函数一开始有检测.</span><br><span class="line">      </span><br><span class="line">c-&gt;error = 1;</span><br><span class="line">  </span><br><span class="line">//如果没有cache，则finalize　upstream request</span><br><span class="line">      </span><br><span class="line">if (!u-&gt;cacheable &amp;&amp; u-&gt;peer.connection) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_log_error(NGX_LOG_INFO, ev-&gt;log, err,</span><br><span class="line">                        </span><br><span class="line">&quot;client closed prematurely connection, &quot;</span><br><span class="line">                        </span><br><span class="line">&quot;so upstream connection is closed too&quot;);</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                             </span><br><span class="line">NGX_HTTP_CLIENT_CLOSED_REQUEST);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_log_error(NGX_LOG_INFO, ev-&gt;log, err,</span><br><span class="line">                    </span><br><span class="line">&quot;client closed prematurely connection&quot;);</span><br><span class="line">  </span><br><span class="line">//如果有cache，并且后端的upstream还在处理，则此时继续处理upstream，忽略对端的错误.</span><br><span class="line">      </span><br><span class="line">if (u-&gt;peer.connection == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                             </span><br><span class="line">NGX_HTTP_CLIENT_CLOSED_REQUEST);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来看nginx如何连接后端的upstream，在上篇blog的结束的时候，我们看到最终会调用ngx_http_upstream_connect来进入连接upstream的处理，因此我们来详细分析这个函数以及相关的函数。</p>
<p>函数一开始是初始化请求开始事件一些参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">//取得upstream的状态</span><br><span class="line">      </span><br><span class="line">u-&gt;state = ngx_array_push(r-&gt;upstream_states);</span><br><span class="line">      </span><br><span class="line">if (u-&gt;state == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                             </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_memzero(u-&gt;state, sizeof(ngx_http_upstream_state_t));</span><br><span class="line"></span><br><span class="line">tp = ngx_timeofday();</span><br><span class="line">  </span><br><span class="line">//初始化时间</span><br><span class="line">      </span><br><span class="line">u-&gt;state-&gt;response_sec = tp-&gt;sec;</span><br><span class="line">      </span><br><span class="line">u-&gt;state-&gt;response_msec = tp-&gt;msec;</span><br></pre></td></tr></table></figure>
<p>然后是调用ngx_event_connect_peer开始连接后端upstream.并且对返回值进行处理，等下会详细分析ngx_event_connect_peer这个函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//连接后端</span><br><span class="line">      </span><br><span class="line">rc = ngx_event_connect_peer(&amp;u-&gt;peer);</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,</span><br><span class="line">                     </span><br><span class="line">&quot;http upstream connect: %i&quot;, rc);</span><br><span class="line"></span><br><span class="line">if (rc == NGX_ERROR) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                             </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//这个是很关键的一个结构peer，后面的blog会详细分析</span><br><span class="line">      </span><br><span class="line">u-&gt;state-&gt;peer = u-&gt;peer.name;</span><br><span class="line"></span><br><span class="line">if (rc == NGX_BUSY) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, &quot;no live upstreams&quot;);</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_NOLIVE);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (rc == NGX_DECLINED) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当返回值为NGX_OK或者NGX_AGAIN的话，就说明连接成功或者暂时异步的连接还没成功，所以需要挂载upstream端的回调函数.这里要注意就是NGX_AGAIN的情况，因为是异步的connect，所以可能会连接不成功。所以如果返回NGX_AGAIN的话，需要挂载写函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">/\* rc == NGX_OK || rc == NGX_AGAIN \*/</span><br><span class="line"></span><br><span class="line">c = u-&gt;peer.connection;</span><br><span class="line"></span><br><span class="line">c-&gt;data = r;</span><br><span class="line"></span><br><span class="line">c-&gt;write-&gt;handler = ngx_http_upstream_handler;</span><br><span class="line">      </span><br><span class="line">c-&gt;read-&gt;handler = ngx_http_upstream_handler;</span><br><span class="line">  </span><br><span class="line">//开始挂载回调函数，一个是读，一个是写。</span><br><span class="line">      </span><br><span class="line">u-&gt;write_event_handler = ngx_http_upstream_send_request_handler;</span><br><span class="line">      </span><br><span class="line">u-&gt;read_event_handler = ngx_http_upstream_process_header;</span><br><span class="line"></span><br><span class="line">c-&gt;sendfile &amp;= r-&gt;connection-&gt;sendfile;</span><br><span class="line">      </span><br><span class="line">u-&gt;output.sendfile = c-&gt;sendfile;</span><br><span class="line"></span><br><span class="line">c-&gt;pool = r-&gt;pool;</span><br><span class="line">      </span><br><span class="line">c-&gt;log = r-&gt;connection-&gt;log;</span><br><span class="line">      </span><br><span class="line">c-&gt;read-&gt;log = c-&gt;log;</span><br><span class="line">      </span><br><span class="line">c-&gt;write-&gt;log = c-&gt;log;</span><br><span class="line"></span><br><span class="line">/\* init or reinit the ngx_output_chain() and ngx_chain_writer() contexts \*/</span><br><span class="line"></span><br><span class="line">u-&gt;writer.out = NULL;</span><br><span class="line">      </span><br><span class="line">u-&gt;writer.last = &amp;u-&gt;writer.out;</span><br><span class="line">      </span><br><span class="line">u-&gt;writer.connection = c;</span><br><span class="line">      </span><br><span class="line">u-&gt;writer.limit = 0;</span><br></pre></td></tr></table></figure>
<p>然后时对request_body的一些处理以及如果request_sent已经设置，也就是这个upstream已经发送过一部分数据了，此时需要重新初始化upstream.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (u-&gt;request_sent) &#123;</span><br><span class="line">  </span><br><span class="line">//重新初始化upstream</span><br><span class="line">          </span><br><span class="line">if (ngx_http_upstream_reinit(r, u) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果request_body存在的话，保存request_body</span><br><span class="line">      </span><br><span class="line">if (r-&gt;request_body</span><br><span class="line">          </span><br><span class="line">&amp;&amp; r-&gt;request_body-&gt;buf</span><br><span class="line">          </span><br><span class="line">&amp;&amp; r-&gt;request_body-&gt;temp_file</span><br><span class="line">          </span><br><span class="line">&amp;&amp; r == r-&gt;main)</span><br><span class="line">      </span><br><span class="line">&#123;</span><br><span class="line">          </span><br><span class="line">/*</span><br><span class="line">           </span><br><span class="line">* the r-&gt;request_body-&gt;buf can be reused for one request only,</span><br><span class="line">           </span><br><span class="line">* the subrequests should allocate their own temporay bufs</span><br><span class="line">           </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">u-&gt;output.free = ngx_alloc_chain_link(r-&gt;pool);</span><br><span class="line">          </span><br><span class="line">if (u-&gt;output.free == NULL) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//保存到output</span><br><span class="line">          </span><br><span class="line">u-&gt;output.free-&gt;buf = r-&gt;request_body-&gt;buf;</span><br><span class="line">          </span><br><span class="line">u-&gt;output.free-&gt;next = NULL;</span><br><span class="line">          </span><br><span class="line">u-&gt;output.allocated = 1;</span><br><span class="line">  </span><br><span class="line">//重置request_body</span><br><span class="line">          </span><br><span class="line">r-&gt;request_body-&gt;buf-&gt;pos = r-&gt;request_body-&gt;buf-&gt;start;</span><br><span class="line">          </span><br><span class="line">r-&gt;request_body-&gt;buf-&gt;last = r-&gt;request_body-&gt;buf-&gt;start;</span><br><span class="line">          </span><br><span class="line">r-&gt;request_body-&gt;buf-&gt;tag = u-&gt;output.tag;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后则是先判断rc的返回值，如果是NGX_AGAIN,则说明连接没有返回，则设置定时器，然后返回，否则说明连接成功，这时就需要发送请求到后端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (rc == NGX_AGAIN) &#123;</span><br><span class="line">  </span><br><span class="line">//添加定时器</span><br><span class="line">          </span><br><span class="line">ngx_add_timer(c-&gt;write, u-&gt;conf-&gt;connect_timeout);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_http_upstream_send_request(r, u);</span><br></pre></td></tr></table></figure>
<p>紧接着我们来看最后的两个函数，分别是上面的ngx_event_connect_peer和ngx_http_upstream_send_request，我们来一个个看。</p>
<p>先来看ngx_event_connect_peer。它主要是用来连接后端，函数比较长，一部分一部分来看。</p>
<p>下面这部分主要是建立socket，然后设置属性，从连接池取出来connection.这里后面的一部分和我们前面client请求上来之后，我们初始化connect类似.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//取得我们将要发送的upstream对端</span><br><span class="line">      </span><br><span class="line">rc = pc-&gt;get(pc, pc-&gt;data);</span><br><span class="line">      </span><br><span class="line">if (rc != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">return rc;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//新建socket</span><br><span class="line">      </span><br><span class="line">s = ngx_socket(pc-&gt;sockaddr-&gt;sa_family, SOCK_STREAM, 0);</span><br><span class="line"></span><br><span class="line">ngx_log_debug1(NGX_LOG_DEBUG_EVENT, pc-&gt;log, 0, &quot;socket %d&quot;, s);</span><br><span class="line"></span><br><span class="line">if (s == -1) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_log_error(NGX_LOG_ALERT, pc-&gt;log, ngx_socket_errno,</span><br><span class="line">                        </span><br><span class="line">ngx_socket_n &quot; failed&quot;);</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//取得连接</span><br><span class="line">      </span><br><span class="line">c = ngx_get_connection(s, pc-&gt;log);</span><br><span class="line"></span><br><span class="line">if (c == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">if (ngx_close_socket(s) == -1) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_log_error(NGX_LOG_ALERT, pc-&gt;log, ngx_socket_errno,</span><br><span class="line">                            </span><br><span class="line">ngx_close_socket_n &quot;failed&quot;);</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置rcvbuf的大小</span><br><span class="line">      </span><br><span class="line">if (pc-&gt;rcvbuf) &#123;</span><br><span class="line">          </span><br><span class="line">if (setsockopt(s, SOL_SOCKET, SO_RCVBUF,</span><br><span class="line">                         </span><br><span class="line">(const void *) &amp;pc-&gt;rcvbuf, sizeof(int)) == -1)</span><br><span class="line">          </span><br><span class="line">&#123;</span><br><span class="line">              </span><br><span class="line">ngx_log_error(NGX_LOG_ALERT, pc-&gt;log, ngx_socket_errno,</span><br><span class="line">                            </span><br><span class="line">&quot;setsockopt(SO_RCVBUF) failed&quot;);</span><br><span class="line">              </span><br><span class="line">goto failed;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置非阻塞</span><br><span class="line">      </span><br><span class="line">if (ngx_nonblocking(s) == -1) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_log_error(NGX_LOG_ALERT, pc-&gt;log, ngx_socket_errno,</span><br><span class="line">                        </span><br><span class="line">ngx_nonblocking_n &quot; failed&quot;);</span><br><span class="line"></span><br><span class="line">goto failed;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (pc-&gt;local) &#123;</span><br><span class="line">          </span><br><span class="line">if (bind(s, pc-&gt;local-&gt;sockaddr, pc-&gt;local-&gt;socklen) == -1) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_log_error(NGX_LOG_CRIT, pc-&gt;log, ngx_socket_errno,</span><br><span class="line">                            </span><br><span class="line">&quot;bind(%V) failed&quot;, &amp;pc-&gt;local-&gt;name);</span><br><span class="line"></span><br><span class="line">goto failed;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//开始挂载对应的读写函数.</span><br><span class="line">      </span><br><span class="line">c-&gt;recv = ngx_recv;</span><br><span class="line">      </span><br><span class="line">c-&gt;send = ngx_send;</span><br><span class="line">      </span><br><span class="line">c-&gt;recv_chain = ngx_recv_chain;</span><br><span class="line">      </span><br><span class="line">c-&gt;send_chain = ngx_send_chain;</span><br><span class="line"></span><br><span class="line">c-&gt;sendfile = 1;</span><br><span class="line"></span><br><span class="line">c-&gt;log_error = pc-&gt;log_error;</span><br><span class="line"></span><br><span class="line">if (pc-&gt;sockaddr-&gt;sa_family != AF_INET) &#123;</span><br><span class="line">          </span><br><span class="line">c-&gt;tcp_nopush = NGX_TCP_NOPUSH_DISABLED;</span><br><span class="line">          </span><br><span class="line">c-&gt;tcp_nodelay = NGX_TCP_NODELAY_DISABLED;</span><br><span class="line"></span><br><span class="line">#if (NGX_SOLARIS)</span><br><span class="line">          </span><br><span class="line">/\* Solaris&amp;#8217;s sendfilev() supports AF_NCA, AF_INET, and AF_INET6 \*/</span><br><span class="line">          </span><br><span class="line">c-&gt;sendfile = 0;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rev = c-&gt;read;</span><br><span class="line">      </span><br><span class="line">wev = c-&gt;write;</span><br><span class="line"></span><br><span class="line">rev-&gt;log = pc-&gt;log;</span><br><span class="line">      </span><br><span class="line">wev-&gt;log = pc-&gt;log;</span><br><span class="line"></span><br><span class="line">pc-&gt;connection = c;</span><br><span class="line"></span><br><span class="line">c-&gt;number = ngx_atomic_fetch_add(ngx_connection_counter, 1);</span><br><span class="line"></span><br><span class="line">#if (NGX_THREADS)</span><br><span class="line"></span><br><span class="line">/\* TODO: lock event when call completion handler \*/</span><br><span class="line"></span><br><span class="line">rev-&gt;lock = pc-&gt;lock;</span><br><span class="line">      </span><br><span class="line">wev-&gt;lock = pc-&gt;lock;</span><br><span class="line">      </span><br><span class="line">rev-&gt;own_lock = &amp;c-&gt;lock;</span><br><span class="line">      </span><br><span class="line">wev-&gt;own_lock = &amp;c-&gt;lock;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">if (ngx_add_conn) &#123;</span><br><span class="line">  </span><br><span class="line">//添加读写事件</span><br><span class="line">          </span><br><span class="line">if (ngx_add_conn(c) == NGX_ERROR) &#123;</span><br><span class="line">              </span><br><span class="line">goto failed;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等socket设置完毕，nginx就开始连接后端的upstream，这段代码可以学习一个好的代码是如何处理错误的，</p>
<p>下面这段主要是处理当返回值为-１，并且err不等于NGX_EINPROGRESS的时候，而NGX_EINPROGRESS表示非阻塞的socket，然后connect，然后连接还没有完成，可是提前返回，就回设置这个errno.这个error不算出错，因此需要过滤掉.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">rc = connect(s, pc-&gt;sockaddr, pc-&gt;socklen);</span><br><span class="line"></span><br><span class="line">if (rc == -1) &#123;</span><br><span class="line">          </span><br><span class="line">err = ngx_socket_errno;</span><br><span class="line"></span><br><span class="line">//判断错误号</span><br><span class="line">          </span><br><span class="line">if (err != NGX_EINPROGRESS</span><br><span class="line">  </span><br><span class="line">#if (NGX_WIN32)</span><br><span class="line">              </span><br><span class="line">/\* Winsock returns WSAEWOULDBLOCK (NGX_EAGAIN) \*/</span><br><span class="line">              </span><br><span class="line">&amp;&amp; err != NGX_EAGAIN</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">              </span><br><span class="line">)</span><br><span class="line">          </span><br><span class="line">&#123;</span><br><span class="line">              </span><br><span class="line">if (err == NGX_ECONNREFUSED</span><br><span class="line">  </span><br><span class="line">#if (NGX_LINUX)</span><br><span class="line">                  </span><br><span class="line">/*</span><br><span class="line">                   </span><br><span class="line">* Linux returns EAGAIN instead of ECONNREFUSED</span><br><span class="line">                   </span><br><span class="line">* for unix sockets if listen queue is full</span><br><span class="line">                   </span><br><span class="line">*/</span><br><span class="line">                  </span><br><span class="line">|| err == NGX_EAGAIN</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">                  </span><br><span class="line">|| err == NGX_ECONNRESET</span><br><span class="line">                  </span><br><span class="line">|| err == NGX_ENETDOWN</span><br><span class="line">                  </span><br><span class="line">|| err == NGX_ENETUNREACH</span><br><span class="line">                  </span><br><span class="line">|| err == NGX_EHOSTDOWN</span><br><span class="line">                  </span><br><span class="line">|| err == NGX_EHOSTUNREACH)</span><br><span class="line">              </span><br><span class="line">&#123;</span><br><span class="line">                  </span><br><span class="line">level = NGX_LOG_ERR;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">                  </span><br><span class="line">level = NGX_LOG_CRIT;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_log_error(level, c-&gt;log, err, &quot;connect() to %V failed&quot;,</span><br><span class="line">                            </span><br><span class="line">pc-&gt;name);</span><br><span class="line">  </span><br><span class="line">//返回declined</span><br><span class="line">              </span><br><span class="line">return NGX_DECLINED;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是下面的部门就是处理连接成功和错误号为NGX_EINPROGRESS的情况，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">//如果当前的事件模型支持add_conn，则事件在开始已经加好了，因此如果rc==-1则直接返回</span><br><span class="line">      </span><br><span class="line">if (ngx_add_conn) &#123;</span><br><span class="line">          </span><br><span class="line">if (rc == -1) &#123;</span><br><span class="line"></span><br><span class="line">/\* NGX_EINPROGRESS \*/</span><br><span class="line"></span><br><span class="line">return NGX_AGAIN;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_EVENT, pc-&gt;log, 0, &quot;connected&quot;);</span><br><span class="line"></span><br><span class="line">wev-&gt;ready = 1;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">//添加可读事件</span><br><span class="line">      </span><br><span class="line">if (ngx_add_event(rev, NGX_READ_EVENT, event) != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">goto failed;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (rc == -1) &#123;</span><br><span class="line"></span><br><span class="line">/\* NGX_EINPROGRESS \*/</span><br><span class="line">  </span><br><span class="line">//如果错误号是　EINPROGRES　添加可写事件</span><br><span class="line">          </span><br><span class="line">if (ngx_add_event(wev, NGX_WRITE_EVENT, event) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">goto failed;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NGX_AGAIN;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_EVENT, pc-&gt;log, 0, &quot;connected&quot;);</span><br><span class="line"></span><br><span class="line">wev-&gt;ready = 1;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br></pre></td></tr></table></figure>
<p>最后我们来看下ngx_http_upstream_send_request的实现，这个函数是用来发送数据到后端的upstream，然后这里有一个需要注意的地方，那就是在linux下当非阻塞的connect，然后没有连接完成，如果挂载写事件，此时如果写事件上报上来，并不代表连接成功，此时还需要调用getsockopt来判断SO_ERROR，如果没有错误才能保证连接成功。</p>
<blockquote>
<p>SOL_SOCKET</p>
</blockquote>
<blockquote>
<p>to determine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed</p>
</blockquote>
<blockquote>
<p>here, explaining the reason for the failure).</p>
</blockquote>
<p>这里我看了下内核的代码，就是如果连接失败，比如对端不可达，内核会设置sock-&gt;sk_soft_err,而在tcp_poll中只会检测sk_err ,　对应的SO_ERROR会检测这两个错误。在内核里面的注释是这样子的</p>
<blockquote>
<ul>
<li>@sk_err: last error</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>@sk_err_soft: errors that don&#8217;t cause failure but are the cause of a</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>persistent failure not just &#8216;timed out&#8217;</li>
</ul>
</blockquote>
<p>这个按照我的理解，内核里面的sk_err 表示４层的错误，而sk_err_soft下层的错误.</p>
<p>在nginx中是在ngx_http_upstream_test_connect中对连接是否断开进行判断的(调用getsockopt).</p>
<p>然后发送数据则是调用ngx_output_chain，不过这里我们知道在ngx_output_chain中会依次调用filter链，可是upstream明显不需要调用filter链，那么nginx是怎么做的呢，是这样子的，在upstream的初始化的时候，已经讲u-&gt;output.output_filter改成ngx_chain_writer了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">u-&gt;output.output_filter = ngx_chain_writer;</span><br></pre></td></tr></table></figure>
<p>最后就是一些对错误的处理，我们来看代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_send_request(ngx_http_request_t \*r, ngx_http_upstream_t \*u)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_int_t rc;</span><br><span class="line">      </span><br><span class="line">ngx_connection_t *c;</span><br><span class="line"></span><br><span class="line">c = u-&gt;peer.connection;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0,</span><br><span class="line">                     </span><br><span class="line">&quot;http upstream send request&quot;);</span><br><span class="line">  </span><br><span class="line">//如果test connect失败，则说明连接失败，于是跳到下一个upstream，然后返回</span><br><span class="line">      </span><br><span class="line">if (!u-&gt;request_sent &amp;&amp; ngx_http_upstream_test_connect(c) != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_ERROR);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c-&gt;log-&gt;action = &quot;sending request to upstream&quot;;</span><br><span class="line">  </span><br><span class="line">//发送数据，这里的u-&gt;output.output_filter已经被修改过了</span><br><span class="line">      </span><br><span class="line">rc = ngx_output_chain(&amp;u-&gt;output, u-&gt;request_sent ? NULL : u-&gt;request_bufs);</span><br><span class="line"></span><br><span class="line">u-&gt;request_sent = 1;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">//和request的处理类似，如果again，则说明数据没有发送完毕，此时挂载写事件.</span><br><span class="line">      </span><br><span class="line">if (rc == NGX_AGAIN) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_add_timer(c-&gt;write, u-&gt;conf-&gt;send_timeout);</span><br><span class="line"></span><br><span class="line">if (ngx_handle_write_event(c-&gt;write, u-&gt;conf-&gt;send_lowat) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/\* rc == NGX_OK \*/</span><br><span class="line">  </span><br><span class="line">//设置tcp_cork,远离和前面的keepalive部分的处理类似</span><br><span class="line">      </span><br><span class="line">if (c-&gt;tcp_nopush == NGX_TCP_NOPUSH_SET) &#123;</span><br><span class="line">          </span><br><span class="line">if (ngx_tcp_push(c-&gt;fd) == NGX_ERROR) &#123;</span><br><span class="line">              </span><br><span class="line">ngx_log_error(NGX_LOG_CRIT, c-&gt;log, ngx_socket_errno,</span><br><span class="line">                            </span><br><span class="line">ngx_tcp_push_n &quot; failed&quot;);</span><br><span class="line">              </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                                 </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">              </span><br><span class="line">return;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c-&gt;tcp_nopush = NGX_TCP_NOPUSH_UNSET;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_add_timer(c-&gt;read, u-&gt;conf-&gt;read_timeout);</span><br><span class="line"></span><br><span class="line">#if 1</span><br><span class="line">  </span><br><span class="line">//如果读也可以了，则开始解析头</span><br><span class="line">      </span><br><span class="line">if (c-&gt;read-&gt;ready) &#123;</span><br><span class="line"></span><br><span class="line">/\* post aio operation \*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">           </span><br><span class="line">* TODO comment</span><br><span class="line">           </span><br><span class="line">* although we can post aio operation just in the end</span><br><span class="line">           </span><br><span class="line">* of ngx_http_upstream_connect() CHECK IT !!!</span><br><span class="line">           </span><br><span class="line">* it&amp;#8217;s better to do here because we postpone header buffer allocation</span><br><span class="line">           </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">ngx_http_upstream_process_header(r, u);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下一篇blog里面，我会详细的分析nginx对后端来的数据如何解析以及如何发送数据到client.</p>
</div><div class="tags"><a href="/tags/opensource/">opensource</a><a href="/tags/nginx/">nginx</a><a href="/tags/server/">server</a><a href="/tags/web-server/">web server</a></div><div class="post-nav"><a class="pre" href="/2011/04/20/design-and-implementation-of-epoll-in-linux-kernel.html">linux kernel中epoll的设计和实现</a><a class="next" href="/2011/04/08/design-and-implementation-of-upstream-in-nginx-(1).html">nginx中upstream的设计和实现(一)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/08/introduction-to-mysql.-rocksdb.-manifest-file.html">MySQL · RocksDB · MANIFEST文件介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>