<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MTR(mini-transaction)设计与实现 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MTR(mini-transaction)设计与实现</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MTR(mini-transaction)设计与实现</h1><div class="post-meta">Apr 18, 2019</div><div class="post-content"><h1 id="MTR-mini-transaction-设计与实现"><a href="#MTR-mini-transaction-设计与实现" class="headerlink" title="MTR(mini-transaction)设计与实现"></a>MTR(mini-transaction)设计与实现</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先来看MTR的定义:</p>
<blockquote>
<p>An internal phase of InnoDB processing, when making changes at the<strong>physical</strong>level to internal data structures during<strong>DML</strong>operations. A mini-transaction (mtr) has no notion of<strong>rollback</strong>; multiple mini-transactions can occur within a single<strong>transaction</strong>. Mini-transactions write information to the<strong>redo log</strong>that is used during<strong>crash recovery</strong>. A mini-transaction can also happen outside the context of a regular transaction, for example during<strong>purge</strong>processing by background threads.  </p>
</blockquote>
<p>MTR主要的目的是为了保证数据的一致性(比如多个事务或者发生数据库异常时). 因此MTR一般来说都伴随着写Redo log,因为redolog就是为了在recover的时候能够正常恢复数据.</p>
<p>一般来说在一个MTR中会做两个事情.</p>
<ul>
<li>写redolog</li>
<li>挂载脏页到flush list.</li>
<li><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2></li>
</ul>
<h3 id="MTR的接口"><a href="#MTR的接口" class="headerlink" title="MTR的接口"></a>MTR的接口</h3><p>一般使用逻辑如下:</p>
<blockquote>
<p>Mtr start<br>Process something<br>Mtr commit  </p>
</blockquote>
<p>来看个例子，比如在btree中打印目录以及btree info.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mtr_start(&amp;mtr);</span><br><span class="line"></span><br><span class="line">root = btr_root_block_get(index, RW_SX_LATCH, &amp;mtr);</span><br><span class="line"></span><br><span class="line">btr_print_recursive(index, root, width, &amp;heap, &amp;offsets, &amp;mtr);</span><br><span class="line"><span class="keyword">if</span> (heap) &#123;</span><br><span class="line">  mem_heap_free(heap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mtr_commit(&amp;mtr);</span><br></pre></td></tr></table></figure>

<p>可以看到使用比较简单，和我们上面的描述一致。</p>
<p>因此我们来看对应的这两个接口. 这里要注意mtr_start不仅有正常的接口，还有一个syn和async的接口，mtr_start就是mtr_start_sync.也就是默认的mtr是同步的.而async的mtr只能做只读操作.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Start a mini-transaction. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtr_start(*m*) (m)-&gt;start()</span></span><br><span class="line"></span><br><span class="line">*<span class="comment">/** Start a synchronous mini-transaction */</span>*</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtr_start_sync(*m*) (m)-&gt;start(true)</span></span><br><span class="line"></span><br><span class="line">*<span class="comment">/** Start an asynchronous read-only mini-transaction */</span>*</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtr_start_ro(*m*) (m)-&gt;start(true, true)</span></span><br><span class="line"></span><br><span class="line">*<span class="comment">/** Commit a mini-transaction. */</span>*</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mtr_commit(*m*) (m)-&gt;commit()</span></span><br></pre></td></tr></table></figure>

<p>这里的m就是 struct mtr_t ,这个结构就是mini-transaction在InnoDB中的抽象.</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>接下来来分析mtr_t这个结构, 这个结构有一个内部的数据结构用来保存MTR的一些状态.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Impl</span> &#123;</span></span><br><span class="line">    *<span class="comment">/** memo stack for locks etc. */</span>*</span><br><span class="line">    <span class="keyword">mtr_buf_t</span> m_memo;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** mini-transaction log */</span>*</span><br><span class="line">    <span class="keyword">mtr_buf_t</span> m_log;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** true if mtr has made at least one buffer pool page dirty */</span>*</span><br><span class="line">    <span class="keyword">bool</span> m_made_dirty;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** true if inside ibuf changes */</span>*</span><br><span class="line">    <span class="keyword">bool</span> m_inside_ibuf;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** true if the mini-transaction modified buffer pool pages */</span>*</span><br><span class="line">    <span class="keyword">bool</span> m_modifications;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** Count of how many page initial log records have been*</span></span><br><span class="line"><span class="comment">*written to the mtr log */</span>*</span><br><span class="line">    <span class="keyword">ib_uint32_t</span> m_n_log_recs;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** specifies which operations should be logged; default*</span></span><br><span class="line"><span class="comment">*value MTR_LOG_ALL */</span>*</span><br><span class="line">    <span class="keyword">mtr_log_t</span> m_log_mode;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** State of the transaction */</span>*</span><br><span class="line">    <span class="keyword">mtr_state_t</span> m_state;</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** Flush Observer */</span>*</span><br><span class="line">    FlushObserver *m_flush_observer;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNIV_DEBUG</span></span><br><span class="line">    *<span class="comment">/** For checking corruption. */</span>*</span><br><span class="line">    ulint m_magic_n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> *<span class="comment">/* UNIV_DEBUG */</span>*</span></span><br><span class="line"></span><br><span class="line">    *<span class="comment">/** Owning mini-transaction */</span>*</span><br><span class="line">    <span class="keyword">mtr_t</span> *m_mtr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>::注释写的比较简略，这里我们来详细看几个比较重要的字段::</p>
<p>首先是m_state,这个表示当前MTR的状态，主要有3个状态，分别是激活，提交中以及提交完毕.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">mtr_state_t</span> &#123;</span><br><span class="line">  MTR_STATE_INIT = <span class="number">0</span>,</span><br><span class="line">  MTR_STATE_ACTIVE = <span class="number">12231</span>,</span><br><span class="line">  MTR_STATE_COMMITTING = <span class="number">56456</span>,</span><br><span class="line">  MTR_STATE_COMMITTED = <span class="number">34676</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后是 m_log_mode,它主要是表示当前所需要记录的操作类型，可以看到一共分为4种操作类型.</p>
<ol>
<li>MTR_LOG_ALL 表示LOG所有的操作（包括写redolog以及加脏页到flush list)</li>
<li>MTR_LOG_NONE  不记录任何操作.</li>
<li>MTR_LOG_NO_REDO 不生成REDO log,可是会加脏页到flush list</li>
<li>MTR_LOG_SHORT_INSERTS  这个也是不记录任何操作，纯粹只是使用了MTR的一些功能(只在copy page的使用).</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment">/** Logging modes for a mini-transaction */</span>*</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">mtr_log_t</span> &#123;</span><br><span class="line">  *<span class="comment">/** Default mode: log all operations modifying disk-based data */</span>*</span><br><span class="line">  MTR_LOG_ALL = <span class="number">21</span>,</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/** Log no operations and dirty pages are not added to the flush list */</span>*</span><br><span class="line">  MTR_LOG_NONE = <span class="number">22</span>,</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/** Don't generate REDO log but add dirty pages to flush list */</span>*</span><br><span class="line">  MTR_LOG_NO_REDO = <span class="number">23</span>,</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/** Inserts are logged in a shorter form */</span>*</span><br><span class="line">  MTR_LOG_SHORT_INSERTS = <span class="number">24</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>m_log 则是当前的MTR提交的log内容,后面我们回来分析m_log的格式.</p>
<p>然后我们来看mtr_t这个结构里面仅有的几个字段. 可以看到m_impl就是上面我们介绍的Impl,而m_commit_lsn表示在commit的时候(commit)的lsn, 这里还有一个比较关键的数据结构，那就是Command,这个数据结构主要是抽象了MTR的具体操作。也就是说对于Redo log的修改其实是在Command这个结构中执行的.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> Impl m_impl;</span><br><span class="line"></span><br><span class="line"> *<span class="comment">/** LSN at commit time */</span>*</span><br><span class="line"> <span class="keyword">lsn_t</span> m_commit_lsn;</span><br><span class="line"></span><br><span class="line"> *<span class="comment">/** true if it is synchronous mini-transaction */</span>*</span><br><span class="line"> <span class="keyword">bool</span> m_sync;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Command</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Command</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="mtr-t-start"><a href="#mtr-t-start" class="headerlink" title="mtr_t::start"></a>mtr_t::start</h3><p>接下来我们来看MTR的启动函数mtr_t::start.这个函数包含两个参数，第一个sync表示是否当前的mtr是同步，第二个是read_only,这个表示当前mtr 是否只读.默认情况下sync=true, read_only=false. </p>
<p>这里的初始化可以看到state会被初始化为MTR_STATE_ACTIVE,其他的参数都是初始化为默认值.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">mtr_t</span>::start(<span class="keyword">bool</span> sync, <span class="keyword">bool</span> read_only) &#123;</span><br><span class="line">  UNIV_MEM_INVALID(<span class="keyword">this</span>, <span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  UNIV_MEM_INVALID(&amp;m_impl, <span class="keyword">sizeof</span>(m_impl));</span><br><span class="line"></span><br><span class="line">  m_sync = sync;</span><br><span class="line"></span><br><span class="line">  m_commit_lsn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> (&amp;m_impl.m_log) <span class="keyword">mtr_buf_t</span>();</span><br><span class="line">  <span class="keyword">new</span> (&amp;m_impl.m_memo) <span class="keyword">mtr_buf_t</span>();</span><br><span class="line"></span><br><span class="line">  m_impl.m_mtr = <span class="keyword">this</span>;</span><br><span class="line">  m_impl.m_log_mode = MTR_LOG_ALL;</span><br><span class="line">  m_impl.m_inside_ibuf = <span class="literal">false</span>;</span><br><span class="line">  m_impl.m_modifications = <span class="literal">false</span>;</span><br><span class="line">  m_impl.m_made_dirty = <span class="literal">false</span>;</span><br><span class="line">  m_impl.m_n_log_recs = <span class="number">0</span>;</span><br><span class="line">  m_impl.m_state = MTR_STATE_ACTIVE;</span><br><span class="line">  m_impl.m_flush_observer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  ut_d(m_impl.m_magic_n = MTR_MAGIC_N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Start完毕之后，就是提交修改了(commit).</p>
<h3 id="mtr-t-commit"><a href="#mtr-t-commit" class="headerlink" title="mtr_t::commit"></a>mtr_t::commit</h3><ol>
<li>首先会设置m_state为COMMITTING状态</li>
<li>然后进行判断是否需要执行所做的修改.</li>
</ol>
<p>这里可以看到只要满足下面两个条件之一就会去执行MTR.</p>
<ol>
<li>m_n_log_recs 大于0 也就是将要写入到mar log的页的个数.</li>
<li>当前mtr修改buffer pool pages并且不生成redolog操作.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*<span class="comment">/** Commit a mini-transaction. */</span>*</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">mtr_t</span>::commit() &#123;</span><br><span class="line">  ut_ad(is_active());</span><br><span class="line">  ut_ad(!is_inside_ibuf());</span><br><span class="line">  ut_ad(m_impl.m_magic_n == MTR_MAGIC_N);</span><br><span class="line">  m_impl.m_state = MTR_STATE_COMMITTING;</span><br><span class="line"></span><br><span class="line">  <span class="function">Command <span class="title">cmd</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m_impl.m_n_log_recs &gt; <span class="number">0</span> ||</span><br><span class="line">      (m_impl.m_modifications &amp;&amp; m_impl.m_log_mode == MTR_LOG_NO_REDO)) &#123;</span><br><span class="line">    ut_ad(!srv_read_only_mode || m_impl.m_log_mode == MTR_LOG_NO_REDO);</span><br><span class="line"></span><br><span class="line">    cmd.execute();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cmd.release_all();</span><br><span class="line">    cmd.release_resources();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Command-execute"><a href="#Command-execute" class="headerlink" title="Command::execute"></a>Command::execute</h3><p>因此我们来看最终的执行方法 execute </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">mtr_t</span>::Command::execute() &#123;</span><br><span class="line">  ut_ad(m_impl-&gt;m_log_mode != MTR_LOG_NONE);</span><br><span class="line"></span><br><span class="line">  ulint len;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNIV_HOTBACKUP</span></span><br><span class="line">  len = prepare_write();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">mtr_write_log_t</span> write_log;</span><br><span class="line"></span><br><span class="line">    write_log.m_left_to_write = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> handle = log_buffer_reserve(*log_sys, len);</span><br><span class="line"></span><br><span class="line">    write_log.m_handle = handle;</span><br><span class="line">    write_log.m_lsn = handle.start_lsn;</span><br><span class="line">    write_log.m_rec_group_start_lsn = handle.start_lsn;</span><br><span class="line"></span><br><span class="line">    m_impl-&gt;m_log.for_each_block(write_log);</span><br><span class="line"></span><br><span class="line">    ut_ad(write_log.m_left_to_write == <span class="number">0</span>);</span><br><span class="line">    ut_ad(write_log.m_lsn == handle.end_lsn);</span><br><span class="line"></span><br><span class="line">    log_wait_for_space_in_log_recent_closed(*log_sys, handle.start_lsn);</span><br><span class="line"></span><br><span class="line">    DEBUG_SYNC_C(<span class="string">"mtr_redo_before_add_dirty_blocks"</span>);</span><br><span class="line"></span><br><span class="line">    add_dirty_blocks_to_flush_list(handle.start_lsn, handle.end_lsn);</span><br><span class="line"></span><br><span class="line">    log_buffer_close(*log_sys, handle);</span><br><span class="line"></span><br><span class="line">    m_impl-&gt;m_mtr-&gt;m_commit_lsn = handle.end_lsn;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DEBUG_SYNC_C(<span class="string">"mtr_noredo_before_add_dirty_blocks"</span>);</span><br><span class="line"></span><br><span class="line">    add_dirty_blocks_to_flush_list(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> *<span class="comment">/* !UNIV_HOTBACKUP */</span>*</span></span><br><span class="line"></span><br><span class="line">  release_all();</span><br><span class="line">  release_resources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数不长，我们分段来看。</p>
<p>首先在excecute中会先进行写之前的操作，主要是进行一些校验以及最终返回将要写入的redolog长度,这个函数就是(prepare_write).</p>
<h4 id="prepare-write"><a href="#prepare-write" class="headerlink" title="prepare_write"></a>prepare_write</h4><p>先来看几个变量.</p>
<ol>
<li>m_log.size() 这个返回当前m_log buffer的字节长度.</li>
<li>m_n_log_recs 这个表示当前mtr将要写入的页的个数.</li>
</ol>
<p>因此prepare_write这个函数就是根据m_n_log_recs来判断是否是多个record，从而来设置不同的标记.</p>
<ul>
<li>如果是单个record(n_recs == 1), 则设置到m_log的最高位为1.</li>
<li>如果是多个record(n_recs &gt; 1),则多写一个字节到record的最末.</li>
</ul>
<p>最终只有多个redord才会更改len,不然默认就是m_log.size().</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ulint <span class="keyword">mtr_t</span>::Command::prepare_write() &#123;</span><br><span class="line">...............................................</span><br><span class="line">  *<span class="comment">/* An ibuf merge could happen when loading page to apply log*</span></span><br><span class="line"><span class="comment">*records during recovery. During the ibuf merge mtr is used. */</span>*</span><br><span class="line"></span><br><span class="line">  ut_a(!recv_recovery_is_on() || !recv_no_ibuf_operations);</span><br><span class="line"></span><br><span class="line">  ulint len = m_impl-&gt;m_log.size();</span><br><span class="line">  ut_ad(len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ulint n_recs = m_impl-&gt;m_n_log_recs;</span><br><span class="line">  ut_ad(n_recs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ut_ad(log_sys != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  ut_ad(m_impl-&gt;m_n_log_recs == n_recs);</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/* This was not the first time of dirtying a*</span></span><br><span class="line"><span class="comment">*tablespace since the latest checkpoint. */</span>*</span><br><span class="line"></span><br><span class="line">  ut_ad(n_recs == m_impl-&gt;m_n_log_recs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n_recs &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ut_ad(n_recs == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    *<span class="comment">/* Flag the single log record as the*</span></span><br><span class="line"><span class="comment">*only record in this mini-transaction. */</span>*</span><br><span class="line"></span><br><span class="line">    *m_impl-&gt;m_log.front()-&gt;begin() |= MLOG_SINGLE_REC_FLAG;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *<span class="comment">/* Because this mini-transaction comprises*</span></span><br><span class="line"><span class="comment">*multiple log records, append MLOG_MULTI_REC_END*</span></span><br><span class="line"><span class="comment">*at the end. */</span>*</span><br><span class="line"></span><br><span class="line">    mlog_catenate_ulint(&amp;m_impl-&gt;m_log, MLOG_MULTI_REC_END, MLOG_1BYTE);</span><br><span class="line">    ++len;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ut_ad(m_impl-&gt;m_log_mode == MTR_LOG_ALL);</span><br><span class="line">  ut_ad(m_impl-&gt;m_log.size() == len);</span><br><span class="line">  ut_ad(len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算完毕之后，我们就进入真正的执行阶段了(Command. execute)，这里流程是这样子的:</p>
<ol>
<li><p>首先需要构造一个mtr_write_log_t 结构.<br><code>mtr_write_log_t write_log;</code></p>
<ol>
<li><p>这个结构主要是将mtr中的内容写入到redo log 中.这里先来看他的字段.</p>
</li>
<li><p>m_handle 这个主要是用来保存从redolog得到的一些字段</p>
<ol>
<li>lock_no 表示shared锁</li>
<li>start_lsn表示当前mtr的起始lsn</li>
<li>end_lsn表示当前mtr的结束lsn.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">size_t</span> <span class="keyword">log_lock_no_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Log_handle</span> &#123;</span></span><br><span class="line">  <span class="keyword">log_lock_no_t</span> lock_no;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">lsn_t</span> start_lsn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">lsn_t</span> end_lsn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>m_lsn 起始lsn</p>
</li>
<li><p>m_rec_group_start_lsn ?</p>
</li>
<li><p>m_left_to_write 表示还需要写入到redolog的内容的长度，因此这个值默认就是len.</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtr_write_log_t</span> &#123;</span></span><br><span class="line">..................................</span><br><span class="line">  Log_handle m_handle;</span><br><span class="line">  <span class="keyword">lsn_t</span> m_lsn;</span><br><span class="line">  <span class="keyword">lsn_t</span> m_rec_group_start_lsn;</span><br><span class="line">  ulint m_left_to_write;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分配log buf以及初始化write_log.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">mtr_t</span>::Command::execute() &#123;</span><br><span class="line">..........................</span><br><span class="line">  <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">mtr_write_log_t</span> write_log;</span><br><span class="line"></span><br><span class="line">    write_log.m_left_to_write = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> handle = log_buffer_reserve(*log_sys, len);</span><br><span class="line"></span><br><span class="line">    write_log.m_handle = handle;</span><br><span class="line">    write_log.m_lsn = handle.start_lsn;</span><br><span class="line">    write_log.m_rec_group_start_lsn = handle.start_lsn;</span><br><span class="line">.........................................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="log-buffer-reserve"><a href="#log-buffer-reserve" class="headerlink" title="log_buffer_reserve"></a>log_buffer_reserve</h4><p>在执行mtr的时候会首先调用log_buffer_reserve在redolog中分配对应的buf长度. 这个函数主要是计算sn以及lsn ,而sn和lsn的区别是在于数据写入到redolog的时候，redolog是按照block来写的，而每一个block都会有header和footer，因此这里sn是写入者看到的lsn，而lsn则是在磁盘上的真正的lsn.<br>下面就是代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Log_handle <span class="title">log_buffer_reserve</span><span class="params">(<span class="keyword">log_t</span> &amp;<span class="built_in">log</span>, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  Log_handle handle;</span><br><span class="line"></span><br><span class="line">  handle.lock_no = log_buffer_s_lock_enter(<span class="built_in">log</span>);</span><br><span class="line">......................................</span><br><span class="line">  srv_stats.log_write_requests.inc();</span><br><span class="line"></span><br><span class="line">  ut_a(srv_shutdown_state &lt;= SRV_SHUTDOWN_FLUSH_PHASE);</span><br><span class="line">  ut_a(len &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/* Reserve space in sequence of data bytes: */</span>*</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">sn_t</span> start_sn = <span class="built_in">log</span>.sn.fetch_add(len);</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/* Ensure that redo log has been initialized properly. */</span>*</span><br><span class="line">  ut_a(start_sn &gt; <span class="number">0</span>);</span><br><span class="line">......................................</span><br><span class="line"></span><br><span class="line">  *<span class="comment">/* Headers in redo blocks are not calculated to sn values: */</span>*</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">sn_t</span> end_sn = start_sn + len;</span><br><span class="line">...........................................</span><br><span class="line">  *<span class="comment">/* Translate sn to lsn (which includes also headers in redo blocks): */</span>*</span><br><span class="line">  handle.start_lsn = log_translate_sn_to_lsn(start_sn);</span><br><span class="line">  handle.end_lsn = log_translate_sn_to_lsn(end_sn);</span><br><span class="line">...................................................</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后就是从mtr的buffer中写入内容到redolog的buffer.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">mtr_t</span>::Command::execute() &#123;</span><br><span class="line">.....................</span><br><span class="line">m_impl-&gt;m_log.for_each_block(write_log);</span><br><span class="line">.......................</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Functor&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">for_each_block</span><span class="params">(Functor &amp;functor)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">block_t</span> *block = UT_LIST_GET_FIRST(m_list); block != <span class="literal">NULL</span>;</span><br><span class="line">         block = UT_LIST_GET_NEXT(m_node, block)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!functor(block)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p> 从上面的代码我们可以看到写入最红柿会遍历m_log的buf，然后再调用write_log类的方法来真正写入block.因此我们需要再次回到mtr_write_log_t这个结构.</p>
<p>这里是通过重载()来实现函数调用的，参数block表示将要写入redolog的内容.这里看到一个循环勒啊些股</p>
<ol>
<li>首先是调用 log_buffer_write来写入block到redolog.</li>
<li>更新m_left_to_write.</li>
<li>如果内容写完则 log_buffer_set_first_record_group ？</li>
<li>调用 log_buffer_write_completed完成buffer的写入</li>
<li>更新m_lsn,以便于下次使用.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mtr_write_log_t</span> &#123;</span></span><br><span class="line">  *<span class="comment">/** Append a block to the redo log buffer.*</span></span><br><span class="line"><span class="comment">*@return whether the appending should continue */</span>*</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">mtr_buf_t</span>::<span class="keyword">block_t</span> *block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">lsn_t</span> start_lsn;</span><br><span class="line">    <span class="keyword">lsn_t</span> end_lsn;</span><br><span class="line"></span><br><span class="line">    ut_ad(block != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (block-&gt;used() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    start_lsn = m_lsn;</span><br><span class="line"></span><br><span class="line">    end_lsn = log_buffer_write(*log_sys, m_handle, block-&gt;begin(),</span><br><span class="line">                               block-&gt;used(), start_lsn);</span><br><span class="line"></span><br><span class="line">    ut_a(end_lsn % OS_FILE_LOG_BLOCK_SIZE &lt;</span><br><span class="line">         OS_FILE_LOG_BLOCK_SIZE - LOG_BLOCK_TRL_SIZE);</span><br><span class="line"></span><br><span class="line">    m_left_to_write -= block-&gt;used();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_left_to_write == <span class="number">0</span></span><br><span class="line">        &amp;&amp; m_rec_group_start_lsn / OS_FILE_LOG_BLOCK_SIZE !=</span><br><span class="line">               end_lsn / OS_FILE_LOG_BLOCK_SIZE) &#123;</span><br><span class="line">      log_buffer_set_first_record_group(*log_sys, m_handle, end_lsn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log_buffer_write_completed(*log_sys, m_handle, start_lsn, end_lsn);</span><br><span class="line"></span><br><span class="line">    m_lsn = end_lsn;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">.........................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，可以看到核心就是两个调用，一个是log_buffer_write, 一个是log_buffer_write_completed.</p>
<h4 id="log-buffer-write"><a href="#log-buffer-write" class="headerlink" title="log_buffer_write"></a>log_buffer_write</h4><p>先来看log_buffer_write,这个函数主要是写入到redo log buffer(log-&gt;buf).</p>
<ol>
<li>这里首先根据start_lsn(也就是前一次写入之后的lsn),来计算当前的redolog block的偏移(也就是上一次写入之后的可写位置).</li>
<li>然后得到当前的block剩余的大小</li>
<li>如果当前block可以写入在直接copy到当前的block</li>
<li>否则只copy部分(left)内容到当前block,然后再次进入循环再写入一个新的block.</li>
<li>最后则是返回最终写入完毕后的lsn.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lsn_t</span> log_buffer_write(<span class="keyword">log_t</span> &amp;<span class="built_in">log</span>, <span class="keyword">const</span> Log_handle &amp;handle, <span class="keyword">const</span> byte *str,</span><br><span class="line">                       <span class="keyword">size_t</span> str_len, <span class="keyword">lsn_t</span> start_lsn) &#123;</span><br><span class="line">............................</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">lsn_t</span> end_sn = log_translate_lsn_to_sn(start_lsn) + str_len;</span><br><span class="line"></span><br><span class="line">  byte *buf_end = <span class="built_in">log</span>.buf + <span class="built_in">log</span>.buf_size;</span><br><span class="line"></span><br><span class="line">  byte *ptr = <span class="built_in">log</span>.buf + (start_lsn % <span class="built_in">log</span>.buf_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">lsn_t</span> lsn = start_lsn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> offset = lsn % OS_FILE_LOG_BLOCK_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> left = OS_FILE_LOG_BLOCK_SIZE - LOG_BLOCK_TRL_SIZE - offset;</span><br><span class="line"></span><br><span class="line">    ut_a(left &gt; <span class="number">0</span>);</span><br><span class="line">    ut_a(left &lt; OS_FILE_LOG_BLOCK_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> len, lsn_diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; str_len) &#123;</span><br><span class="line"></span><br><span class="line">      len = str_len;</span><br><span class="line"></span><br><span class="line">      lsn_diff = str_len;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      len = left;</span><br><span class="line"></span><br><span class="line">      lsn_diff = left + LOG_BLOCK_TRL_SIZE + LOG_BLOCK_HDR_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">..............................</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(ptr, str, len);</span><br><span class="line"></span><br><span class="line">    str_len -= len;</span><br><span class="line">    str += len;</span><br><span class="line">    lsn += lsn_diff;</span><br><span class="line">    ptr += lsn_diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ptr &gt;= buf_end) &#123;</span><br><span class="line"></span><br><span class="line">      ptr -= <span class="built_in">log</span>.buf_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lsn_diff &gt; left) &#123;</span><br><span class="line">......................................</span><br><span class="line">      log_block_set_first_rec_group(</span><br><span class="line">          <span class="keyword">reinterpret_cast</span>&lt;byte *&gt;(<span class="keyword">uintptr_t</span>(ptr) &amp;</span><br><span class="line">                                   ~<span class="keyword">uintptr_t</span>(LOG_BLOCK_HDR_SIZE)),</span><br><span class="line">          <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (str_len == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...............................</span><br><span class="line">  <span class="keyword">return</span> (lsn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="log-buffer-write-completed"><a href="#log-buffer-write-completed" class="headerlink" title="log_buffer_write_completed"></a>log_buffer_write_completed</h4><p>然后就是log_buffer_write_completed函数，这个函数主要是用来更新recent_written字段，这个字段主要是用来track已经写入到log buffer的lsn(后续分析redolog的时候会详细分析).</p>
<p>逻辑很简单，就是判断是否recent_written是否还有空间，如果没有则等待，否则加入到recent_written.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_buffer_write_completed</span><span class="params">(<span class="keyword">log_t</span> &amp;*<span class="built_in">log</span>*, <span class="keyword">const</span> Log_handle &amp;*handle*,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">lsn_t</span> *start_lsn*, <span class="keyword">lsn_t</span> *end_lsn*)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> wait_loops = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">log</span>.recent_written.has_space(start_lsn)) &#123;</span><br><span class="line">    ++wait_loops;</span><br><span class="line">    os_thread_sleep(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(wait_loops != <span class="number">0</span>)) &#123;</span><br><span class="line">    MONITOR_INC_VALUE(MONITOR_LOG_ON_RECENT_WRITTEN_WAIT_LOOPS, wait_loops);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">log</span>.recent_written.add_link(start_lsn, end_lsn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="log-wait-for-space-in-log-recent-closed"><a href="#log-wait-for-space-in-log-recent-closed" class="headerlink" title="log_wait_for_space_in_log_recent_closed"></a>log_wait_for_space_in_log_recent_closed</h3><p>然后我们来看log_wait_for_space_in_log_recent_closed，到达这里的话，则说明我们已经写完log buffer,然后等待加脏页到flush list,而在InnoDB中log.recent_closed用来track在flush list中的脏页，因此这里在加脏页之前需要判断是否link buf已满。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_wait_for_space_in_log_recent_closed</span><span class="params">(<span class="keyword">log_t</span> &amp;*<span class="built_in">log</span>*, <span class="keyword">lsn_t</span> *lsn*)</span> </span>&#123;</span><br><span class="line">  ut_a(log_lsn_validate(lsn));</span><br><span class="line"></span><br><span class="line">  ut_ad(lsn &gt;= log_buffer_dirty_pages_added_up_to_lsn(<span class="built_in">log</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> wait_loops = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!<span class="built_in">log</span>.recent_closed.has_space(lsn)) &#123;</span><br><span class="line">    ++wait_loops;</span><br><span class="line">    os_thread_sleep(<span class="number">20</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlikely(wait_loops != <span class="number">0</span>)) &#123;</span><br><span class="line">    MONITOR_INC_VALUE(MONITOR_LOG_ON_RECENT_CLOSED_WAIT_LOOPS, wait_loops);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-dirty-blocks-to-flush-list"><a href="#add-dirty-blocks-to-flush-list" class="headerlink" title="add_dirty_blocks_to_flush_list"></a>add_dirty_blocks_to_flush_list</h3><p>然后就是加脏页到flush list中.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">mtr_t</span>::Command::add_dirty_blocks_to_flush_list(<span class="keyword">lsn_t</span> *start_lsn*,</span><br><span class="line">                                                    <span class="keyword">lsn_t</span> *end_lsn*) &#123;</span><br><span class="line">  <span class="function">Add_dirty_blocks_to_flush_list <span class="title">add_to_flush</span><span class="params">(start_lsn, end_lsn,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              m_impl-&gt;m_flush_observer)</span></span>;</span><br><span class="line"></span><br><span class="line">  Iterate&lt;Add_dirty_blocks_to_flush_list&gt; iterator(add_to_flush);</span><br><span class="line"></span><br><span class="line">  m_impl-&gt;m_memo.for_each_block_in_reverse(iterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个点要注意的.</p>
<ul>
<li>m_impl-&gt;m_memo<ul>
<li>这个里面保存了需要加入到flush list的block</li>
<li>也就是说在使用mtr的时候，需要自己挂载block到这个数据结构</li>
</ul>
</li>
<li>Add_dirty_blocks_to_flush_list<ul>
<li>核心是这个数据结构，所有的操作都在这个结构里面</li>
</ul>
</li>
</ul>
<p>m_memo.for_each_block_in_reverse比较简单，就是从尾部开始遍历，然后调用iterator的()，因此这里我们来看Add_dirty_blocks_to_flush_list的().</p>
<p>这里可以看到最终就是调用add_dirty_page_to_flush_list来吧对应的block加入到flush list,这里不详细分析这块，以后我们分析buffer pool相关代码的时候会再来看这块.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">mtr_memo_slot_t</span> **slot*)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (slot-&gt;object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slot-&gt;type == MTR_MEMO_PAGE_X_FIX ||</span><br><span class="line">        slot-&gt;type == MTR_MEMO_PAGE_SX_FIX) &#123;</span><br><span class="line">      add_dirty_page_to_flush_list(slot);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slot-&gt;type == MTR_MEMO_BUF_FIX) &#123;</span><br><span class="line">      <span class="keyword">buf_block_t</span> *block;</span><br><span class="line">      block = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">buf_block_t</span> *&gt;(slot-&gt;object);</span><br><span class="line">      <span class="keyword">if</span> (block-&gt;made_dirty_with_no_latch) &#123;</span><br><span class="line">        add_dirty_page_to_flush_list(slot);</span><br><span class="line">        block-&gt;made_dirty_with_no_latch = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>#MySQL/InnoDB/MTR</p>
</div><div class="tags"><a href="/tags/InnoDB/">InnoDB</a></div><div class="post-nav"><a class="pre" href="/2019/06/19/redo-log-design-and-implementation-in-innodb-1.html">InnoDB中Redo log设计与实现(一)</a><a class="next" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/redo-log-design-and-implementation-in-innodb-1.html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/mtr-minitransaction-design-and-implementation.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-·-rocksdb-data-reading-2.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-·-rocksdb-data-reading-1.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-·-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-·-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/mysql-·-rocksdb-memtable-write.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/mysql-·-rocksdb-implementation-of-write-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>