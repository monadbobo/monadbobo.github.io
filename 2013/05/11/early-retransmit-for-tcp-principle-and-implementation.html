<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Early Retransmit for TCP原理以及实现 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Early Retransmit for TCP原理以及实现</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Early Retransmit for TCP原理以及实现</h1><div class="post-meta">May 11, 2013<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a><a href="/categories/kernel/协议/">协议</a></span></div><div class="post-content"><p>Early Retransmit for TCP(ER)是google为了解决快重传的一些局限，从而对快重传(fast retransmit)做出的一些改变，其中ER在linux kernel 3.5进入了内核,他的paper在这里：</p>
<p><a href="http://tools.ietf.org/html/rfc5827" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc5827</a></p>
<p>首先我们要知道快重传算法的弱点很多，比如如果发送端接收不到足够数量(一般来说是3个)的ack，那么快重传算法就无法起作用，这个时候就只能等待RTO超时。ER主要就是为了解决这个问题的。在下面的条件下，就会导致收不到足够的ack。</p>
<ul>
<li>拥塞窗口比较小</li>
<li>窗口中一个很大的段丢失或者在传输的结尾处发生了丢包</li>
</ul>
<a id="more"></a>
<p>如果满足了上面的两个条件，那么就会发生发送端由于接收不到足够数量的ack，导致快重传算法无法生效。举个例子，比如拥塞窗口是3，然后第一个段丢失了，那么理论上最多发送段只可能收到2个重复的(duplicate)ack,此时由于快重传要求3个重复的ack，那么发送端将会等待RTO超时，然后重传第一个段.</p>
<p>在上面的第二个条件中，有两种可能性，其中ER是为了解决第一种可能性(也就是当一个比较大的段丢失),而第二种情况则需要TLP来解决(TLP应该会合并进下个版本的内核，我后续也会分析TLP).</p>
<p>下面是我对ER做的一些摘要笔记：</p>
<ul>
<li>在linux下early retransit 和thin dupack是互斥的。</li>
<li>early retransmit也就是会在小窗口下(flight count 小于4),减小快重传的数量，比如减小到1或者2。而在linux的实现里面，会人为的加上一个延迟，为了防止假超时。</li>
<li>ER打开的条件有两个，第一个是outstand的数据很小，第二个是前一个未发送的数据不能被发送</li>
<li>由于early retransmit必须很小心，因此必须通过sack来猜测中间的一个段已经丢失才会启动early retransmit，比如有3个 in flight的段，那么sack必须有2个段，也就是这样才会启动early retrainsmit.</li>
<li>快重传也只是每次新的数据发送过来之后才会激活，因此最少窗口要有4个段。</li>
<li><p>当接收端收到一个outstand的数据的话，必须立即发送一个重复的ack，这个就是为了快重传(rfc2581/5681)</p>
<p>一般来说是通过sack来判断快重传(sack_outs),也就是说每次快重传的ack(重复ack)都会带sack.</p>
</li>
</ul>
<p>接下来来描述一下ER的算法，ER可以基于两种模式，一种是基于字节的，一种是基于段(segment-based)的，两种算法基本差不多，我这里主要描述基于段的，因为linux kernel中实现的就是基于段的。</p>
<p>当一个ack到来后，发送端启动early retransmit(ER)只有满足下面两个条件。</p>
<ul>
<li>outstanding段的个数(oseg),小于4.</li>
<li>要么没有未发送的数据，要么advertised 接受窗口不允许新的段被发送.</li>
</ul>
<p>当上面的两个条件满足并且当前tcp链接不提供sack，那么duplicate ack threshold(快重传的ack个数阈值),必须被减少为 ER_thresh=oseg &#8211; 1.</p>
<p>当上面的两个条件满足，并且当前tcp连接支持sack，那么只有当(oseg-1)个数的段已经被sacked时，ER才会被使用。</p>
<p>ER的优点我们都知道了，接下来来看看ER的缺点，或者说可能会引起的问题。当应用层(application)不是连续的发送数据的时候，ER会导致很多不必要的重传。举个例子，假设一个application发送两个段的数据，然后紧跟着一段idle期。那么此时如果网络reorder这两个段，那么发送者将会发送没必要的一个段(ER的重传).如果application持续的这样发送数据，那么将会有1/3的段是没必要发送的。</p>
<p>接下来来看对应的linux kernel实现，我这里内核版本是3.7.</p>
<p>首先内核增加了一个sysctl的选项tcp_early_retrans，这个选项用来开关ER，这个选项默认值是2，也就是打开ER，并且打开delay定时器。</p>
<blockquote>
<p>tcp_early_retrans &#8211; INTEGER</p>
</blockquote>
<blockquote>
<p>Enable Early Retransmit (ER), per RFC 5827. ER lowers the threshold</p>
</blockquote>
<blockquote>
<p>for triggering fast retransmit when the amount of outstanding data is</p>
</blockquote>
<blockquote>
<p>small and when no previously unsent data can be transmitted (such</p>
</blockquote>
<blockquote>
<p>that limited transmit could be used).</p>
</blockquote>
<blockquote>
<p>Possible values:</p>
</blockquote>
<blockquote>
<p>0 disables ER</p>
</blockquote>
<blockquote>
<p>1 enables ER</p>
</blockquote>
<blockquote>
<p>2 enables ER but delays fast recovery and fast retransmit</p>
</blockquote>
<blockquote>
<p>by a fourth of RTT. This mitigates connection falsely</p>
</blockquote>
<blockquote>
<p>recovers when network has a small degree of reordering</p>
</blockquote>
<blockquote>
<p>(less than 3 packets).</p>
</blockquote>
<blockquote>
<p>Default: 2 </p>
</blockquote>
<p>首先来看ER的初始化函数，当每一个socket建立的时候，都会调用tcp_enable_early_retrans来设置对应的ER选项值，这里主要是两个值，一个是do_early_retrans，表示是否打开ER，一个是early_retrans_delayed，表示delay是否已经打开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static inline void tcp_enable_early_retrans(struct tcp_sock *tp)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;do_early_retrans = sysctl_tcp_early_retrans &amp;&amp;</span><br><span class="line">		  </span><br><span class="line">!sysctl_tcp_thin_dupack &amp;&amp; sysctl_tcp_reordering == 3;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;early_retrans_delayed = 0;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们可以看到ER打开的三个条件分别是</p>
<ul>
<li>首先sysctl的选项必须打开</li>
<li>第二thin dupack必须关闭</li>
<li>第三tcp_reordering必须为3</li>
</ul>
<p>然后我们来看tcp_time_to_recover这个函数中ER的相关部分。tcp_time_to_recover如果返回true则我们可能会进入快重传，否则将会继续保持open状态.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">if (tp-&gt;do_early_retrans &amp;&amp; !tp-&gt;retrans_out &amp;&amp; tp-&gt;sacked_out &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">(tp-&gt;packets_out == (tp-&gt;sacked_out + 1) &amp;&amp; tp-&gt;packets_out &lt; 4) &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">!tcp_may_send_now(sk))</span><br><span class="line">		  </span><br><span class="line">return !tcp_pause_early_retransmit(sk, flag);</span><br></pre></td></tr></table></figure>
<p>上面的代码很好理解(上一篇blog分析过)，因为判断条件基本和paper描述一致，其中下面这个条件说明，如果收到oseg -1 个dup ack，就会进入ER处理。因为packets_out就表示oseg的段的个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">tp-&gt;packets_out == (tp-&gt;sacked_out + 1) &amp;&amp; tp-&gt;packets_out &lt; 4</span><br></pre></td></tr></table></figure>
<p>然后来看tcp_pause_early_retransmit这个函数，它主要是ER对快重传做一定的延迟.这里通过early_retrans_delayed来标记这个延迟.这个延迟时间一般是设置为RTT/4. 也就是当ER判断需要快重传的时候，并不会立即启动快重传，而是启动一个delay定时器，等定时器超时后再重传。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static bool tcp_pause_early_retransmit(struct sock *sk, int flag)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	  </span><br><span class="line">unsigned long delay;</span><br><span class="line"></span><br><span class="line">/* Delay early retransmit and entering fast recovery for</span><br><span class="line">	   </span><br><span class="line">* max(RTT/4, 2msec) unless ack has ECE mark, no RTT samples</span><br><span class="line">	   </span><br><span class="line">* available, or RTO is scheduled to fire first.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">if (sysctl_tcp_early_retrans &lt; 2 || (flag &amp; FLAG_ECE) || !tp-&gt;srtt)</span><br><span class="line">		  </span><br><span class="line">return false;</span><br><span class="line">  </span><br><span class="line">//设置延迟</span><br><span class="line">	  </span><br><span class="line">delay = max_t(unsigned long, (tp-&gt;srtt &gt;&gt; 5), msecs_to_jiffies(2));</span><br><span class="line">	  </span><br><span class="line">if (!time_after(inet_csk(sk)-&gt;icsk_timeout, (jiffies + delay)))</span><br><span class="line">		  </span><br><span class="line">return false;</span><br><span class="line">  </span><br><span class="line">//启动定时器</span><br><span class="line">	  </span><br><span class="line">inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, delay, TCP_RTO_MAX);</span><br><span class="line">	  </span><br><span class="line">tp-&gt;early_retrans_delayed = 1;</span><br><span class="line">	  </span><br><span class="line">return true;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来看当delay定时器到期后会发生什么,由于通过上面的代码我们可以看到ER的delay定时器是重传定时器，因此当delay 超时后，将会在重传定时器回调中调用tcp_resume_early_retransmit。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void tcp_resume_early_retransmit(struct sock *sk)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">tcp_rearm_rto(sk);</span><br><span class="line"></span><br><span class="line">/\* Stop if ER is disabled after the delayed ER timer is scheduled \*/</span><br><span class="line">	  </span><br><span class="line">if (!tp-&gt;do_early_retrans)</span><br><span class="line">		  </span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">tcp_enter_recovery(sk, false);</span><br><span class="line">	  </span><br><span class="line">tcp_update_scoreboard(sk, 1);</span><br><span class="line">	  </span><br><span class="line">tcp_xmit_retransmit_queue(sk);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/tcp-ip/">tcp/ip</a><a href="/tags/tcp/">tcp</a></div><div class="post-nav"><a class="pre" href="/2013/09/08/lua-source-analysis-(4).html">Lua源码剖析（四）</a><a class="next" href="/2012/10/21/tcp-congestion-handling-in-linux-kernel-(2).html">linux 内核tcp拥塞处理(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>