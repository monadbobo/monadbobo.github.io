<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Lua源码剖析(五) | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Lua源码剖析(五)</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Lua源码剖析(五)</h1><div class="post-meta">Dec 3, 2013<span> | </span><span class="category"><a href="/categories/lua/">lua</a><a href="/categories/lua/源码阅读/">源码阅读</a></span></div><div class="post-content"><p>这次主要来分析lua的gc。</p>
<p>首先lua中的数据类型包括下面9种，ni， Boolean， number， string， table，user data， thread , functions 以及 lightusedata.其中 string， table，thread , function 是会被垃圾回收管理的，其他的都是值存在。</p>
<p>因此我们来看对应的GC数据结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define CommonHeader GCObject *next; lu_byte tt; lu_byte marked</span><br><span class="line"></span><br><span class="line">typedef struct GCheader &#123;</span><br><span class="line">    </span><br><span class="line">CommonHeader;</span><br><span class="line">  </span><br><span class="line">&#125; GCheader;</span><br><span class="line"></span><br><span class="line">union GCObject &#123;</span><br><span class="line">    </span><br><span class="line">GCheader gch;</span><br><span class="line">    </span><br><span class="line">union TString ts;</span><br><span class="line">    </span><br><span class="line">union Udata u;</span><br><span class="line">    </span><br><span class="line">union Closure cl;</span><br><span class="line">    </span><br><span class="line">struct Table h;</span><br><span class="line">    </span><br><span class="line">struct Proto p;</span><br><span class="line">    </span><br><span class="line">struct UpVal uv;</span><br><span class="line">    </span><br><span class="line">struct lua_State th; /\* thread \*/</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到在lua中字符串，userdata, thread, table ,string, thread(以及Upval, proto) 都会被垃圾回收管理。这里比较关键的就是GCheader这个结构体，我们可以看到这个结构体其实就是一个链表，也就是说所有的gc对象都会被链到一个链表中，其中tt表示当前对象的类型，在lua中包括下面这些类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define LUA_TNIL 0</span><br><span class="line">  </span><br><span class="line">#define LUA_TBOOLEAN 1</span><br><span class="line">  </span><br><span class="line">#define LUA_TLIGHTUSERDATA 2</span><br><span class="line">  </span><br><span class="line">#define LUA_TNUMBER 3</span><br><span class="line">  </span><br><span class="line">#define LUA_TSTRING 4</span><br><span class="line">  </span><br><span class="line">#define LUA_TTABLE 5</span><br><span class="line">  </span><br><span class="line">#define LUA_TFUNCTION 6</span><br><span class="line">  </span><br><span class="line">#define LUA_TUSERDATA 7</span><br><span class="line">  </span><br><span class="line">#define LUA_TTHREAD 8</span><br></pre></td></tr></table></figure>
<p>而marked表示当前对象的状态(涉及到gc算法，后续会详细分析),状态位包括下面这些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define WHITE0BIT 0</span><br><span class="line">  </span><br><span class="line">#define WHITE1BIT 1</span><br><span class="line">  </span><br><span class="line">#define BLACKBIT 2</span><br><span class="line">  </span><br><span class="line">#define FINALIZEDBIT 3</span><br><span class="line">  </span><br><span class="line">#define KEYWEAKBIT 3</span><br><span class="line">  </span><br><span class="line">#define VALUEWEAKBIT 4</span><br><span class="line">  </span><br><span class="line">#define FIXEDBIT 5</span><br><span class="line">  </span><br><span class="line">#define SFIXEDBIT 6</span><br><span class="line">  </span><br><span class="line">#define WHITEBITS bit2mask(WHITE0BIT, WHITE1BIT)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后我们来看lua_state这个数据结构，这个结构也就是一个lua意义上的thread。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct lua_State &#123;</span><br><span class="line">    </span><br><span class="line">CommonHeader;</span><br><span class="line">    </span><br><span class="line">lu_byte status;</span><br><span class="line">    </span><br><span class="line">StkId top; /\* first free slot in the stack \*/</span><br><span class="line">    </span><br><span class="line">StkId base; /\* base of current function \*/</span><br><span class="line">    </span><br><span class="line">global_State *l_G;</span><br><span class="line">    </span><br><span class="line">CallInfo \*ci; /\* call info for current function */</span><br><span class="line">    </span><br><span class="line">const Instruction \*savedpc; /\* \`savedpc&amp;#8217; of current function */</span><br><span class="line">    </span><br><span class="line">StkId stack_last; /\* last free slot in the stack \*/</span><br><span class="line">    </span><br><span class="line">StkId stack; /\* stack base \*/</span><br><span class="line">    </span><br><span class="line">CallInfo \*end_ci; /\* points after end of ci array*/</span><br><span class="line">    </span><br><span class="line">CallInfo \*base_ci; /\* array of CallInfo&amp;#8217;s */</span><br><span class="line">    </span><br><span class="line">int stacksize;</span><br><span class="line">    </span><br><span class="line">int size_ci; /\* size of array \`base_ci&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">unsigned short nCcalls; /\* number of nested C calls \*/</span><br><span class="line">    </span><br><span class="line">unsigned short baseCcalls; /\* nested C calls when resuming coroutine \*/</span><br><span class="line">    </span><br><span class="line">lu_byte hookmask;</span><br><span class="line">    </span><br><span class="line">lu_byte allowhook;</span><br><span class="line">    </span><br><span class="line">int basehookcount;</span><br><span class="line">    </span><br><span class="line">int hookcount;</span><br><span class="line">    </span><br><span class="line">lua_Hook hook;</span><br><span class="line">    </span><br><span class="line">TValue l_gt; /\* table of globals \*/</span><br><span class="line">    </span><br><span class="line">TValue env; /\* temporary place for environments \*/</span><br><span class="line">    </span><br><span class="line">GCObject \*openupval; /\* list of open upvalues in this stack */</span><br><span class="line">    </span><br><span class="line">GCObject *gclist;</span><br><span class="line">    </span><br><span class="line">struct lua_longjmp \*errorJmp; /\* current error recover point */</span><br><span class="line">    </span><br><span class="line">ptrdiff_t errfunc; /\* current error handling function (stack index) \*/</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每一个lua虚拟机可能会包含很多个lua_state结构。而所有的lua_State所共享的数据(比如string，比如gc数据等), 都将会放到global_State中。</p>
<p>这里要注意所有的GC数据中，string和其他的是不同的，他和其他的GC对象分开管理，我们先来看非string类的对象如何管理。先来看global_State这个结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct global_State &#123;</span><br><span class="line">    </span><br><span class="line">stringtable strt; /\* hash table for strings \*/</span><br><span class="line">    </span><br><span class="line">lua_Alloc frealloc; /\* function to reallocate memory \*/</span><br><span class="line">    </span><br><span class="line">void \*ud; /\* auxiliary data to \`frealloc&amp;#8217; */</span><br><span class="line">    </span><br><span class="line">lu_byte currentwhite;</span><br><span class="line">    </span><br><span class="line">lu_byte gcstate; /\* state of garbage collector \*/</span><br><span class="line">    </span><br><span class="line">int sweepstrgc; /\* position of sweep in \`strt&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">GCObject \*rootgc; /\* list of all collectable objects */</span><br><span class="line">    </span><br><span class="line">GCObject *\*sweepgc; /\* position of sweep in \`rootgc&amp;#8217; */</span><br><span class="line">    </span><br><span class="line">GCObject \*gray; /\* list of gray objects */</span><br><span class="line">    </span><br><span class="line">GCObject \*grayagain; /\* list of objects to be traversed atomically */</span><br><span class="line">    </span><br><span class="line">GCObject \*weak; /\* list of weak tables (to be cleared) */</span><br><span class="line">    </span><br><span class="line">GCObject \*tmudata; /\* last element of list of userdata to be GC */</span><br><span class="line">    </span><br><span class="line">Mbuffer buff; /\* temporary buffer for string concatentation \*/</span><br><span class="line">    </span><br><span class="line">lu_mem GCthreshold;</span><br><span class="line">    </span><br><span class="line">lu_mem totalbytes; /\* number of bytes currently allocated \*/</span><br><span class="line">    </span><br><span class="line">lu_mem estimate; /\* an estimate of number of bytes actually in use \*/</span><br><span class="line">    </span><br><span class="line">lu_mem gcdept; /\* how much GC is \`behind schedule&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">int gcpause; /\* size of pause between successive GCs \*/</span><br><span class="line">    </span><br><span class="line">int gcstepmul; /\* GC \`granularity&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">lua_CFunction panic; /\* to be called in unprotected errors \*/</span><br><span class="line">    </span><br><span class="line">TValue l_registry;</span><br><span class="line">    </span><br><span class="line">struct lua_State *mainthread;</span><br><span class="line">    </span><br><span class="line">UpVal uvhead; /\* head of double-linked list of all open upvalues \*/</span><br><span class="line">    </span><br><span class="line">struct Table \*mt[NUM_TAGS]; /\* metatables for basic types */</span><br><span class="line">    </span><br><span class="line">TString \*tmname[TM_N]; /\* array with tag-method names */</span><br><span class="line">  </span><br><span class="line">&#125; global_State;</span><br></pre></td></tr></table></figure>
<p>着重来看GC相关的几个数据结构。当前虚拟机的所有的GC对象都会保存在一个链表中，这个链表的根就是global_State的rootgc中。我们来看roottgc的初始化，代码在lua_newstate中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">g-&gt;rootgc = obj2gco(L);</span><br></pre></td></tr></table></figure>
<p>然后每一个被创建的gc对象都会被挂载到这个链表中。挂载函数就是luaC_link。这个函数主要用来将需要gc的对象link到全局的global_state中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaC_link (lua_State \*L, GCObject \*o, lu_byte tt) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">o-&gt;gch.next = g-&gt;rootgc;</span><br><span class="line">    </span><br><span class="line">g-&gt;rootgc = o;</span><br><span class="line">    </span><br><span class="line">o-&gt;gch.marked = luaC_white(g);</span><br><span class="line">    </span><br><span class="line">o-&gt;gch.tt = tt;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的函数，我们可以看到每次新的gc对象插入的时候，总是放到链表的最前端(rootgc 为当前对象). </p>
<p>不过这里的upvalue和userdata都是使用另外的方法挂载到全局的涟中的，先来看upvalue(upvalue是什么，我这里就不介绍了，前面的lua源码分析有介绍过的).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaC_linkupval (lua_State \*L, UpVal \*uv) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">GCObject *o = obj2gco(uv);</span><br><span class="line">    </span><br><span class="line">o-&gt;gch.next = g-&gt;rootgc; /\* link upvalue into \`rootgc&amp;#8217; list \*/</span><br><span class="line">    </span><br><span class="line">g-&gt;rootgc = o;</span><br><span class="line">    </span><br><span class="line">if (isgray(o)) &#123;</span><br><span class="line">      </span><br><span class="line">if (g-&gt;gcstate == GCSpropagate) &#123;</span><br><span class="line">        </span><br><span class="line">gray2black(o); /\* closed upvalues need barrier \*/</span><br><span class="line">        </span><br><span class="line">luaC_barrier(L, uv, uv-&gt;v);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">else &#123; /\* sweep phase: sweep it (turning it into white) \*/</span><br><span class="line">        </span><br><span class="line">makewhite(g, o);</span><br><span class="line">        </span><br><span class="line">lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到和luaC_link不同的是，进行了gc算法的一些操作，这里我们先搁置，后续介绍gc算法的时候，会再来看这里。</p>
<p>然后就是userdata的特殊处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">Udata \*luaS_newudata (lua_State \*L, size_t s, Table *e) &#123;</span><br><span class="line">    </span><br><span class="line">Udata *u;</span><br><span class="line">    </span><br><span class="line">if (s &gt; MAX_SIZET &amp;#8211; sizeof(Udata))</span><br><span class="line">      </span><br><span class="line">luaM_toobig(L);</span><br><span class="line">    </span><br><span class="line">u = cast(Udata *, luaM_malloc(L, s + sizeof(Udata)));</span><br><span class="line">    </span><br><span class="line">u-&gt;uv.marked = luaC_white(G(L)); /\* is not finalized \*/</span><br><span class="line">    </span><br><span class="line">u-&gt;uv.tt = LUA_TUSERDATA;</span><br><span class="line">    </span><br><span class="line">u-&gt;uv.len = s;</span><br><span class="line">    </span><br><span class="line">u-&gt;uv.metatable = NULL;</span><br><span class="line">    </span><br><span class="line">u-&gt;uv.env = e;</span><br><span class="line">    </span><br><span class="line">/\* chain it on udata list (after main thread) \*/</span><br><span class="line">    </span><br><span class="line">u-&gt;uv.next = G(L)-&gt;mainthread-&gt;next;</span><br><span class="line">    </span><br><span class="line">G(L)-&gt;mainthread-&gt;next = obj2gco(u);</span><br><span class="line">    </span><br><span class="line">return u;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是和上面的两种方式完全不同,这是因为userdata一般来说都有自己的gc方法，因此最好能够放在一起处理，因此这里会将udata放到最末尾.</p>
<p>在lua中的gc算法，是mark-sweep算法，这个算法简单来说就分为两步，第一步是遍历所有的GCObject的对象，然后做标记 。 第二步是遍历所有可回收对象，然后清除没有做过标记的对象。 在lua中通过两个参数来控制gc的频率和周期，分别是garbage-collector pause 和garbage-collector step multiplier， 这两个值都是使用百分比(100表示 100%). 其中garbage-collector pause控制回收器等待多久开始一次新的垃圾回收，比如默认值是200，那么就说明只有当等待内存使用为上一次gc时的2倍才会进行下一次gc。而garbage-collector step multiplier控制垃圾回收的相对速度(相对于分配的速度), 默认也是200，说明垃圾回收的速度为内存分配的两倍，这两个值都可以通过lua_gc来修改(LUA_GCSETPAUSE与LUA_GCSETSTEPMUL).</p>
<p>而在lua 5.1中实现的是 Tri-color marking 算法，算法描述见wiki(<a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tri-color_marking" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Tri-color_marking</a>) , 这个算法将每一个对象分为三种颜色，分别是白色(初始状态), 灰色(和root有连接，可是它所连接的对象还没有被扫描,因此这个状态不能被gc),以及黑色(可以被释放的对象集合), 所有的对象都会经历从白色到灰色再到黑色的过程.</p>
<p>算法的具体步骤如下:</p>
<blockquote>
<ol>
<li>Create initial white, grey, and black sets; these sets will be used to maintain progress during the cycle.</li>
</ol>
</blockquote>
<blockquote>
<p>2.</p>
</blockquote>
<blockquote>
<ul>
<li>Initially the white set or condemned set is the set of objects that are candidates for having their memory recycled.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>The black set is the set of objects that can cheaply be proven to have no references to objects in the white set, but are also not chosen to be candidates for recycling; in many implementations, the black set starts off empty.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>The grey set is all the objects that are reachable from root references but the objects referenced by grey objects haven&#8217;t been scanned yet. Grey objects are known to be reachable from the root, so cannot be garbage collected: grey objects will eventually end up in the black set. The grey state means we still need to check any objects that the object references.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>The grey set is initialised to objects which are referenced directly at root level; typically all other objects are initially placed in the white set.</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Objects can move from white to grey to black, never in the other direction.</li>
</ul>
</blockquote>
<blockquote>
<ol start="3">
<li>Pick an object from the grey set. Blacken this object (move it to the black set), by greying all the white objects it references directly. This confirms that this object cannot be garbage collected, and also that any objects it references cannot be garbage collected.</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>Repeat the previous step until the grey set is empty.</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>When there are no more objects in the grey set, then all the objects remaining in the white set have been demonstrated not to be reachable, and the storage occupied by them can be reclaimed.</li>
</ol>
</blockquote>
<p>然后我们来看具体实现，我们就从最常见的table来分析。首先来看lua gc的启动。这里核心方法就是luaC_checkGC这个宏, 因为gc的启动一般来说就是通过这个宏开始的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define luaC_checkGC(L) &#123; \</span><br><span class="line">    </span><br><span class="line">condhardstacktests(luaD_reallocstack(L, L-&gt;stacksize &amp;#8211; EXTRA_STACK &amp;#8211; 1)); \</span><br><span class="line">    </span><br><span class="line">if (G(L)-&gt;totalbytes &gt;= G(L)-&gt;GCthreshold) \</span><br><span class="line">       </span><br><span class="line">luaC_step(L); &#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到它会比较当前分配的字节数与GCthreshold进行比较，如果大于这个值才会进行step。而GCthreshold就是一个阀值..</p>
<p>然后来看luaC_step这个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaC_step (lua_State *L) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">  </span><br><span class="line">//首先计算需要回收的内存大小</span><br><span class="line">    </span><br><span class="line">l_mem lim = (GCSTEPSIZE/100) * g-&gt;gcstepmul;</span><br><span class="line">    </span><br><span class="line">if (lim == 0)</span><br><span class="line">      </span><br><span class="line">lim = (MAX_LUMEM-1)/2; /\* no limit \*/</span><br><span class="line">    </span><br><span class="line">g-&gt;gcdept += g-&gt;totalbytes &amp;#8211; g-&gt;GCthreshold;</span><br><span class="line">    </span><br><span class="line">do &#123;</span><br><span class="line">  </span><br><span class="line">//开始gc处理</span><br><span class="line">      </span><br><span class="line">lim -= singlestep(L);</span><br><span class="line">      </span><br><span class="line">if (g-&gt;gcstate == GCSpause)</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">    </span><br><span class="line">&#125; while (lim &gt; 0);</span><br><span class="line">    </span><br><span class="line">if (g-&gt;gcstate != GCSpause) &#123;</span><br><span class="line">      </span><br><span class="line">if (g-&gt;gcdept &lt; GCSTEPSIZE)</span><br><span class="line">        </span><br><span class="line">g-&gt;GCthreshold = g-&gt;totalbytes + GCSTEPSIZE; /\* &amp;#8211; lim/g-&gt;gcstepmul;\*/</span><br><span class="line">      </span><br><span class="line">else &#123;</span><br><span class="line">        </span><br><span class="line">g-&gt;gcdept -= GCSTEPSIZE;</span><br><span class="line">        </span><br><span class="line">g-&gt;GCthreshold = g-&gt;totalbytes;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">else &#123;</span><br><span class="line">      </span><br><span class="line">setthreshold(g);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要就是singlestep函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static l_mem singlestep (lua_State *L) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">/\*lua_checkmemory(L);\*/</span><br><span class="line">    </span><br><span class="line">switch (g-&gt;gcstate) &#123;</span><br><span class="line">      </span><br><span class="line">case GCSpause: &#123;</span><br><span class="line">        </span><br><span class="line">markroot(L); /\* start a new collection \*/</span><br><span class="line">        </span><br><span class="line">return 0;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case GCSpropagate: &#123;</span><br><span class="line">        </span><br><span class="line">if (g-&gt;gray)</span><br><span class="line">          </span><br><span class="line">return propagatemark(g);</span><br><span class="line">        </span><br><span class="line">else &#123; /\* no more \`gray&amp;#8217; objects \*/</span><br><span class="line">          </span><br><span class="line">atomic(L); /\* finish mark phase \*/</span><br><span class="line">          </span><br><span class="line">return 0;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case GCSsweepstring: &#123;</span><br><span class="line">        </span><br><span class="line">lu_mem old = g-&gt;totalbytes;</span><br><span class="line">        </span><br><span class="line">sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class="line">        </span><br><span class="line">if (g-&gt;sweepstrgc &gt;= g-&gt;strt.size) /\* nothing more to sweep? \*/</span><br><span class="line">          </span><br><span class="line">g-&gt;gcstate = GCSsweep; /\* end sweep-string phase \*/</span><br><span class="line">        </span><br><span class="line">lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">        </span><br><span class="line">g-&gt;estimate -= old &amp;#8211; g-&gt;totalbytes;</span><br><span class="line">        </span><br><span class="line">return GCSWEEPCOST;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case GCSsweep: &#123;</span><br><span class="line">        </span><br><span class="line">lu_mem old = g-&gt;totalbytes;</span><br><span class="line">        </span><br><span class="line">g-&gt;sweepgc = sweeplist(L, g-&gt;sweepgc, GCSWEEPMAX);</span><br><span class="line">        </span><br><span class="line">if (\*g-&gt;sweepgc == NULL) &#123; /\* nothing more to sweep? */</span><br><span class="line">          </span><br><span class="line">checkSizes(L);</span><br><span class="line">          </span><br><span class="line">g-&gt;gcstate = GCSfinalize; /\* end sweep phase \*/</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">        </span><br><span class="line">g-&gt;estimate -= old &amp;#8211; g-&gt;totalbytes;</span><br><span class="line">        </span><br><span class="line">return GCSWEEPMAX*GCSWEEPCOST;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case GCSfinalize: &#123;</span><br><span class="line">        </span><br><span class="line">if (g-&gt;tmudata) &#123;</span><br><span class="line">          </span><br><span class="line">GCTM(L);</span><br><span class="line">          </span><br><span class="line">if (g-&gt;estimate &gt; GCFINALIZECOST)</span><br><span class="line">            </span><br><span class="line">g-&gt;estimate -= GCFINALIZECOST;</span><br><span class="line">          </span><br><span class="line">return GCFINALIZECOST;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">else &#123;</span><br><span class="line">          </span><br><span class="line">g-&gt;gcstate = GCSpause; /\* end collection \*/</span><br><span class="line">          </span><br><span class="line">g-&gt;gcdept = 0;</span><br><span class="line">          </span><br><span class="line">return 0;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">default: lua_assert(0); return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里是一个状态机. 这里lua的gc执行顺序也是按照上面的状态的从大到小开始。</p>
<p>其中GCSpause是初始化状态。在这个状态主要就是标记主线程对象(也就是从白色染成灰色)。我们就从这个状态开始,我们可以看到这个状态的处理很简单，就是调用markroot函数来标记对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void markroot (lua_State *L) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">g-&gt;gray = NULL;</span><br><span class="line">    </span><br><span class="line">g-&gt;grayagain = NULL;</span><br><span class="line">    </span><br><span class="line">g-&gt;weak = NULL;</span><br><span class="line">    </span><br><span class="line">markobject(g, g-&gt;mainthread);</span><br><span class="line">    </span><br><span class="line">/\* make global table be traversed before main stack \*/</span><br><span class="line">    </span><br><span class="line">markvalue(g, gt(g-&gt;mainthread));</span><br><span class="line">    </span><br><span class="line">markvalue(g, registry(L));</span><br><span class="line">    </span><br><span class="line">markmt(g);</span><br><span class="line">    </span><br><span class="line">g-&gt;gcstate = GCSpropagate;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的markXXX的几个函数最终都会调用reallymarkobject函数，因此我们就从这个函数开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void reallymarkobject (global_State \*g, GCObject \*o) &#123;</span><br><span class="line">    </span><br><span class="line">lua_assert(iswhite(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">    </span><br><span class="line">white2gray(o);</span><br><span class="line">    </span><br><span class="line">switch (o-&gt;gch.tt) &#123;</span><br><span class="line">      </span><br><span class="line">case LUA_TSTRING: &#123;</span><br><span class="line">        </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TUSERDATA: &#123;</span><br><span class="line">        </span><br><span class="line">Table *mt = gco2u(o)-&gt;metatable;</span><br><span class="line">        </span><br><span class="line">gray2black(o); /\* udata are never gray \*/</span><br><span class="line">        </span><br><span class="line">if (mt) markobject(g, mt);</span><br><span class="line">        </span><br><span class="line">markobject(g, gco2u(o)-&gt;env);</span><br><span class="line">        </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TUPVAL: &#123;</span><br><span class="line">        </span><br><span class="line">UpVal *uv = gco2uv(o);</span><br><span class="line">        </span><br><span class="line">markvalue(g, uv-&gt;v);</span><br><span class="line">        </span><br><span class="line">if (uv-&gt;v == &amp;uv-&gt;u.value) /\* closed? \*/</span><br><span class="line">          </span><br><span class="line">gray2black(o); /\* open upvalues are never black \*/</span><br><span class="line">        </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TFUNCTION: &#123;</span><br><span class="line">        </span><br><span class="line">gco2cl(o)-&gt;c.gclist = g-&gt;gray;</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = o;</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TTABLE: &#123;</span><br><span class="line">        </span><br><span class="line">gco2h(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = o;</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TTHREAD: &#123;</span><br><span class="line">        </span><br><span class="line">gco2th(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = o;</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TPROTO: &#123;</span><br><span class="line">        </span><br><span class="line">gco2p(o)-&gt;gclist = g-&gt;gray;</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = o;</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">default: lua_assert(0);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数我们可以看到首先它会将白色染成灰色，然后会根据对象的类型来做不同的操作，这里特殊操作就3种类型，分别是string(不通过gc管理),userdata, 以及upval，其他的类型都是将灰色的对象连接到global state的链表中.</p>
<p>当GCSpause状态之后，会进入GCSpropagate状态(上面的markroot函数最后一个语句).这个状态也是一个标记过程，并且这个状态会被进入多次，也就是分布迭代。如果gray对象一直存在的话，会反复调用propagatemark函数，等所有的gray对象都被标记了，那么就将会进入atomic函数处理。这个函数，顾名思义，也就是原子操作，最终在这个状态之后，gc进入清理字符串的阶段.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static l_mem propagatemark (global_State *g) &#123;</span><br><span class="line">    </span><br><span class="line">GCObject *o = g-&gt;gray;</span><br><span class="line">    </span><br><span class="line">lua_assert(isgray(o));</span><br><span class="line">    </span><br><span class="line">gray2black(o);</span><br><span class="line">    </span><br><span class="line">switch (o-&gt;gch.tt) &#123;</span><br><span class="line">      </span><br><span class="line">case LUA_TTABLE: &#123;</span><br><span class="line">        </span><br><span class="line">Table *h = gco2h(o);</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = h-&gt;gclist;</span><br><span class="line">        </span><br><span class="line">if (traversetable(g, h)) /\* table is weak? \*/</span><br><span class="line">          </span><br><span class="line">black2gray(o); /\* keep it gray \*/</span><br><span class="line">        </span><br><span class="line">return sizeof(Table) + sizeof(TValue) * h-&gt;sizearray +</span><br><span class="line">                               </span><br><span class="line">sizeof(Node) * sizenode(h);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TFUNCTION: &#123;</span><br><span class="line">        </span><br><span class="line">Closure *cl = gco2cl(o);</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = cl-&gt;c.gclist;</span><br><span class="line">        </span><br><span class="line">traverseclosure(g, cl);</span><br><span class="line">        </span><br><span class="line">return (cl-&gt;c.isC) ? sizeCclosure(cl-&gt;c.nupvalues) :</span><br><span class="line">                             </span><br><span class="line">sizeLclosure(cl-&gt;l.nupvalues);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TTHREAD: &#123;</span><br><span class="line">        </span><br><span class="line">lua_State *th = gco2th(o);</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = th-&gt;gclist;</span><br><span class="line">        </span><br><span class="line">th-&gt;gclist = g-&gt;grayagain;</span><br><span class="line">        </span><br><span class="line">g-&gt;grayagain = o;</span><br><span class="line">        </span><br><span class="line">black2gray(o);</span><br><span class="line">        </span><br><span class="line">traversestack(g, th);</span><br><span class="line">        </span><br><span class="line">return sizeof(lua_State) + sizeof(TValue) * th-&gt;stacksize +</span><br><span class="line">                                   </span><br><span class="line">sizeof(CallInfo) * th-&gt;size_ci;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">case LUA_TPROTO: &#123;</span><br><span class="line">        </span><br><span class="line">Proto *p = gco2p(o);</span><br><span class="line">        </span><br><span class="line">g-&gt;gray = p-&gt;gclist;</span><br><span class="line">        </span><br><span class="line">traverseproto(g, p);</span><br><span class="line">        </span><br><span class="line">return sizeof(Proto) + sizeof(Instruction) * p-&gt;sizecode +</span><br><span class="line">                               </span><br><span class="line">sizeof(Proto \*) \* p-&gt;sizep +</span><br><span class="line">                               </span><br><span class="line">sizeof(TValue) * p-&gt;sizek +</span><br><span class="line">                               </span><br><span class="line">sizeof(int) * p-&gt;sizelineinfo +</span><br><span class="line">                               </span><br><span class="line">sizeof(LocVar) * p-&gt;sizelocvars +</span><br><span class="line">                               </span><br><span class="line">sizeof(TString \*) \* p-&gt;sizeupvalues;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">default: lua_assert(0); return 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在propagate状态，也会根据对象类型来进行标记，这里我们可以看到它首先会把当前的对象节点标记为黑色，然后再进行后续处理,主要来看table类型。它会将对象挂载到gray链表，然后开始遍历标记table，这里注意如果table是weak的，那么则会将black节点重新染成gray的, 最后返回这次标记的内存大小，而核心方法就在traversetable.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int traversetable (global_State \*g, Table \*h) &#123;</span><br><span class="line">    </span><br><span class="line">int i;</span><br><span class="line">    </span><br><span class="line">int weakkey = 0;</span><br><span class="line">    </span><br><span class="line">int weakvalue = 0;</span><br><span class="line">    </span><br><span class="line">const TValue *mode;</span><br><span class="line">    </span><br><span class="line">if (h-&gt;metatable)</span><br><span class="line">      </span><br><span class="line">markobject(g, h-&gt;metatable);</span><br><span class="line">    </span><br><span class="line">mode = gfasttm(g, h-&gt;metatable, TM_MODE);</span><br><span class="line">    </span><br><span class="line">if (mode &amp;&amp; ttisstring(mode)) &#123; /\* is there a weak mode? \*/</span><br><span class="line">      </span><br><span class="line">weakkey = (strchr(svalue(mode), &amp;#8216;k&amp;#8217;) != NULL);</span><br><span class="line">      </span><br><span class="line">weakvalue = (strchr(svalue(mode), &amp;#8216;v&amp;#8217;) != NULL);</span><br><span class="line">      </span><br><span class="line">if (weakkey || weakvalue) &#123; /\* is really weak? \*/</span><br><span class="line">        </span><br><span class="line">h-&gt;marked &amp;= ~(KEYWEAK | VALUEWEAK); /\* clear bits \*/</span><br><span class="line">        </span><br><span class="line">h-&gt;marked |= cast_byte((weakkey &lt;&lt; KEYWEAKBIT) |</span><br><span class="line">                               </span><br><span class="line">(weakvalue &lt;&lt; VALUEWEAKBIT));</span><br><span class="line">        </span><br><span class="line">h-&gt;gclist = g-&gt;weak; /\* must be cleared after GC, &amp;#8230; \*/</span><br><span class="line">        </span><br><span class="line">g-&gt;weak = obj2gco(h); /\* &amp;#8230; so put in the appropriate list \*/</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">if (weakkey &amp;&amp; weakvalue) return 1;</span><br><span class="line">    </span><br><span class="line">if (!weakvalue) &#123;</span><br><span class="line">      </span><br><span class="line">i = h-&gt;sizearray;</span><br><span class="line">      </span><br><span class="line">while (i&amp;#8211;)</span><br><span class="line">        </span><br><span class="line">markvalue(g, &amp;h-&gt;array[i]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//对表的数组部分进行处理.</span><br><span class="line">    </span><br><span class="line">i = sizenode(h);</span><br><span class="line">    </span><br><span class="line">while (i&amp;#8211;) &#123;</span><br><span class="line">      </span><br><span class="line">Node *n = gnode(h, i);</span><br><span class="line">      </span><br><span class="line">lua_assert(ttype(gkey(n)) != LUA_TDEADKEY || ttisnil(gval(n)));</span><br><span class="line">      </span><br><span class="line">if (ttisnil(gval(n)))</span><br><span class="line">        </span><br><span class="line">removeentry(n); /\* remove empty entries \*/</span><br><span class="line">      </span><br><span class="line">else &#123;</span><br><span class="line">        </span><br><span class="line">lua_assert(!ttisnil(gkey(n)));</span><br><span class="line">        </span><br><span class="line">if (!weakkey) markvalue(g, gkey(n));</span><br><span class="line">        </span><br><span class="line">if (!weakvalue) markvalue(g, gval(n));</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return weakkey || weakvalue;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>traversetable方法首先会标记元表，然后主要是对weak table进行特殊处理,由于weak table是弱引用，因此这里将会在gc之后单独处理弱表(g-&gt;weak).如果不是weak表，那么将会对这个对象进行mark。最后返回值是表示当前的表是否处于weak模式.</p>
<p>如果traversetable返回1，则表示表是weak模式，此时重新将对象的颜色染回灰色，因为weak table，后续会统一处理，也就是脱离lua的gc.</p>
<p>最后如果已经将所有的gray对象染色完毕(weak 表的话，gray对象会被移到g-&gt;weak),那么GCSpropagate状态最后将会进入atomic这个函数。这个函数之所以叫atomic，是因为在这个状态下lua的标记是不会被打断的，它最终会做一次清理，也就是对于在标记期间有改变的对象再次进行mark。这里就涉及到一个barrier的概念，之所以要有barrier，是因为由于lua的gc是分步的，因此在进入最终的清理状态之前，有可能被标记的对象的颜色已经改变(比如本来是白色，可是我们第一次扫描之后，它又被使用了，此时自然就变成灰色了，或者是已经被染色为黑色了，可是对象后续又没有对应的引用了),在这些情况下，都会将颜色染回灰色，要么是barrier fwd(white-&gt;gray),要么是 barrier back(black-&gt;gray).后续我们会详细介绍barrier，这里先跳过.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void atomic (lua_State *L) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">size_t udsize; /\* total size of userdata to be finalized \*/</span><br><span class="line">    </span><br><span class="line">/\* remark occasional upvalues of (maybe) dead threads \*/</span><br><span class="line">    </span><br><span class="line">remarkupvals(g);</span><br><span class="line">    </span><br><span class="line">/\* traverse objects cautch by write barrier and by &amp;#8216;remarkupvals&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">propagateall(g);</span><br><span class="line">    </span><br><span class="line">/\* remark weak tables \*/</span><br><span class="line">    </span><br><span class="line">g-&gt;gray = g-&gt;weak;</span><br><span class="line">    </span><br><span class="line">g-&gt;weak = NULL;</span><br><span class="line">    </span><br><span class="line">lua_assert(!iswhite(obj2gco(g-&gt;mainthread)));</span><br><span class="line">    </span><br><span class="line">markobject(g, L); /\* mark running thread \*/</span><br><span class="line">    </span><br><span class="line">markmt(g); /\* mark basic metatables (again) \*/</span><br><span class="line">    </span><br><span class="line">propagateall(g);</span><br><span class="line">    </span><br><span class="line">/\* remark gray again \*/</span><br><span class="line">    </span><br><span class="line">g-&gt;gray = g-&gt;grayagain;</span><br><span class="line">    </span><br><span class="line">g-&gt;grayagain = NULL;</span><br><span class="line">    </span><br><span class="line">propagateall(g);</span><br><span class="line">    </span><br><span class="line">udsize = luaC_separateudata(L, 0); /\* separate userdata to be finalized \*/</span><br><span class="line">    </span><br><span class="line">marktmu(g); /\* mark \`preserved&amp;#8217; userdata \*/</span><br><span class="line">    </span><br><span class="line">udsize += propagateall(g); /\* remark, to propagate \`preserveness&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">cleartable(g-&gt;weak); /\* remove collected objects from weak tables \*/</span><br><span class="line">    </span><br><span class="line">/\* flip current white \*/</span><br><span class="line">    </span><br><span class="line">g-&gt;currentwhite = cast_byte(otherwhite(g));</span><br><span class="line">  </span><br><span class="line">//这里注意，这个值后面清理string的时候会用到.</span><br><span class="line">    </span><br><span class="line">g-&gt;sweepstrgc = 0;</span><br><span class="line">  </span><br><span class="line">//清理其他对象的时候，会用到.到达这里说明在rootgc上挂在的都是不可达对象，因此我们需要将他们后续清理.</span><br><span class="line">    </span><br><span class="line">g-&gt;sweepgc = &amp;g-&gt;rootgc;</span><br><span class="line">    </span><br><span class="line">g-&gt;gcstate = GCSsweepstring;</span><br><span class="line">    </span><br><span class="line">g-&gt;estimate = g-&gt;totalbytes &amp;#8211; udsize; /\* first estimate \*/</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还有一个要注意的，那就是处理useadata，由于userdata是会有自己的gc方法，因此userdata最终会单独处理(前面我们看到链接到gcroot的时候，也是放在最末尾).来看luaC_separateudata:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">size_t luaC_separateudata (lua_State *L, int all) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">size_t deadmem = 0;</span><br><span class="line">  </span><br><span class="line">//取出userdata</span><br><span class="line">    </span><br><span class="line">GCObject **p = &amp;g-&gt;mainthread-&gt;next;</span><br><span class="line">    </span><br><span class="line">GCObject *curr;</span><br><span class="line">  </span><br><span class="line">//开始遍历</span><br><span class="line">    </span><br><span class="line">while ((curr = *p) != NULL) &#123;</span><br><span class="line">      </span><br><span class="line">if (!(iswhite(curr) || all) || isfinalized(gco2u(curr)))</span><br><span class="line">        </span><br><span class="line">p = &amp;curr-&gt;gch.next; /\* don&amp;#8217;t bother with them \*/</span><br><span class="line">      </span><br><span class="line">else if (fasttm(L, gco2u(curr)-&gt;metatable, TM_GC) == NULL) &#123;</span><br><span class="line">        </span><br><span class="line">markfinalized(gco2u(curr)); /\* don&amp;#8217;t need finalization \*/</span><br><span class="line">        </span><br><span class="line">p = &amp;curr-&gt;gch.next;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">else &#123; /\* must call its gc method \*/</span><br><span class="line">  </span><br><span class="line">//到达这里说明有gc方法</span><br><span class="line">        </span><br><span class="line">deadmem += sizeudata(gco2u(curr));</span><br><span class="line">        </span><br><span class="line">markfinalized(gco2u(curr));</span><br><span class="line">        </span><br><span class="line">*p = curr-&gt;gch.next;</span><br><span class="line">        </span><br><span class="line">/\* link \`curr&amp;#8217; at the end of \`tmudata&amp;#8217; list \*/</span><br><span class="line">        </span><br><span class="line">if (g-&gt;tmudata == NULL) /\* list is empty? \*/</span><br><span class="line">          </span><br><span class="line">g-&gt;tmudata = curr-&gt;gch.next = curr; /\* creates a circular list \*/</span><br><span class="line">        </span><br><span class="line">else &#123;</span><br><span class="line">          </span><br><span class="line">curr-&gt;gch.next = g-&gt;tmudata-&gt;gch.next;</span><br><span class="line">          </span><br><span class="line">g-&gt;tmudata-&gt;gch.next = curr;</span><br><span class="line">          </span><br><span class="line">g-&gt;tmudata = curr;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return deadmem;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面我们可以看到这里并没有真正的释放userdata，只是将有gc方法的userdata链接到g-&gt;tmudata上。我们要谨记，在lua gc中，只有清理阶段才会真正释放内存。</p>
<p>然后我们来看GCSsweepstring状态，也就是清理string。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">case GCSsweepstring: &#123;</span><br><span class="line">        </span><br><span class="line">lu_mem old = g-&gt;totalbytes;</span><br><span class="line">  </span><br><span class="line">//这里可以看到每次进来都会对当前的hash进行释放，这里sweepstrgc相当于一个索引</span><br><span class="line">        </span><br><span class="line">sweepwholelist(L, &amp;g-&gt;strt.hash[g-&gt;sweepstrgc++]);</span><br><span class="line">  </span><br><span class="line">//判断是否释放完毕</span><br><span class="line">        </span><br><span class="line">if (g-&gt;sweepstrgc &gt;= g-&gt;strt.size) /\* nothing more to sweep? \*/</span><br><span class="line">          </span><br><span class="line">g-&gt;gcstate = GCSsweep; /\* end sweep-string phase \*/</span><br><span class="line">        </span><br><span class="line">lua_assert(old &gt;= g-&gt;totalbytes);</span><br><span class="line">        </span><br><span class="line">g-&gt;estimate -= old &amp;#8211; g-&gt;totalbytes;</span><br><span class="line">        </span><br><span class="line">return GCSWEEPCOST;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define sweepwholelist(L,p) sweeplist(L,p,MAX_LUMEM)</span><br></pre></td></tr></table></figure>
<p>可以看到核心的方法就是 sweeplist,这个方法是清理阶段所有的对象都会调用这个方法.这里注意有一个other white，这个也就是当我们在标记之后，清理之前新添加的对象，我们都会认为他们是other white，等待下次处理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static GCObject *\*sweeplist (lua_State \*L, GCObject **p, lu_mem count) &#123;</span><br><span class="line">    </span><br><span class="line">GCObject *curr;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">int deadmask = otherwhite(g);</span><br><span class="line">  </span><br><span class="line">//遍历gc对象</span><br><span class="line">    </span><br><span class="line">while ((curr = *p) != NULL &amp;&amp; count&amp;#8211; &gt; 0) &#123;</span><br><span class="line">      </span><br><span class="line">if (curr-&gt;gch.tt == LUA_TTHREAD) /\* sweep open upvalues of each thread \*/</span><br><span class="line">        </span><br><span class="line">sweepwholelist(L, &amp;gco2th(curr)-&gt;openupval);</span><br><span class="line">  </span><br><span class="line">//如果还没有dead，则会重新染成白色，等待下次处理</span><br><span class="line">      </span><br><span class="line">if ((curr-&gt;gch.marked ^ WHITEBITS) &amp; deadmask) &#123; /\* not dead? \*/</span><br><span class="line">        </span><br><span class="line">lua_assert(!isdead(g, curr) || testbit(curr-&gt;gch.marked, FIXEDBIT));</span><br><span class="line">        </span><br><span class="line">makewhite(g, curr); /\* make it white (for next cycle) \*/</span><br><span class="line">        </span><br><span class="line">p = &amp;curr-&gt;gch.next;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">else &#123; /\* must erase \`curr&amp;#8217; \*/</span><br><span class="line">        </span><br><span class="line">lua_assert(isdead(g, curr) || deadmask == bitmask(SFIXEDBIT));</span><br><span class="line">        </span><br><span class="line">*p = curr-&gt;gch.next;</span><br><span class="line">        </span><br><span class="line">if (curr == g-&gt;rootgc) /\* is the first element of the list? \*/</span><br><span class="line">          </span><br><span class="line">g-&gt;rootgc = curr-&gt;gch.next; /\* adjust first \*/</span><br><span class="line">  </span><br><span class="line">//释放对象</span><br><span class="line">        </span><br><span class="line">freeobj(L, curr);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">return p;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看最后一个状态 GCSfinalize，这个状态最终会处理useadata，主要是调用GCTM 来调用userdata的gc方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void GCTM (lua_State *L) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">GCObject \*o = g-&gt;tmudata-&gt;gch.next; /\* get first element */</span><br><span class="line">    </span><br><span class="line">Udata *udata = rawgco2u(o);</span><br><span class="line">    </span><br><span class="line">const TValue *tm;</span><br><span class="line">    </span><br><span class="line">/\* remove udata from \`tmudata&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">if (o == g-&gt;tmudata) /\* last element? \*/</span><br><span class="line">      </span><br><span class="line">g-&gt;tmudata = NULL;</span><br><span class="line">    </span><br><span class="line">else</span><br><span class="line">      </span><br><span class="line">g-&gt;tmudata-&gt;gch.next = udata-&gt;uv.next;</span><br><span class="line">    </span><br><span class="line">udata-&gt;uv.next = g-&gt;mainthread-&gt;next; /\* return it to \`root&amp;#8217; list \*/</span><br><span class="line">    </span><br><span class="line">g-&gt;mainthread-&gt;next = o;</span><br><span class="line">    </span><br><span class="line">makewhite(g, o);</span><br><span class="line">  </span><br><span class="line">//取的gc 元方法.</span><br><span class="line">    </span><br><span class="line">tm = fasttm(L, udata-&gt;uv.metatable, TM_GC);</span><br><span class="line">    </span><br><span class="line">if (tm != NULL) &#123;</span><br><span class="line">      </span><br><span class="line">lu_byte oldah = L-&gt;allowhook;</span><br><span class="line">      </span><br><span class="line">lu_mem oldt = g-&gt;GCthreshold;</span><br><span class="line">      </span><br><span class="line">L-&gt;allowhook = 0; /\* stop debug hooks during GC tag method \*/</span><br><span class="line">      </span><br><span class="line">g-&gt;GCthreshold = 2\*g-&gt;totalbytes; /\* avoid GC steps */</span><br><span class="line">      </span><br><span class="line">setobj2s(L, L-&gt;top, tm);</span><br><span class="line">      </span><br><span class="line">setuvalue(L, L-&gt;top+1, udata);</span><br><span class="line">      </span><br><span class="line">L-&gt;top += 2;</span><br><span class="line">  </span><br><span class="line">//调用对应的gc方法.</span><br><span class="line">      </span><br><span class="line">luaD_call(L, L-&gt;top &amp;#8211; 2, 0);</span><br><span class="line">      </span><br><span class="line">L-&gt;allowhook = oldah; /\* restore hooks \*/</span><br><span class="line">      </span><br><span class="line">g-&gt;GCthreshold = oldt; /\* restore threshold \*/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们来看 write barrier，它主要用来解决在扫描过程中，一些已经染色的对象，或者说新添加的对象能够被正确的染色。来看对应的4个api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#define luaC_barrier(L,p,v) &#123; if (valiswhite(v) &amp;&amp; isblack(obj2gco(p))) \</span><br><span class="line">       </span><br><span class="line">luaC_barrierf(L,obj2gco(p),gcvalue(v)); &#125;</span><br><span class="line"></span><br><span class="line">#define luaC_barriert(L,t,v) &#123; if (valiswhite(v) &amp;&amp; isblack(obj2gco(t))) \</span><br><span class="line">       </span><br><span class="line">luaC_barrierback(L,t); &#125;</span><br><span class="line"></span><br><span class="line">#define luaC_objbarrier(L,p,o) \</span><br><span class="line">       </span><br><span class="line">&#123; if (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(p))) \</span><br><span class="line">            </span><br><span class="line">luaC_barrierf(L,obj2gco(p),obj2gco(o)); &#125;</span><br><span class="line"></span><br><span class="line">#define luaC_objbarriert(L,t,o) \</span><br><span class="line">     </span><br><span class="line">&#123; if (iswhite(obj2gco(o)) &amp;&amp; isblack(obj2gco(t))) luaC_barrierback(L,t); &#125;</span><br></pre></td></tr></table></figure>
<p>其中带obj的表示是针对gc类型的，而不带obj的api表示是针对Tvalue类型的。而对应的luaC_barrierf(forwardl表示 从白色到灰色，而luaC_barrierback(back)表示从黑色到灰色. 并且可以看到table被拿出来特殊处理，这里之所以特殊处理，是因为table的修改是很频繁的，而其他的对象之间联系会比较少.因此前面的代码我们也可以看到(atomic)，也是针对table对象特殊处理.</p>
<p>这四个函数都是用于将对象v(o)关联到p(t)时，需要做的操作.先来看luaC_barrierf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaC_barrierf (lua_State \*L, GCObject \*o, GCObject *v) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">lua_assert(isblack(o) &amp;&amp; iswhite(v) &amp;&amp; !isdead(g, v) &amp;&amp; !isdead(g, o));</span><br><span class="line">    </span><br><span class="line">lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">    </span><br><span class="line">lua_assert(ttype(&amp;o-&gt;gch) != LUA_TTABLE);</span><br><span class="line">    </span><br><span class="line">/\* must keep invariant? \*/</span><br><span class="line">    </span><br><span class="line">if (g-&gt;gcstate == GCSpropagate)</span><br><span class="line">      </span><br><span class="line">reallymarkobject(g, v); /\* restore invariant \*/</span><br><span class="line">    </span><br><span class="line">else /\* don&amp;#8217;t mind \*/</span><br><span class="line">      </span><br><span class="line">makewhite(g, o); /\* mark as white just to avoid other barriers \*/</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数很简单，我们可以看到只有处于mark状态时，我们才需要重新mark将要挂在的对象，否则就直接把对象染成白色(和需要清理的白色不同)。</p>
<p>然后是luaC_barrierback</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaC_barrierback (lua_State \*L, Table \*t) &#123;</span><br><span class="line">    </span><br><span class="line">global_State *g = G(L);</span><br><span class="line">    </span><br><span class="line">GCObject *o = obj2gco(t);</span><br><span class="line">    </span><br><span class="line">lua_assert(isblack(o) &amp;&amp; !isdead(g, o));</span><br><span class="line">    </span><br><span class="line">lua_assert(g-&gt;gcstate != GCSfinalize &amp;&amp; g-&gt;gcstate != GCSpause);</span><br><span class="line">    </span><br><span class="line">black2gray(o); /\* make table gray (again) \*/</span><br><span class="line">    </span><br><span class="line">t-&gt;gclist = g-&gt;grayagain;</span><br><span class="line">    </span><br><span class="line">g-&gt;grayagain = o;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到是直接变为灰色，然后再把对象加载到grayagain这个链表上.而最终会在atomic函数中特殊处理.</p>
</div><div class="tags"><a href="/tags/lua/">lua</a><a href="/tags/gc/">gc</a></div><div class="post-nav"><a class="pre" href="/2018/04/18/introduction-to-mysql-rocksdb-wal-(writeaheadlog).html">MySQL · RocksDB · WAL(WriteAheadLog)介绍</a><a class="next" href="/2013/09/08/lua-source-analysis-(4).html">Lua源码剖析（四）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>