<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Lua源码剖析（四） | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Lua源码剖析（四）</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Lua源码剖析（四）</h1><div class="post-meta">Sep 8, 2013<span> | </span><span class="category"><a href="/categories/lua/">lua</a><a href="/categories/lua/源码阅读/">源码阅读</a></span></div><div class="post-content"><p>前面三篇请看我前面的 <a href="http://www.pagefault.info/?p=34" title="lua源码分析" target="_blank" rel="noopener">blog</a></p>
<p>这篇主要来分析lua的虚拟机的实现，我看的代码依旧是5.1</p>
<p>因此首先从luaL_loadfile开始，这个函数我们知道是在当前的lua state加载一个lua文件，其中第二个参数就是filename。</p>
<p>其中LoadF结构很简单，它用来表示一个load file：</p>
<figure class="highlight plain"><figcaption><span>struct LoadF &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">int extraline;</span><br><span class="line">    </span><br><span class="line">FILE *f;</span><br><span class="line">    </span><br><span class="line">char buff[LUAL_BUFFERSIZE];</span><br><span class="line">  </span><br><span class="line">&#125; LoadF;</span><br></pre></td></tr></table></figure>
<p>其中会使用fopen来打开对应的文件名,然后根据第一个字符来判断是否是注释(#)，如果是则跳过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">lua_pushfstring(L, &quot;@%s&quot;, filename);</span><br><span class="line">      </span><br><span class="line">lf.f = fopen(filename, &quot;r&quot;);</span><br><span class="line">      </span><br><span class="line">if (lf.f == NULL) return errfile(L, &quot;open&quot;, fnameindex);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">c = getc(lf.f);</span><br><span class="line">    </span><br><span class="line">if (c == &amp;#8216;#&amp;#8217;) &#123; /\* Unix exec. file? \*/</span><br><span class="line">      </span><br><span class="line">lf.extraline = 1;</span><br><span class="line">      </span><br><span class="line">while ((c = getc(lf.f)) != EOF &amp;&amp; c != &amp;#8216;\n&amp;#8217;) ; /\* skip first line \*/</span><br><span class="line">      </span><br><span class="line">if (c == &amp;#8216;\n&amp;#8217;) c = getc(lf.f);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后会判断是否是lua字节码文件，通过文件头的magic number(<esc>Lua),如果是，则用二进制打开。</esc></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">if (c == LUA_SIGNATURE[0] &amp;&amp; filename) &#123; /\* binary file? \*/</span><br><span class="line">      </span><br><span class="line">lf.f = freopen(filename, &quot;rb&quot;, lf.f); /\* reopen in binary mode \*/</span><br><span class="line">      </span><br><span class="line">if (lf.f == NULL) return errfile(L, &quot;reopen&quot;, fnameindex);</span><br><span class="line">      </span><br><span class="line">/\* skip eventual \`#!&amp;#8230;&amp;#8217; \*/</span><br><span class="line">     </span><br><span class="line">while ((c = getc(lf.f)) != EOF &amp;&amp; c != LUA_SIGNATURE[0]) ;</span><br><span class="line">      </span><br><span class="line">lf.extraline = 0;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是调用lua_load来load文件。这里有一个结构要注意，那就是zio，这个结构就是一个parse的结构。这里的reader就是一个回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct Zio &#123;</span><br><span class="line">    </span><br><span class="line">size_t n; /\* bytes still unread \*/</span><br><span class="line">    </span><br><span class="line">const char \*p; /\* current position in buffer */</span><br><span class="line">    </span><br><span class="line">lua_Reader reader;</span><br><span class="line">    </span><br><span class="line">void\* data; /\* additional data */</span><br><span class="line">    </span><br><span class="line">lua_State \*L; /\* Lua state (for reader) */</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看看这个结构如何被初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaZ_init (lua_State \*L, ZIO \*z, lua_Reader reader, void *data) &#123;</span><br><span class="line">    </span><br><span class="line">z-&gt;L = L;</span><br><span class="line">    </span><br><span class="line">z-&gt;reader = reader;</span><br><span class="line">    </span><br><span class="line">z-&gt;data = data;</span><br><span class="line">    </span><br><span class="line">z-&gt;n = 0;</span><br><span class="line">    </span><br><span class="line">z-&gt;p = NULL;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看看lua的BNF</p>
<blockquote>
<p>chunk ::= {stat [`;´]} [laststat [`;´]] block ::= chunk stat ::= varlist `=´ explist | functioncall | do block end | while exp do block end | repeat block until exp | if exp then block {elseif exp then block} [else block] end | for Name `=´ exp `,´ exp [`,´ exp] do block end | for namelist in explist do block end | function funcname funcbody | local function Name funcbody | local namelist [`=´ explist] laststat ::= return [explist] | break funcname ::= Name {`.´ Name} [`:´ Name] varlist ::= var {`,´ var} var ::= Name | prefixexp `[´ exp `]´ | prefixexp `.´ Name namelist ::= Name {`,´ Name} explist ::= {exp `,´} exp exp ::= nil | false | true | Number | String | `&#8230;´ | function | prefixexp | tableconstructor | exp binop exp | unop exp prefixexp ::= var | functioncall | `(´ exp `)´ functioncall ::= prefixexp args | prefixexp `:´ Name args args ::= `(´ [explist] `)´ | tableconstructor | String function ::= function funcbody funcbody ::= `(´ [parlist] `)´ block end parlist ::= namelist [`,´ `&#8230;´] | `&#8230;´ tableconstructor ::= `{´ [fieldlist] `}´ fieldlist ::= field {fieldsep field} [fieldsep] field ::= `[´ exp `]´ `=´ exp | Name `=´ exp | exp fieldsep ::= `,´ | `;´ binop ::= `+´ | `-´ | `*´ | `/´ | `^´ | `%´ | `..´ | `&lt;´ | `&lt;=´ | `]]&gt;´ | `&gt;=´ | `==´ | `~=´ | and | or unop ::= `-´ | not | `#´</p>
</blockquote>
<p>可以看到reader就是被初始化为getF，而data是被初始化位上面的LoadF结构，然后就是调用luaD_protectedparser来parse源代码。</p>
<p>在初始化的时候调用luaX_init将保留关键字作为字符串放入全局的string hash中(ts-&gt;reserved)，因此当解析到字符串时，能够很容易的到当前字符串的类型。</p>
<p>解析函数是luaY_parser, 而核心的parse方法是llex，这个函数会返回对应的token，然后根据解析出来的token，来决定接下来理应是什么符号(核心在chunk函数里面,这函数有一个循环), 然后每次都会调用luaX_next函数，来继续解析(它会调用llex). </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">Proto \*luaY_parser (lua_State \*L, ZIO \*z, Mbuffer \*buff, const char *name) &#123;</span><br><span class="line">    </span><br><span class="line">struct LexState lexstate;</span><br><span class="line">    </span><br><span class="line">struct FuncState funcstate;</span><br><span class="line">    </span><br><span class="line">lexstate.buff = buff;</span><br><span class="line">    </span><br><span class="line">luaX_setinput(L, &amp;lexstate, z, luaS_new(L, name));</span><br><span class="line">    </span><br><span class="line">open_func(&amp;lexstate, &amp;funcstate);</span><br><span class="line">    </span><br><span class="line">funcstate.f-&gt;is_vararg = VARARG_ISVARARG; /\* main func. is always vararg \*/</span><br><span class="line">    </span><br><span class="line">luaX_next(&amp;lexstate); /\* read first token \*/</span><br><span class="line">    </span><br><span class="line">chunk(&amp;lexstate);</span><br><span class="line">    </span><br><span class="line">check(&amp;lexstate, TK_EOS);</span><br><span class="line">    </span><br><span class="line">close_func(&amp;lexstate);</span><br><span class="line">    </span><br><span class="line">lua_assert(funcstate.prev == NULL);</span><br><span class="line">    </span><br><span class="line">lua_assert(funcstate.f-&gt;nups == 0);</span><br><span class="line">    </span><br><span class="line">lua_assert(lexstate.fs == NULL);</span><br><span class="line">    </span><br><span class="line">return funcstate.f;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到最终luaY_parser返回的是一个proto，也就是说每一个lua文件也就相当于一个proto(函数).</p>
<p>下面湿核心的chunk方法.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void chunk (LexState *ls) &#123;</span><br><span class="line">    </span><br><span class="line">/\* chunk -&gt; &#123; stat [\`;&amp;#8217;] &#125; \*/</span><br><span class="line">    </span><br><span class="line">int islast = 0;</span><br><span class="line">    </span><br><span class="line">enterlevel(ls);</span><br><span class="line">    </span><br><span class="line">while (!islast &amp;&amp; !block_follow(ls-&gt;t.token)) &#123;</span><br><span class="line">      </span><br><span class="line">islast = statement(ls);</span><br><span class="line">      </span><br><span class="line">testnext(ls, &amp;#8216;;&amp;#8217;);</span><br><span class="line">      </span><br><span class="line">lua_assert(ls-&gt;fs-&gt;f-&gt;maxstacksize &gt;= ls-&gt;fs-&gt;freereg &amp;&amp;</span><br><span class="line">                 </span><br><span class="line">ls-&gt;fs-&gt;freereg &gt;= ls-&gt;fs-&gt;nactvar);</span><br><span class="line">      </span><br><span class="line">ls-&gt;fs-&gt;freereg = ls-&gt;fs-&gt;nactvar; /\* free registers \*/</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">leavelevel(ls);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lua里面token定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">enum RESERVED &#123;</span><br><span class="line">    </span><br><span class="line">/\* terminal symbols denoted by reserved words \*/</span><br><span class="line">    </span><br><span class="line">TK_AND = FIRST_RESERVED, TK_BREAK,</span><br><span class="line">    </span><br><span class="line">TK_DO, TK_ELSE, TK_ELSEIF, TK_END, TK_FALSE, TK_FOR, TK_FUNCTION,</span><br><span class="line">    </span><br><span class="line">TK_IF, TK_IN, TK_LOCAL, TK_NIL, TK_NOT, TK_OR, TK_REPEAT,</span><br><span class="line">    </span><br><span class="line">TK_RETURN, TK_THEN, TK_TRUE, TK_UNTIL, TK_WHILE,</span><br><span class="line">    </span><br><span class="line">/\* other terminal symbols \*/</span><br><span class="line">    </span><br><span class="line">TK_CONCAT, TK_DOTS, TK_EQ, TK_GE, TK_LE, TK_NE, TK_NUMBER,</span><br><span class="line">    </span><br><span class="line">TK_NAME, TK_STRING, TK_EOS</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上方是关键字，而下方是其他的一些终结符。</p>
<p>核心的parse结构LexState，它主要是用于parse期间保存状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct LexState &#123;</span><br><span class="line">    </span><br><span class="line">int current; /\* current character (charint) \*/</span><br><span class="line">    </span><br><span class="line">int linenumber; /\* input line counter \*/</span><br><span class="line">    </span><br><span class="line">int lastline; /\* line of last token \`consumed&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">Token t; /\* current token \*/</span><br><span class="line">  </span><br><span class="line">//表示前一个token</span><br><span class="line">    </span><br><span class="line">Token lookahead; /\* look ahead token \*/</span><br><span class="line">    </span><br><span class="line">struct FuncState \*fs; /\* \`FuncState&amp;#8217; is private to the parser */</span><br><span class="line">    </span><br><span class="line">struct lua_State *L;</span><br><span class="line">    </span><br><span class="line">ZIO \*z; /\* input stream */</span><br><span class="line">    </span><br><span class="line">Mbuffer \*buff; /\* buffer for tokens */</span><br><span class="line">    </span><br><span class="line">TString \*source; /\* current source name */</span><br><span class="line">    </span><br><span class="line">char decpoint; /\* locale decimal point \*/</span><br><span class="line">  </span><br><span class="line">&#125; LexState;</span><br></pre></td></tr></table></figure>
<p>上面这个结构中最需要注意的是Token结构，这个结构保存了对应的解析出来的token。seminfo保存了经过词法解析后的词(不包括运算符以及[]等),只包括字母以及数字number and string。在lua中所有的tiken分为13类，也就是BNF中的binop(不包括and or)+各种关键字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef union &#123;</span><br><span class="line">    </span><br><span class="line">lua_Number r;</span><br><span class="line">    </span><br><span class="line">TString *ts;</span><br><span class="line">  </span><br><span class="line">&#125; SemInfo; /\* semantics information \*/</span><br><span class="line"></span><br><span class="line">typedef struct Token &#123;</span><br><span class="line">    </span><br><span class="line">int token;</span><br><span class="line">    </span><br><span class="line">SemInfo seminfo;</span><br><span class="line">  </span><br><span class="line">&#125; Token;</span><br></pre></td></tr></table></figure>
<p>然后就是每个解析出来的函数的数据结构，这个结构保存了解析到的函数的状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct FuncState &#123;</span><br><span class="line">    </span><br><span class="line">Proto \*f; /\* current function header */</span><br><span class="line">    </span><br><span class="line">Table \*h; /\* table to find (and reuse) elements in \`k&amp;#8217; */</span><br><span class="line">    </span><br><span class="line">struct FuncState \*prev; /\* enclosing function */</span><br><span class="line">    </span><br><span class="line">struct LexState \*ls; /\* lexical state */</span><br><span class="line">    </span><br><span class="line">struct lua_State \*L; /\* copy of the Lua state */</span><br><span class="line">    </span><br><span class="line">struct BlockCnt \*bl; /\* chain of current blocks */</span><br><span class="line">    </span><br><span class="line">int pc; /\* next position to code (equivalent to \`ncode&amp;#8217;) \*/</span><br><span class="line">    </span><br><span class="line">int lasttarget; /\* \`pc&amp;#8217; of last \`jump target&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">int jpc; /\* list of pending jumps to \`pc&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">int freereg; /\* first free register \*/</span><br><span class="line">    </span><br><span class="line">int nk; /\* number of elements in \`k&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">int np; /\* number of elements in \`p&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">short nlocvars; /\* number of elements in \`locvars&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">lu_byte nactvar; /\* number of active local variables \*/</span><br><span class="line">    </span><br><span class="line">upvaldesc upvalues[LUAI_MAXUPVALUES]; /\* upvalues \*/</span><br><span class="line">    </span><br><span class="line">unsigned short actvar[LUAI_MAXVARS]; /\* declared-variable stack \*/</span><br><span class="line">  </span><br><span class="line">&#125; FuncState;</span><br></pre></td></tr></table></figure>
<p>上面这几个结构的初始化都是放在luaY_parser中的，llex方法其实只是一个词法扫描器，它只负责扫描符号以及单词，然后它会将扫描到的符号交给后续的语法分析器去判断。</p>
<p>其中luaX_setinput用于初始化设置lexState的一些输入属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void luaX_setinput (lua_State \*L, LexState \*ls, ZIO \*z, TString \*source) &#123;</span><br><span class="line">    </span><br><span class="line">ls-&gt;decpoint = &amp;#8216;.&amp;#8217;;</span><br><span class="line">    </span><br><span class="line">ls-&gt;L = L;</span><br><span class="line">  </span><br><span class="line">//前一个token</span><br><span class="line">    </span><br><span class="line">ls-&gt;lookahead.token = TK_EOS; /\* no look-ahead token \*/</span><br><span class="line">    </span><br><span class="line">ls-&gt;z = z;</span><br><span class="line">    </span><br><span class="line">ls-&gt;fs = NULL;</span><br><span class="line">    </span><br><span class="line">ls-&gt;linenumber = 1;</span><br><span class="line">    </span><br><span class="line">ls-&gt;lastline = 1;</span><br><span class="line">    </span><br><span class="line">ls-&gt;source = source;</span><br><span class="line">    </span><br><span class="line">luaZ_resizebuffer(ls-&gt;L, ls-&gt;buff, LUA_MINBUFFER); /\* initialize buffer \*/</span><br><span class="line">  </span><br><span class="line">//第一次读取token</span><br><span class="line">    </span><br><span class="line">next(ls); /\* read first char \*/</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而open_func函数则是新建一个func对象.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void open_func (LexState \*ls, FuncState \*fs) &#123;</span><br><span class="line">    </span><br><span class="line">lua_State *L = ls-&gt;L;</span><br><span class="line">    </span><br><span class="line">Proto *f = luaF_newproto(L);</span><br><span class="line">    </span><br><span class="line">fs-&gt;f = f;</span><br><span class="line">    </span><br><span class="line">fs-&gt;prev = ls-&gt;fs; /\* linked list of funcstates \*/</span><br><span class="line">    </span><br><span class="line">fs-&gt;ls = ls;</span><br><span class="line">    </span><br><span class="line">fs-&gt;L = L;</span><br><span class="line">    </span><br><span class="line">ls-&gt;fs = fs;</span><br><span class="line">    </span><br><span class="line">fs-&gt;pc = 0;</span><br><span class="line">    </span><br><span class="line">fs-&gt;lasttarget = -1;</span><br><span class="line">    </span><br><span class="line">fs-&gt;jpc = NO_JUMP;</span><br><span class="line">    </span><br><span class="line">fs-&gt;freereg = 0;</span><br><span class="line">    </span><br><span class="line">fs-&gt;nk = 0;</span><br><span class="line">    </span><br><span class="line">fs-&gt;np = 0;</span><br><span class="line">    </span><br><span class="line">fs-&gt;nlocvars = 0;</span><br><span class="line">    </span><br><span class="line">fs-&gt;nactvar = 0;</span><br><span class="line">    </span><br><span class="line">fs-&gt;bl = NULL;</span><br><span class="line">    </span><br><span class="line">f-&gt;source = ls-&gt;source;</span><br><span class="line">    </span><br><span class="line">f-&gt;maxstacksize = 2; /\* registers 0/1 are always valid \*/</span><br><span class="line">    </span><br><span class="line">fs-&gt;h = luaH_new(L, 0, 0);</span><br><span class="line">    </span><br><span class="line">/\* anchor table of constants and prototype (to avoid being collected) \*/</span><br><span class="line">    </span><br><span class="line">sethvalue2s(L, L-&gt;top, fs-&gt;h);</span><br><span class="line">    </span><br><span class="line">incr_top(L);</span><br><span class="line">    </span><br><span class="line">setptvalue2s(L, L-&gt;top, f);</span><br><span class="line">    </span><br><span class="line">incr_top(L);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后会在statement函数中对语句进行语法解析，然后不同的函数解析不同的语句。</p>
<p>assignment函数用于解析赋值语法，而它会调用exploits1，explist1对应的解析 explist1 -&gt; expr { `,&#8217; expr } ，因此在它里面就会调用expr函数，而在expr中是直接调用subexpr函数，它主要是解析这类语法subexpr -&gt; (simpleexp | unop subexpr) { binop subexpr } . 因此在subexpr中就会调用三个函数，分别是simpleexp (simpleexp -&gt; NUMBER | STRING | NIL | true | false | … | constructor | FUNCTION body | primaryexp)， getunopr来解析一元操作符，getbinopr来解析二元操作符。 在simpleexp中，则会调用primaryexp来解析 primaryexp -&gt; prefixexp { `.&#8217; NAME | `[&#8216; exp `]&#8217; | `:&#8217; NAME funcargs | funcargs } 这类语法。</p>
<p>每次使用checknext方法来检测下一个token是否是期望的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void check (LexState *ls, int c) &#123;</span><br><span class="line">    </span><br><span class="line">if (ls-&gt;t.token != c)</span><br><span class="line">      </span><br><span class="line">error_expected(ls, c);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void checknext (LexState *ls, int c) &#123;</span><br><span class="line">    </span><br><span class="line">check(ls, c);</span><br><span class="line">    </span><br><span class="line">luaX_next(ls);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lua的自顶向下的解析最核心的就是lcode.c 和lparse.c.其中lua对待一个文件就是把这个文件当做一个函数，因此在解析完毕之后，返回的就是一个proto指针。对应的lparse是解析lua源代码，而lcode.c则将对应的源码翻译为虚拟机指令(保存在proto的code数组中).</p>
<p>在lua中每一个表达式解析完毕后就表示为一个这样的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct expdesc &#123;</span><br><span class="line">    </span><br><span class="line">expkind k;</span><br><span class="line">    </span><br><span class="line">union &#123;</span><br><span class="line">      </span><br><span class="line">struct &#123; int info, aux; &#125; s;</span><br><span class="line">      </span><br><span class="line">lua_Number nval;</span><br><span class="line">    </span><br><span class="line">&#125; u;</span><br><span class="line">    </span><br><span class="line">int t; /\* patch list of \`exit when true&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">int f; /\* patch list of \`exit when false&amp;#8217; \*/</span><br><span class="line">  </span><br><span class="line">&#125; expdesc;</span><br></pre></td></tr></table></figure>
<p>这里最重要的就是联合体u，其中info表示语句对应的索引(在指令数组code(proto结构体)中).或者说表示为对应constant 的索引(proto的TValue *k这个数组的索引).这就体现了程序是由数据+指令组成。</p>
<p>lua的虚拟机指令的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/*===========================================================================</span><br><span class="line">    </span><br><span class="line">We assume that instructions are unsigned numbers.</span><br><span class="line">    </span><br><span class="line">All instructions have an opcode in the first 6 bits.</span><br><span class="line">    </span><br><span class="line">Instructions can have the following fields:</span><br><span class="line">   </span><br><span class="line">\`A&amp;#8217; : 8 bits</span><br><span class="line">   </span><br><span class="line">\`B&amp;#8217; : 9 bits</span><br><span class="line">   </span><br><span class="line">\`C&amp;#8217; : 9 bits</span><br><span class="line">   </span><br><span class="line">\`Bx&amp;#8217; : 18 bits (\`B&amp;#8217; and \`C&amp;#8217; together)</span><br><span class="line">   </span><br><span class="line">\`sBx&amp;#8217; : signed Bx</span><br><span class="line"></span><br><span class="line">A signed argument is represented in excess K; that is, the number</span><br><span class="line">    </span><br><span class="line">value is the unsigned value minus K. K is exactly the maximum value</span><br><span class="line">    </span><br><span class="line">for that argument (so that -max is represented by 0, and +max is</span><br><span class="line">    </span><br><span class="line">represented by 2*max), which is half the maximum for the corresponding</span><br><span class="line">    </span><br><span class="line">unsigned argument.</span><br><span class="line">  </span><br><span class="line">===========================================================================*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">enum OpMode &#123;iABC, iABx, iAsBx&#125;; /\* basic instruction format \*/</span><br></pre></td></tr></table></figure>
<p>可以看到也就是3种指令，而下面的宏定义了指令的参数以及opcode的大小以及偏移，这里可以看到在lua里面所有的指令都是定长的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">#define SIZE_C9</span><br><span class="line">  </span><br><span class="line">#define SIZE_B9</span><br><span class="line">  </span><br><span class="line">#define SIZE_Bx(SIZE_C + SIZE_B)</span><br><span class="line">  </span><br><span class="line">#define SIZE_A8</span><br><span class="line"></span><br><span class="line">#define SIZE_OP6</span><br><span class="line"></span><br><span class="line">#define POS_OP0</span><br><span class="line">  </span><br><span class="line">#define POS_A(POS_OP + SIZE_OP)</span><br><span class="line">  </span><br><span class="line">#define POS_C(POS_A + SIZE_A)</span><br><span class="line">  </span><br><span class="line">#define POS_B(POS_C + SIZE_C)</span><br><span class="line">  </span><br><span class="line">#define POS_BxPOS_C</span><br></pre></td></tr></table></figure>
<p>再接下来就是如何取得对应的opcode以及各个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">/\* creates a mask with \`n&amp;#8217; 1 bits at position \`p&amp;#8217; \*/</span><br><span class="line">  </span><br><span class="line">#define MASK1(n,p)((~((~(Instruction)0)&lt;&lt;n))&lt;&lt;p)</span><br><span class="line"></span><br><span class="line">/\* creates a mask with \`n&amp;#8217; 0 bits at position \`p&amp;#8217; \*/</span><br><span class="line">  </span><br><span class="line">#define MASK0(n,p)(~MASK1(n,p))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  </span><br><span class="line">** the following macros help to manipulate instructions</span><br><span class="line">  </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#define GET_OPCODE(i)(cast(OpCode, ((i)&gt;&gt;POS_OP) &amp; MASK1(SIZE_OP,0)))</span><br><span class="line">  </span><br><span class="line">#define SET_OPCODE(i,o)((i) = (((i)&amp;MASK0(SIZE_OP,POS_OP)) | \</span><br><span class="line">    </span><br><span class="line">((cast(Instruction, o)&lt;&lt;POS_OP)&amp;MASK1(SIZE_OP,POS_OP))))</span><br></pre></td></tr></table></figure>
<p>对应的上面就是如何取得对应指令 opcode的宏。下面就是所有的opcode类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef enum &#123;</span><br><span class="line">  </span><br><span class="line">/*&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;-</span><br><span class="line">  </span><br><span class="line">nameargsdescription</span><br><span class="line">  </span><br><span class="line">&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;*/</span><br><span class="line">  </span><br><span class="line">OP_MOVE,/\*A BR(A) := R(B)\*/</span><br><span class="line">  </span><br><span class="line">OP_LOADK,/\*A BxR(A) := Kst(Bx)\*/</span><br><span class="line">  </span><br><span class="line">OP_LOADBOOL,/\*A B CR(A) := (Bool)B; if (C) pc++\*/</span><br><span class="line">  </span><br><span class="line">OP_LOADNIL,/\*A BR(A) := &amp;#8230; := R(B) := nil\*/</span><br><span class="line">  </span><br><span class="line">OP_GETUPVAL,/\*A BR(A) := UpValue[B]\*/</span><br><span class="line"></span><br><span class="line">OP_GETGLOBAL,/\*A BxR(A) := Gbl[Kst(Bx)]\*/</span><br><span class="line">  </span><br><span class="line">OP_GETTABLE,/\*A B CR(A) := R(B)[RK(C)]\*/</span><br><span class="line"></span><br><span class="line">OP_SETGLOBAL,/\*A BxGbl[Kst(Bx)] := R(A)\*/</span><br><span class="line">  </span><br><span class="line">OP_SETUPVAL,/\*A BUpValue[B] := R(A)\*/</span><br><span class="line">  </span><br><span class="line">OP_SETTABLE,/\*A B CR(A)[RK(B)] := RK©\*/</span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,/\*A B CR(A) := &#123;&#125; (size = B,C)\*/</span><br><span class="line"></span><br><span class="line">OP_SELF,/\*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]\*/</span><br><span class="line"></span><br><span class="line">OP_ADD,/\*A B CR(A) := RK(B) + RK©\*/</span><br><span class="line">  </span><br><span class="line">OP_SUB,/\*A B CR(A) := RK(B) &amp;#8211; RK©\*/</span><br><span class="line">  </span><br><span class="line">OP_MUL,/\*A B CR(A) := RK(B) \* RK©*/</span><br><span class="line">  </span><br><span class="line">OP_DIV,/\*A B CR(A) := RK(B) / RK©\*/</span><br><span class="line">  </span><br><span class="line">OP_MOD,/\*A B CR(A) := RK(B) % RK©\*/</span><br><span class="line">  </span><br><span class="line">OP_POW,/\*A B CR(A) := RK(B) ^ RK©\*/</span><br><span class="line">  </span><br><span class="line">OP_UNM,/\*A BR(A) := -R(B)\*/</span><br><span class="line">  </span><br><span class="line">OP_NOT,/\*A BR(A) := not R(B)\*/</span><br><span class="line">  </span><br><span class="line">OP_LEN,/\*A BR(A) := length of R(B)\*/</span><br><span class="line"></span><br><span class="line">OP_CONCAT,/\*A B CR(A) := R(B).. &amp;#8230; ..R©\*/</span><br><span class="line"></span><br><span class="line">OP_JMP,/\*sBxpc+=sBx\*/</span><br><span class="line"></span><br><span class="line">OP_EQ,/\*A B Cif ((RK(B) == RK(C)) ~= A) then pc++\*/</span><br><span class="line">  </span><br><span class="line">OP_LT,/\*A B Cif ((RK(B) &lt; RK(C)) ~= A) then pc++ \*/</span><br><span class="line">  </span><br><span class="line">OP_LE,/\*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++ \*/</span><br><span class="line"></span><br><span class="line">OP_TEST,/\*A Cif not (R(A) &lt;=&gt; C) then pc++\*/</span><br><span class="line">  </span><br><span class="line">OP_TESTSET,/\*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++\*/ </span><br><span class="line"></span><br><span class="line">OP_CALL,/\*A B CR(A), &amp;#8230; ,R(A+C-2) := R(A)(R(A+1), &amp;#8230; ,R(A+B-1)) \*/</span><br><span class="line">  </span><br><span class="line">OP_TAILCALL,/\*A B Creturn R(A)(R(A+1), &amp;#8230; ,R(A+B-1))\*/</span><br><span class="line">  </span><br><span class="line">OP_RETURN,/\*A Breturn R(A), &amp;#8230; ,R(A+B-2)(see note)\*/</span><br><span class="line"></span><br><span class="line">OP_FORLOOP,/*A sBxR(A)+=R(A+2);</span><br><span class="line">     </span><br><span class="line">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span><br><span class="line">  </span><br><span class="line">OP_FORPREP,/\*A sBxR(A)-=R(A+2); pc+=sBx\*/</span><br><span class="line"></span><br><span class="line">OP_TFORLOOP,/*A CR(A+3), &amp;#8230; ,R(A+2+C) := R(A)(R(A+1), R(A+2));</span><br><span class="line">                          </span><br><span class="line">if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++*/</span><br><span class="line">  </span><br><span class="line">OP_SETLIST,/\*A B CR(A)[(C-1)\*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span><br><span class="line"></span><br><span class="line">OP_CLOSE,/\*A close all variables in the stack up to (&gt;=) R(A)\*/</span><br><span class="line">  </span><br><span class="line">OP_CLOSURE,/\*A BxR(A) := closure(KPROTO[Bx], R(A), &amp;#8230; ,R(A+n))\*/</span><br><span class="line"></span><br><span class="line">OP_VARARG/\*A BR(A), R(A+1), &amp;#8230;, R(A+B-1) = vararg\*/</span><br><span class="line">  </span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure>
<p>然后我们来看一个最简单的语句是如何解析进lua的虚拟机的，假设有一条 local t = 3 的语句。这个会通过parse进入localstat，然后调用new_localvar来新建一个local变量，所有的local变量都放在Proto结构的f-&gt;locvars中，locvars也就是一个数组 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct LocVar \*locvars; /\* information about local variables */</span><br></pre></td></tr></table></figure>
<p>而对应的数组索引放到FuncState的actvar数组中。因为在lua中可以这么写local t, t1 = 3。解析完毕名字之后，就开始解析=，解析=会在explist1函数中进行。然后会讲解析掉的数字3 放入到表达式(expdesc)的nval域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">typedef struct expdesc &#123;</span><br><span class="line">    </span><br><span class="line">expkind k;</span><br><span class="line">    </span><br><span class="line">union &#123;</span><br><span class="line">      </span><br><span class="line">struct &#123; int info, aux; &#125; s;</span><br><span class="line">      </span><br><span class="line">lua_Number nval;</span><br><span class="line">    </span><br><span class="line">&#125; u;</span><br><span class="line">    </span><br><span class="line">int t; /\* patch list of \`exit when true&amp;#8217; \*/</span><br><span class="line">    </span><br><span class="line">int f; /\* patch list of \`exit when false&amp;#8217; \*/</span><br><span class="line">  </span><br><span class="line">&#125; expdesc;</span><br><span class="line"></span><br><span class="line">case TK_NUMBER: &#123;</span><br><span class="line">        </span><br><span class="line">init_exp(v, VKNUM, 0);</span><br><span class="line">        </span><br><span class="line">v-&gt;u.nval = ls-&gt;t.seminfo.r;</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到直接赋值给nval。</p>
<p>然后就是adjust_assign以及adjustlocalvars两个函数，其中adjust_assign将会调用luaK_exp2nextreg函数，而在这个函数中则会调用discharge2reg函数来设置对应的指令， 这里比较关键的，就是lua如何来选择寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void luaK_reserveregs (FuncState *fs, int n) &#123;</span><br><span class="line">    </span><br><span class="line">luaK_checkstack(fs, n);</span><br><span class="line">    </span><br><span class="line">fs-&gt;freereg += n;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void luaK_exp2nextreg (FuncState \*fs, expdesc \*e) &#123;</span><br><span class="line">    </span><br><span class="line">luaK_dischargevars(fs, e);</span><br><span class="line">    </span><br><span class="line">freeexp(fs, e);</span><br><span class="line">    </span><br><span class="line">luaK_reserveregs(fs, 1);</span><br><span class="line">    </span><br><span class="line">exp2reg(fs, e, fs-&gt;freereg &amp;#8211; 1);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void exp2reg (FuncState \*fs, expdesc \*e, int reg) &#123;</span><br><span class="line">    </span><br><span class="line">discharge2reg(fs, e, reg);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void discharge2reg (FuncState \*fs, expdesc \*e, int reg) &#123;</span><br><span class="line">    </span><br><span class="line">luaK_dischargevars(fs, e);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">      </span><br><span class="line">case VKNUM: &#123;</span><br><span class="line">        </span><br><span class="line">luaK_codeABx(fs, OP_LOADK, reg, luaK_numberK(fs, e-&gt;u.nval));</span><br><span class="line">        </span><br><span class="line">break;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">    </span><br><span class="line">e-&gt;u.s.info = reg;</span><br><span class="line">    </span><br><span class="line">e-&gt;k = VNONRELOC;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面我们可以看到寄存器的选择是通过funcstate的freereg域来进行选择的。最终我们可以看到当字节码生成之后，e-&gt;u.s.info中放的就是寄存器了。而在一开始进入luaK_exp2nextreg之后，立即对freereg进行+1,这里寄存器我们可以看做是一个索引.</p>
<p>接下来我们来看luaK_numberK的实现，也就是lua会把constant放到哪里去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">int luaK_numberK (FuncState *fs, lua_Number r) &#123;</span><br><span class="line">    </span><br><span class="line">TValue o;</span><br><span class="line">    </span><br><span class="line">setnvalue(&amp;o, r);</span><br><span class="line">    </span><br><span class="line">return addk(fs, &amp;o, &amp;o);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static int addk (FuncState *fs, TValue *k, TValue *v) {</p>
<p>lua_State *L = fs-&gt;L;</p>
<p>TValue *idx = luaH_set(L, fs-&gt;h, k);</p>
<p>Proto *f = fs-&gt;f;</p>
<p>int oldsize = f-&gt;sizek;</p>
<p>if (ttisnumber(idx)) {</p>
<p>lua_assert(luaO_rawequalObj(&amp;fs-&gt;f-&gt;k[cast_int(nvalue(idx))], v));</p>
<p>return cast_int(nvalue(idx));</p>
<p>}</p>
<p>else { /* constant not found; create a new entry */</p>
<p>setnvalue(idx, cast_num(fs-&gt;nk));</p>
<p>luaM_growvector(L, f-&gt;k, fs-&gt;nk, f-&gt;sizek, TValue,</p>
<p>MAXARG_Bx, “constant table overflow”);</p>
<p>while (oldsize &lt; f-&gt;sizek) setnilvalue(&amp;f-&gt;k[oldsize++]);</p>
<p>//存储值</p>
<p>setobj(L, &amp;f-&gt;k[fs-&gt;nk], v);</p>
<p>luaC_barrier(L, f, v);</p>
<p>return fs-&gt;nk++;</p>
<p>}</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到最终值会放到f-&gt;k这个数组中。并且会返回对应的索引，然后讲索引保存到字节码中。</span><br><span class="line"></span><br><span class="line">这个时候可以看到这条语句对应的字节码是LOADK, 而loadk对应的指令类型是ABx，我们来看对应的域都填充的是什么。</span><br></pre></td></tr></table></figure>
<p>int luaK_codeABx (FuncState *fs, OpCode o, int a, unsigned int bc) {</p>
<p>lua_assert(getOpMode(o) == iABx || getOpMode(o) == iAsBx);</p>
<p>lua_assert(getCMode(o) == OpArgN);</p>
<p>return luaK_code(fs, CREATE_ABx(o, a, bc), fs-&gt;ls-&gt;lastline);</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到对应的a填充到ABx类型的A，而bc则填充到bx域，而a是什么呢？通过上面的代码可以看到a就是寄存器，bc就是对应的值.也就是说讲3这个值放到bx，而把t对应的寄存器 放到a域.字节码生成了。</span><br><span class="line"></span><br><span class="line">然后看来luaK_code这个函数,他也就是讲指令放入到proto结构体的code数组中</span><br></pre></td></tr></table></figure>
<p>static int luaK_code (FuncState *fs, Instruction i, int line) {</p>
<p>Proto *f = fs-&gt;f;</p>
<p>dischargejpc(fs); /* `pc&#8217; will change */</p>
<p>/* put new instruction in code array */</p>
<p>luaM_growvector(fs-&gt;L, f-&gt;code, fs-&gt;pc, f-&gt;sizecode, Instruction,</p>
<p>MAX_INT, “code size overflow”);</p>
<p>f-&gt;code[fs-&gt;pc] = i;</p>
<p>/* save corresponding line information */</p>
<p>luaM_growvector(fs-&gt;L, f-&gt;lineinfo, fs-&gt;pc, f-&gt;sizelineinfo, int,</p>
<p>MAX_INT, “code size overflow”);</p>
<p>f-&gt;lineinfo[fs-&gt;pc] = line;</p>
<p>return fs-&gt;pc++;</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接下来我们来看lua虚拟机会如何来解析字节码。</span><br><span class="line"></span><br><span class="line">所有的解析都在luaV_execute中。来看对应的代码, luaV_execute也就是会通过遍历L-&gt;code(索引在savedpc中)来执行所有的字节码。</span><br></pre></td></tr></table></figure>
<p>void luaV_execute (lua_State *L) {</p>
<p>CallInfo *ci = L-&gt;ci;</p>
<p>&#8230;&#8230;&#8230;&#8230;&#8230;..</p>
<p>pc = L-&gt;savedpc;</p>
<p>cl = &amp;clvalue(L-&gt;ci-&gt;func)-&gt;l;</p>
<p>base = L-&gt;base;</p>
<p>//取出constants数组</p>
<p>k = cl-&gt;p-&gt;k;</p>
<p>/* main loop of interpreter */</p>
<p>for (;;) {</p>
<p>const Instruction i = *pc++;</p>
<p>StkId ra;</p>
<p>if ((L-&gt;hookmask &amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;&amp;</p>
<p>(&#8211;L-&gt;hookcount == 0 || L-&gt;hookmask &amp; LUA_MASKLINE)) {</p>
<p>traceexec(L, pc);</p>
<p>if (L-&gt;status == LUA_YIELD) { /* did hook yield? */</p>
<p>L-&gt;savedpc = pc &#8211; 1;</p>
<p>return;</p>
<p>}</p>
<p>base = L-&gt;base;</p>
<p>}</p>
<p>&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;</p>
<p>ra = RA(i);</p>
<p>&#8230;&#8230;&#8230;&#8230;.</p>
<p>case OP_LOADK: {</p>
<p>setobj2s(L, ra, KBx(i));</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里ra就是对应的栈的位置(通过寄存器来确定栈的位置), 然后KBx主要是用于得到对应的值(也就是我们例子中的5).</span><br></pre></td></tr></table></figure>
<p>#define KBx(i) check_exp(getBMode(GET_OPCODE(i)) == OpArgK, k+GETARG_Bx(i))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以看到他是以k = cl-&gt;p-&gt;k;为基准值，然后加上对应的偏移.</span><br><span class="line"></span><br><span class="line">最后我们来看setobj2s这个函数,这个函数其实很简单，就是把从寄存器取出来的值放入到对应的value结构中。</span><br></pre></td></tr></table></figure>
<p>#define setobj(L,obj1,obj2) \</p>
<p>{ const TValue *o2=(obj2); TValue *o1=(obj1); \</p>
<p>o1-&gt;value = o2-&gt;value; o1-&gt;tt=o2-&gt;tt; \</p>
<p>checkliveness(G(L),o1); }</p>
<p><code>`</code></p>
<p>可以看到最终t的值被放入到L-&gt;base为基础的一段内存中。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2013/12/03/lua-source-analysis-(v).html">Lua源码剖析(五)</a><a class="next" href="/2013/05/11/early-retransmit-for-tcp-principle-and-implementation.html">Early Retransmit for TCP原理以及实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>