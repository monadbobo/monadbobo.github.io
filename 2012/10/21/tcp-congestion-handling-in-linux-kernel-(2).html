<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>linux 内核tcp拥塞处理(二) | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">linux 内核tcp拥塞处理(二)</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">linux 内核tcp拥塞处理(二)</h1><div class="post-meta">Oct 21, 2012<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a><a href="/categories/kernel/协议/">协议</a></span></div><div class="post-content"><p>这篇接的是我最早在javaeye的那篇blog. <a href="http://simohayha.iteye.com/blog/614258" target="_blank" rel="noopener">http://simohayha.iteye.com/blog/614258</a></p>
<p>首先我们要知道在linux下分为5个拥塞状态，定义如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">enum tcp_ca_state &#123;</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Open = 0,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Open (1&lt;&lt;TCP_CA_Open)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Disorder = 1,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Disorder (1&lt;&lt;TCP_CA_Disorder)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_CWR = 2,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_CWR (1&lt;&lt;TCP_CA_CWR)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Recovery = 3,</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Recovery (1&lt;&lt;TCP_CA_Recovery)</span><br><span class="line">	  </span><br><span class="line">TCP_CA_Loss = 4</span><br><span class="line">  </span><br><span class="line">#define TCPF_CA_Loss (1&lt;&lt;TCP_CA_Loss)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TCP_CA_OPEN这个就是初始状态，也就是没有检测到任何拥塞的情况.</p>
<p>TCP_CA_Disorder 顾名思义，这个状态就是当第一次由于收到SACK或者重复的ack而检测到拥塞时，就进入这个状态.</p>
<p>TCP_CA_CWR 由于一些拥塞通知事件而导致拥塞窗口减小,然后就会进入这个状态。比如ECN，ICMP，本地设备拥塞。</p>
<p>TCP_CA_Recovery 当CWND减小</p>
<p>TCP_CA_Loss 超时或者SACK被拒绝，此时表示数据包丢失，因此进入这个状态.</p>
<a id="more"></a>
<p>在分析代码之前，先来看一个最重要的数据结构，那就是tcp_sock,这个结构就是下面的拥塞控制所操作的核心数据结构.注释都是非常详细.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">struct tcp_sock &#123;</span><br><span class="line">	  </span><br><span class="line">/\* inet_connection_sock has to be the first member of tcp_sock \*/</span><br><span class="line">	  </span><br><span class="line">struct inet_connection_sock inet_conn;</span><br><span class="line">	  </span><br><span class="line">u16 tcp_header_len; /\* Bytes of tcp header to send \*/</span><br><span class="line">	  </span><br><span class="line">u16 xmit_size_goal_segs; /\* Goal for segmenting output packets \*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   </span><br><span class="line">* Header prediction flags</span><br><span class="line">   </span><br><span class="line">* 0x5?10 &lt;&lt; 16 + snd_wnd in net byte order</span><br><span class="line">   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">__be32 pred_flags;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   </span><br><span class="line">* RFC793 variables by their proper names. This means you can</span><br><span class="line">   </span><br><span class="line">* read the code and the spec side by side (and laugh &amp;#8230;)</span><br><span class="line">   </span><br><span class="line">* See RFC793 and RFC1122. The RFC writes these in capitals.</span><br><span class="line">   </span><br><span class="line">*/</span><br><span class="line"> 	  </span><br><span class="line">u32 rcv_nxt; /\* What we want to receive next \*/</span><br><span class="line">	  </span><br><span class="line">u32 copied_seq; /\* Head of yet unread data \*/</span><br><span class="line">	  </span><br><span class="line">u32 rcv_wup; /\* rcv_nxt on last window update sent \*/</span><br><span class="line"> 	  </span><br><span class="line">u32 snd_nxt; /\* Next sequence we send \*/</span><br><span class="line"></span><br><span class="line">u32 snd_una; /\* First byte we want an ack for \*/</span><br><span class="line"> 	  </span><br><span class="line">u32 snd_sml; /\* Last byte of the most recently transmitted small packet \*/</span><br><span class="line">	  </span><br><span class="line">u32 rcv_tstamp; /\* timestamp of last received ACK (for keepalives) \*/</span><br><span class="line">	  </span><br><span class="line">u32 lsndtime; /\* timestamp of last sent data packet (for restart window) \*/</span><br><span class="line"></span><br><span class="line">/\* Data for direct copy to user \*/</span><br><span class="line">	  </span><br><span class="line">struct &#123;</span><br><span class="line">		  </span><br><span class="line">struct sk_buff_head prequeue;</span><br><span class="line">		  </span><br><span class="line">struct task_struct *task;</span><br><span class="line">		  </span><br><span class="line">struct iovec *iov;</span><br><span class="line">		  </span><br><span class="line">int memory;</span><br><span class="line">		  </span><br><span class="line">int len;</span><br><span class="line">  </span><br><span class="line">#ifdef CONFIG_NET_DMA</span><br><span class="line">		  </span><br><span class="line">/\* members for async copy \*/</span><br><span class="line">		  </span><br><span class="line">struct dma_chan *dma_chan;</span><br><span class="line">		  </span><br><span class="line">int wakeup;</span><br><span class="line">		  </span><br><span class="line">struct dma_pinned_list *pinned_list;</span><br><span class="line">		  </span><br><span class="line">dma_cookie_t dma_cookie;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">	  </span><br><span class="line">&#125; ucopy;</span><br><span class="line"></span><br><span class="line">u32 snd_wl1; /\* Sequence for window update \*/</span><br><span class="line">	  </span><br><span class="line">u32 snd_wnd; /\* The window we expect to receive \*/</span><br><span class="line">	  </span><br><span class="line">u32 max_window; /\* Maximal window ever seen from peer \*/</span><br><span class="line">	  </span><br><span class="line">u32 mss_cache; /\* Cached effective mss, not including SACKS \*/</span><br><span class="line"></span><br><span class="line">u32 window_clamp; /\* Maximal window to advertise \*/</span><br><span class="line">	  </span><br><span class="line">u32 rcv_ssthresh; /\* Current window clamp \*/</span><br><span class="line"></span><br><span class="line">u32 frto_highmark; /\* snd_nxt when RTO occurred \*/</span><br><span class="line">	  </span><br><span class="line">u16 advmss; /\* Advertised MSS \*/</span><br><span class="line">	  </span><br><span class="line">u8 frto_counter; /\* Number of new acks after RTO \*/</span><br><span class="line">	  </span><br><span class="line">u8 nonagle : 4,/\* Disable Nagle algorithm? \*/</span><br><span class="line">		  </span><br><span class="line">thin_lto : 1,/\* Use linear timeouts for thin streams \*/</span><br><span class="line">		  </span><br><span class="line">thin_dupack : 1,/\* Fast retransmit on first dupack \*/</span><br><span class="line">		  </span><br><span class="line">repair : 1,</span><br><span class="line">		  </span><br><span class="line">unused : 1;</span><br><span class="line">	  </span><br><span class="line">u8 repair_queue;</span><br><span class="line">	  </span><br><span class="line">u8 do_early_retrans:1,/\* Enable RFC5827 early-retransmit \*/</span><br><span class="line">		  </span><br><span class="line">early_retrans_delayed:1; /\* Delayed ER timer installed \*/</span><br><span class="line"></span><br><span class="line">/\* RTT measurement \*/</span><br><span class="line">	  </span><br><span class="line">u32 srtt; /\* smoothed round trip time &lt;&lt; 3 \*/</span><br><span class="line">	  </span><br><span class="line">u32 mdev; /\* medium deviation \*/</span><br><span class="line">	  </span><br><span class="line">u32 mdev_max; /\* maximal mdev for the last rtt period \*/</span><br><span class="line">	  </span><br><span class="line">u32 rttvar; /\* smoothed mdev_max \*/</span><br><span class="line">	  </span><br><span class="line">u32 rtt_seq; /\* sequence number to update rttvar \*/</span><br><span class="line"></span><br><span class="line">u32 packets_out; /\* Packets which are &quot;in flight&quot; \*/</span><br><span class="line">	  </span><br><span class="line">u32 retrans_out; /\* Retransmitted packets out \*/</span><br><span class="line"></span><br><span class="line">u16 urg_data; /\* Saved octet of OOB data and control flags \*/</span><br><span class="line">	  </span><br><span class="line">u8 ecn_flags; /\* ECN status bits. \*/</span><br><span class="line">	  </span><br><span class="line">u8 reordering; /\* Packet reordering metric. \*/</span><br><span class="line">	  </span><br><span class="line">u32 snd_up; /\* Urgent pointer \*/</span><br><span class="line"></span><br><span class="line">u8 keepalive_probes; /\* num of allowed keep alive probes \*/</span><br><span class="line">  </span><br><span class="line">/*</span><br><span class="line">   </span><br><span class="line">* Options received (usually on last packet, some only on SYN packets).</span><br><span class="line">   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">struct tcp_options_received rx_opt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">   </span><br><span class="line">* Slow start and congestion control (see also Nagle, and Karn &amp; Partridge)</span><br><span class="line">   </span><br><span class="line">*/</span><br><span class="line"> 	  </span><br><span class="line">u32 snd_ssthresh; /\* Slow start size threshold \*/</span><br><span class="line"> 	  </span><br><span class="line">u32 snd_cwnd; /\* Sending congestion window \*/</span><br><span class="line">	  </span><br><span class="line">u32 snd_cwnd_cnt; /\* Linear increase counter \*/</span><br><span class="line">	  </span><br><span class="line">u32 snd_cwnd_clamp; /\* Do not allow snd_cwnd to grow above this \*/</span><br><span class="line">	  </span><br><span class="line">u32 snd_cwnd_used;</span><br><span class="line">	  </span><br><span class="line">u32 snd_cwnd_stamp;</span><br><span class="line">	  </span><br><span class="line">u32 prior_cwnd; /\* Congestion window at start of Recovery. \*/</span><br><span class="line">	  </span><br><span class="line">u32 prr_delivered; /* Number of newly delivered packets to</span><br><span class="line">				   </span><br><span class="line">\* receiver in Recovery. \*/</span><br><span class="line">	  </span><br><span class="line">u32 prr_out; /\* Total number of pkts sent during Recovery. \*/</span><br><span class="line"></span><br><span class="line">u32 rcv_wnd; /\* Current receiver window \*/</span><br><span class="line">	  </span><br><span class="line">u32 write_seq; /\* Tail(+1) of data held in tcp send buffer \*/</span><br><span class="line">	  </span><br><span class="line">u32 pushed_seq; /\* Last pushed seq, required to talk to windows \*/</span><br><span class="line">	  </span><br><span class="line">u32 lost_out; /\* Lost packets \*/</span><br><span class="line">	  </span><br><span class="line">u32 sacked_out; /\* SACK&amp;#8217;d packets \*/</span><br><span class="line">	  </span><br><span class="line">u32 fackets_out; /\* FACK&amp;#8217;d packets \*/</span><br><span class="line">	  </span><br><span class="line">u32 tso_deferred;</span><br><span class="line">	  </span><br><span class="line">u32 bytes_acked; /\* Appropriate Byte Counting &amp;#8211; RFC3465 \*/</span><br><span class="line"></span><br><span class="line">/\* from STCP, retrans queue hinting \*/</span><br><span class="line">	  </span><br><span class="line">struct sk_buff* lost_skb_hint;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *scoreboard_skb_hint;</span><br><span class="line">	  </span><br><span class="line">struct sk_buff *retransmit_skb_hint;</span><br><span class="line"></span><br><span class="line">struct sk_buff_head out_of_order_queue; /\* Out of order segments go here \*/</span><br><span class="line"></span><br><span class="line">/\* SACKs data, these 2 need to be together (see tcp_options_write) \*/</span><br><span class="line">	  </span><br><span class="line">struct tcp_sack_block duplicate_sack[1]; /\* D-SACK block \*/</span><br><span class="line">	  </span><br><span class="line">struct tcp_sack_block selective_acks[4]; /\* The SACKS themselves\*/</span><br><span class="line"></span><br><span class="line">struct tcp_sack_block recv_sack_cache[4];</span><br><span class="line"></span><br><span class="line">struct sk_buff \*highest_sack; /\* skb just after the highest</span><br><span class="line">					   </span><br><span class="line">* skb with SACKed bit set</span><br><span class="line">					   </span><br><span class="line">* (validity guaranteed only if</span><br><span class="line">					   </span><br><span class="line">* sacked_out &gt; 0)</span><br><span class="line">					   </span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int lost_cnt_hint;</span><br><span class="line">	  </span><br><span class="line">u32 retransmit_high; /\* L-bits may be on up to this seqno \*/</span><br><span class="line"></span><br><span class="line">u32 lost_retrans_low; /\* Sent seq after any rxmit (lowest) \*/</span><br><span class="line"></span><br><span class="line">u32 prior_ssthresh; /\* ssthresh saved at recovery start \*/</span><br><span class="line">	  </span><br><span class="line">u32 high_seq; /\* snd_nxt at onset of congestion \*/</span><br><span class="line"></span><br><span class="line">u32 retrans_stamp; /* Timestamp of the last retransmit,</span><br><span class="line">				   </span><br><span class="line">* also used in SYN-SENT to remember stamp of</span><br><span class="line">				   </span><br><span class="line">\* the first SYN. \*/</span><br><span class="line">	  </span><br><span class="line">u32 undo_marker; /\* tracking retrans started here. \*/</span><br><span class="line">	  </span><br><span class="line">int undo_retrans; /\* number of undoable retransmissions. \*/</span><br><span class="line">	  </span><br><span class="line">u32 total_retrans; /\* Total retransmits for entire connection \*/</span><br><span class="line"></span><br><span class="line">u32 urg_seq; /\* Seq of received urgent pointer \*/</span><br><span class="line">	  </span><br><span class="line">unsigned int keepalive_time; /\* time before keep alive takes place \*/</span><br><span class="line">	  </span><br><span class="line">unsigned int keepalive_intvl; /\* time interval between keep alive probes \*/</span><br><span class="line"></span><br><span class="line">int linger2;</span><br><span class="line"></span><br><span class="line">/\* Receiver side RTT estimation \*/</span><br><span class="line">	  </span><br><span class="line">struct &#123;</span><br><span class="line">		  </span><br><span class="line">u32 rtt;</span><br><span class="line">		  </span><br><span class="line">u32 seq;</span><br><span class="line">		  </span><br><span class="line">u32 time;</span><br><span class="line">	  </span><br><span class="line">&#125; rcv_rtt_est;</span><br><span class="line"></span><br><span class="line">/\* Receiver queue space \*/</span><br><span class="line">	  </span><br><span class="line">struct &#123;</span><br><span class="line">		  </span><br><span class="line">int space;</span><br><span class="line">		  </span><br><span class="line">u32 seq;</span><br><span class="line">		  </span><br><span class="line">u32 time;</span><br><span class="line">	  </span><br><span class="line">&#125; rcvq_space;</span><br><span class="line"></span><br><span class="line">/\* TCP-specific MTU probe information. \*/</span><br><span class="line">	  </span><br><span class="line">struct &#123;</span><br><span class="line">		  </span><br><span class="line">u32 probe_seq_start;</span><br><span class="line">		  </span><br><span class="line">u32 probe_seq_end;</span><br><span class="line">	  </span><br><span class="line">&#125; mtu_probe;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TCP_MD5SIG</span><br><span class="line">  </span><br><span class="line">/\* TCP AF-Specific parts; only used by MD5 Signature support so far \*/</span><br><span class="line">	  </span><br><span class="line">const struct tcp_sock_af_ops *af_specific;</span><br><span class="line"></span><br><span class="line">/\* TCP MD5 Signature Option information \*/</span><br><span class="line">	  </span><br><span class="line">struct tcp_md5sig_info __rcu *md5sig_info;</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* When the cookie options are generated and exchanged, then this</span><br><span class="line">	   </span><br><span class="line">* object holds a reference to them (cookie_values-&gt;kref). Also</span><br><span class="line">	   </span><br><span class="line">* contains related tcp_cookie_transactions fields.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">struct tcp_cookie_values *cookie_values;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最主要的函数就是tcp_fastretrans_alert，进入这个函数的条件:</p>
<blockquote>
<ul>
<li>&#8211; each incoming ACK, if state is not &#8220;Open&#8221;</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>&#8211; when arrived ACK is unusual, namely:</li>
</ul>
</blockquote>
<blockquote>
<p>* * SACK</p>
</blockquote>
<blockquote>
<p>* * Duplicate ACK.</p>
</blockquote>
<blockquote>
<p>* * ECN ECE.</p></blockquote> <p></p>

<p>接下来就看这几个状态是如何变迁的，tcp_fastretrans_alert这个函数我以前的blog有分析过，因此我这里只是用来描述状态变迁相关的函数。</p>
<p>首先状态变迁分为两部分，一部分是进入某些状态，一部分是从某些状态跳出来。首先来分析状态的默认处理，也就是假设是处于Open状态，然后收到了异常的ACK,此时代码是如何处理的.。</p>
<p>这里要注意TCP reno算法是用快重传来模拟SACK，所以如果关闭了SACK那么就需要模拟SACK.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">switch (icsk-&gt;icsk_ca_state) &#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">		  </span><br><span class="line">/\* Loss is undone; fall through to processing in Open state. \*/</span><br><span class="line">  </span><br><span class="line">// 进入下面则有可能是　disorder,open, cwr,loss 这几个状态.</span><br><span class="line">	  </span><br><span class="line">default:</span><br><span class="line">  </span><br><span class="line">//如果SACK关闭，那么就需要模拟SACK</span><br><span class="line">		  </span><br><span class="line">if (tcp_is_reno(tp)) &#123;</span><br><span class="line">			  </span><br><span class="line">if (flag &amp; FLAG_SND_UNA_ADVANCED)</span><br><span class="line">				  </span><br><span class="line">tcp_reset_reno_sack(tp);</span><br><span class="line">			  </span><br><span class="line">if (is_dupack)</span><br><span class="line">				  </span><br><span class="line">tcp_add_reno_sack(sk);</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//从DSACK恢复</span><br><span class="line">		  </span><br><span class="line">if (icsk-&gt;icsk_ca_state &lt;= TCP_CA_Disorder)</span><br><span class="line">			  </span><br><span class="line">tcp_try_undo_dsack(sk);</span><br><span class="line">  </span><br><span class="line">//是否需要进入revocer状态。</span><br><span class="line">		  </span><br><span class="line">if (!tcp_time_to_recover(sk, flag)) &#123;</span><br><span class="line">  </span><br><span class="line">//如果不需要，则尝试着检测是否需要进入CWR或者Disorder状态.</span><br><span class="line">			  </span><br><span class="line">tcp_try_to_open(sk, flag);</span><br><span class="line">			  </span><br><span class="line">return;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/\* MTU probe failure: don&amp;#8217;t reduce cwnd \*/</span><br><span class="line">		  </span><br><span class="line">if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR &amp;&amp;</span><br><span class="line">		      </span><br><span class="line">icsk-&gt;icsk_mtup.probe_size &amp;&amp;</span><br><span class="line">		      </span><br><span class="line">tp-&gt;snd_una == tp-&gt;mtu_probe.probe_seq_start) &#123;</span><br><span class="line">			  </span><br><span class="line">tcp_mtup_probe_failed(sk);</span><br><span class="line">			  </span><br><span class="line">/\* Restores the reduction we did in tcp_mtup_probe() \*/</span><br><span class="line">			  </span><br><span class="line">tp-&gt;snd_cwnd++;</span><br><span class="line">			  </span><br><span class="line">tcp_simple_retransmit(sk);</span><br><span class="line">			  </span><br><span class="line">return;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//最终进入recovery状态</span><br><span class="line">		  </span><br><span class="line">/\* Otherwise enter Recovery state \*/</span><br><span class="line">		  </span><br><span class="line">tcp_enter_recovery(sk, (flag &amp; FLAG_ECE));</span><br><span class="line">		  </span><br><span class="line">fast_rexmit = 1;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面有三个函数需要详细分析，分别是tcp_time_to_recover,tcp_try_to_open以及tcp_enter_recovery。</p>
<p>首先是tcp_time_to_recover,这个函数主要是用来判断是否需要进入recover状态。</p>
<p>首先来描述下几个基本概念，一个就是重定序长度(reordering),这个值的意思是当有大于１个的SACK之后，相差最大的两个SACK之间的距离,比如第一个SACK通知的序列是7,第二个是2，那么reordering值就是6.而FACK_OUT表示sack确认的最大的序列号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static bool tcp_time_to_recover(struct sock *sk, int flag)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	  </span><br><span class="line">__u32 packets_out;</span><br><span class="line"></span><br><span class="line">/\* Do not perform any recovery during F-RTO algorithm \*/</span><br><span class="line">	  </span><br><span class="line">if (tp-&gt;frto_counter)</span><br><span class="line">		  </span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">/\* Trick#1: The loss is proven. \*/</span><br><span class="line">	  </span><br><span class="line">if (tp-&gt;lost_out)</span><br><span class="line">		  </span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">/\* Not-A-Trick#2 : Classic rule&amp;#8230; \*/</span><br><span class="line">  </span><br><span class="line">//如果SACK的最大序列号大于重定序长度，那么说明重定序序列中头部的数据一定丢失，那么就需要进入recover状态.</span><br><span class="line">	  </span><br><span class="line">if (tcp_dupack_heuristics(tp) &gt; tp-&gt;reordering)</span><br><span class="line">		  </span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">/* Trick#3 : when we use RFC2988 timer restart, fast</span><br><span class="line">	   </span><br><span class="line">* retransmit can be triggered by timeout of queue head.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">  </span><br><span class="line">//如果数据包超时(因为每次重传定时器都会被重置),则进入recover状态.</span><br><span class="line">	  </span><br><span class="line">if (tcp_is_fack(tp) &amp;&amp; tcp_head_timedout(sk))</span><br><span class="line">		  </span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">/* Trick#4: It is still not OK&amp;#8230; But will it be useful to delay</span><br><span class="line">	   </span><br><span class="line">* recovery more?</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">packets_out = tp-&gt;packets_out;</span><br><span class="line">  </span><br><span class="line">//这里不太理解什么意思</span><br><span class="line">	  </span><br><span class="line">if (packets_out &lt;= tp-&gt;reordering &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">tp-&gt;sacked_out &gt;= max_t(__u32, packets_out/2, sysctl_tcp_reordering) &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">!tcp_may_send_now(sk)) &#123;</span><br><span class="line">		  </span><br><span class="line">/* We have nothing to send. This connection is limited</span><br><span class="line">		   </span><br><span class="line">* either by receiver window or by application.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">return true;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* If a thin stream is detected, retransmit after first</span><br><span class="line">	   </span><br><span class="line">* received dupack. Employ only if SACK is supported in order</span><br><span class="line">	   </span><br><span class="line">* to avoid possible corner-case series of spurious retransmissions</span><br><span class="line">	   </span><br><span class="line">* Use only if there are no unsent data.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">  </span><br><span class="line">//处理thin stream</span><br><span class="line">	  </span><br><span class="line">if ((tp-&gt;thin_dupack || sysctl_tcp_thin_dupack) &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">tcp_stream_is_thin(tp) &amp;&amp; tcp_dupack_heuristics(tp) &gt; 1 &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">tcp_is_sack(tp) &amp;&amp; !tcp_send_head(sk))</span><br><span class="line">		  </span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">/* Trick#6: TCP early retransmit, per RFC5827. To avoid spurious</span><br><span class="line">	   </span><br><span class="line">* retransmissions due to small network reorderings, we implement</span><br><span class="line">	   </span><br><span class="line">* Mitigation A.3 in the RFC and delay the retransmission for a short</span><br><span class="line">	   </span><br><span class="line">* interval if appropriate.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">  </span><br><span class="line">//处理early retransmit</span><br><span class="line">	  </span><br><span class="line">if (tp-&gt;do_early_retrans &amp;&amp; !tp-&gt;retrans_out &amp;&amp; tp-&gt;sacked_out &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">(tp-&gt;packets_out == (tp-&gt;sacked_out + 1) &amp;&amp; tp-&gt;packets_out &lt; 4) &amp;&amp;</span><br><span class="line">	      </span><br><span class="line">!tcp_may_send_now(sk))</span><br><span class="line">		  </span><br><span class="line">return !tcp_pause_early_retransmit(sk, flag);</span><br><span class="line"></span><br><span class="line">//最终返回false.</span><br><span class="line">	  </span><br><span class="line">return false;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看tcp_try_to_open方法,这个函数名字有点问题，它的主要作用是检测是否需要进入CWR或者Disorder状态.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void tcp_try_to_open(struct sock *sk, int flag)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">tcp_verify_left_out(tp);</span><br><span class="line"></span><br><span class="line">if (!tp-&gt;frto_counter &amp;&amp; !tcp_any_retrans_done(sk))</span><br><span class="line">		  </span><br><span class="line">tp-&gt;retrans_stamp = 0;</span><br><span class="line">  </span><br><span class="line">//如果接受到ECE那么就进入cwr状态.</span><br><span class="line">	  </span><br><span class="line">if (flag &amp; FLAG_ECE)</span><br><span class="line">		  </span><br><span class="line">tcp_enter_cwr(sk, 1);</span><br><span class="line"></span><br><span class="line">if (inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_CWR) &#123;</span><br><span class="line">  </span><br><span class="line">//检测是否需要进入disorder状态，否则进入open状态.</span><br><span class="line">		  </span><br><span class="line">tcp_try_keep_open(sk);</span><br><span class="line">  </span><br><span class="line">//如果不是open状态，则修改拥塞窗口</span><br><span class="line">		  </span><br><span class="line">if (inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open)</span><br><span class="line">			  </span><br><span class="line">tcp_moderate_cwnd(tp);</span><br><span class="line">	  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">  </span><br><span class="line">//减小拥塞窗口</span><br><span class="line">		  </span><br><span class="line">tcp_cwnd_down(sk, flag);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看tcp__try_keep_open方法，这个方法就是判断是否进入Disorder状态.条件很简单，那就是要么有SACK的段或者有丢失的段，要么有任何重传的段，那么就进入Disorder状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void tcp_try_keep_open(struct sock *sk)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">  </span><br><span class="line">//默认是进入open状态</span><br><span class="line">	  </span><br><span class="line">int state = TCP_CA_Open;</span><br><span class="line">  </span><br><span class="line">//进入Disorder状态</span><br><span class="line">	  </span><br><span class="line">if (tcp_left_out(tp) || tcp_any_retrans_done(sk))</span><br><span class="line">		  </span><br><span class="line">state = TCP_CA_Disorder;</span><br><span class="line"></span><br><span class="line">if (inet_csk(sk)-&gt;icsk_ca_state != state) &#123;</span><br><span class="line">		  </span><br><span class="line">tcp_set_ca_state(sk, state);</span><br><span class="line">		  </span><br><span class="line">tp-&gt;high_seq = tp-&gt;snd_nxt;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是tcp_enter_recovery，这个函数主要就是用来进入recover状态，然后设置相关的域。</p>
<p>high_seq : 进入recover状态时的snd_nxt.</p>
<p>undo_marker: 表示进入revover状态时的snd_una</p>
<p>undo_retrans: 表示进入revover状态时的重传段个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void tcp_enter_recovery(struct sock *sk, bool ece_ack)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	  </span><br><span class="line">int mib_idx;</span><br><span class="line"></span><br><span class="line">if (tcp_is_reno(tp))</span><br><span class="line">		  </span><br><span class="line">mib_idx = LINUX_MIB_TCPRENORECOVERY;</span><br><span class="line">	  </span><br><span class="line">else</span><br><span class="line">		  </span><br><span class="line">mib_idx = LINUX_MIB_TCPSACKRECOVERY;</span><br><span class="line"></span><br><span class="line">NET_INC_STATS_BH(sock_net(sk), mib_idx);</span><br><span class="line">  </span><br><span class="line">//更新相关域</span><br><span class="line">	  </span><br><span class="line">tp-&gt;high_seq = tp-&gt;snd_nxt;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;prior_ssthresh = 0;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;undo_marker = tp-&gt;snd_una;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;undo_retrans = tp-&gt;retrans_out;</span><br><span class="line"></span><br><span class="line">if (inet_csk(sk)-&gt;icsk_ca_state &lt; TCP_CA_CWR) &#123;</span><br><span class="line">		  </span><br><span class="line">if (!ece_ack)</span><br><span class="line">  </span><br><span class="line">//保存当前的ssthresh,以便于后续恢复</span><br><span class="line">			  </span><br><span class="line">tp-&gt;prior_ssthresh = tcp_current_ssthresh(sk);</span><br><span class="line">  </span><br><span class="line">//更新slow start的阈值.</span><br><span class="line">		  </span><br><span class="line">tp-&gt;snd_ssthresh = inet_csk(sk)-&gt;icsk_ca_ops-&gt;ssthresh(sk);</span><br><span class="line">		  </span><br><span class="line">TCP_ECN_queue_cwr(tp);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tp-&gt;bytes_acked = 0;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;snd_cwnd_cnt = 0;</span><br><span class="line">  </span><br><span class="line">//保存拥塞窗口</span><br><span class="line">	  </span><br><span class="line">tp-&gt;prior_cwnd = tp-&gt;snd_cwnd;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;prr_delivered = 0;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;prr_out = 0;</span><br><span class="line">  </span><br><span class="line">//进入recovery状态</span><br><span class="line">	  </span><br><span class="line">tcp_set_ca_state(sk, TCP_CA_Recovery);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看tcp_enter_cwr，这个函数主要是用于进入CWR状态。看这个函数的时候，可以看到和上面recover状态使用的变量的设置关系.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">void tcp_enter_cwr(struct sock *sk, const int set_ssthresh)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	  </span><br><span class="line">const struct inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line"></span><br><span class="line">tp-&gt;prior_ssthresh = 0;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;bytes_acked = 0;</span><br><span class="line">	  </span><br><span class="line">if (icsk-&gt;icsk_ca_state &lt; TCP_CA_CWR) &#123;</span><br><span class="line">		  </span><br><span class="line">tp-&gt;undo_marker = 0;</span><br><span class="line">		  </span><br><span class="line">if (set_ssthresh)</span><br><span class="line">			  </span><br><span class="line">tp-&gt;snd_ssthresh = icsk-&gt;icsk_ca_ops-&gt;ssthresh(sk);</span><br><span class="line">		  </span><br><span class="line">tp-&gt;snd_cwnd = min(tp-&gt;snd_cwnd,</span><br><span class="line">				     </span><br><span class="line">tcp_packets_in_flight(tp) + 1U);</span><br><span class="line">		  </span><br><span class="line">tp-&gt;snd_cwnd_cnt = 0;</span><br><span class="line">  </span><br><span class="line">//设置最大序列号</span><br><span class="line">		  </span><br><span class="line">tp-&gt;high_seq = tp-&gt;snd_nxt;</span><br><span class="line">		  </span><br><span class="line">tp-&gt;snd_cwnd_stamp = tcp_time_stamp;</span><br><span class="line">		  </span><br><span class="line">TCP_ECN_queue_cwr(tp);</span><br><span class="line">  </span><br><span class="line">//进入CWR状态.</span><br><span class="line">		  </span><br><span class="line">tcp_set_ca_state(sk, TCP_CA_CWR);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的设置保存了很多值，那么这些值在什么时候使用呢，先来看上面的代码分析中跳过的片段,也就是tcp_try_undo_dsack函数。</p>
<p>这个函数主要是用于检测是否需要从cwnd减小的驱使中恢复，这里判断条件就是undo_marker和undo_retrans.</p>
<p>这里undo_retrans为0,则表示没有重传任何数据，或者说重传的数据都已经被DSACK了，从而说明数据都已经安全抵达，那么这个时候自然需要从cwr恢复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void tcp_try_undo_dsack(struct sock *sk)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">if (tp-&gt;undo_marker &amp;&amp; !tp-&gt;undo_retrans) &#123;</span><br><span class="line">		  </span><br><span class="line">DBGUNDO(sk, &quot;D-SACK&quot;);</span><br><span class="line">  </span><br><span class="line">//恢复拥塞窗口以及slow start的阈值。</span><br><span class="line">		  </span><br><span class="line">tcp_undo_cwr(sk, true);</span><br><span class="line">		  </span><br><span class="line">tp-&gt;undo_marker = 0;</span><br><span class="line">		  </span><br><span class="line">NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPDSACKUNDO);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到核心就是tcp_undo_cwr函数。这个函数主要就是用于重置发送拥塞窗口和slow start的阈值.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void tcp_undo_cwr(struct sock *sk, const bool undo_ssthresh)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">if (tp-&gt;prior_ssthresh) &#123;</span><br><span class="line">		  </span><br><span class="line">const struct inet_connection_sock *icsk = inet_csk(sk);</span><br><span class="line"></span><br><span class="line">if (icsk-&gt;icsk_ca_ops-&gt;undo_cwnd)</span><br><span class="line">			  </span><br><span class="line">tp-&gt;snd_cwnd = icsk-&gt;icsk_ca_ops-&gt;undo_cwnd(sk);</span><br><span class="line">		  </span><br><span class="line">else</span><br><span class="line">			  </span><br><span class="line">tp-&gt;snd_cwnd = max(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh &lt;&lt; 1);</span><br><span class="line"></span><br><span class="line">if (undo_ssthresh &amp;&amp; tp-&gt;prior_ssthresh &gt; tp-&gt;snd_ssthresh) &#123;</span><br><span class="line">  </span><br><span class="line">//恢复到先前保存的阈值</span><br><span class="line">			  </span><br><span class="line">tp-&gt;snd_ssthresh = tp-&gt;prior_ssthresh;</span><br><span class="line">			  </span><br><span class="line">TCP_ECN_withdraw_cwr(tp);</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">		  </span><br><span class="line">tp-&gt;snd_cwnd = max(tp-&gt;snd_cwnd, tp-&gt;snd_ssthresh);</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">tp-&gt;snd_cwnd_stamp = tcp_time_stamp;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后来看在recover状态下，如何处理重复/部分确认.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">case TCP_CA_Recovery:</span><br><span class="line">  </span><br><span class="line">//如果收到了重复确认</span><br><span class="line">		  </span><br><span class="line">if (!(flag &amp; FLAG_SND_UNA_ADVANCED)) &#123;</span><br><span class="line">  </span><br><span class="line">//如果是reno算法，则更新sack</span><br><span class="line">			  </span><br><span class="line">if (tcp_is_reno(tp) &amp;&amp; is_dupack)</span><br><span class="line">				  </span><br><span class="line">tcp_add_reno_sack(sk);</span><br><span class="line">		  </span><br><span class="line">&#125; else</span><br><span class="line">  </span><br><span class="line">//接收到了部分确认，那么此时就需要撤销先前的设置</span><br><span class="line">			  </span><br><span class="line">do_lost = tcp_try_undo_partial(sk, pkts_acked);</span><br><span class="line">		  </span><br><span class="line">break;</span><br></pre></td></tr></table></figure>
<p>然后来看tcp_try_undo_partial,这个函数就是用来检查是否可以从接受到的部分确认撤销，它的返回值就是是否需要标记一些段为丢失。</p>
<p>这里要注意tcp_may_undo函数，这个函数主要用于判断是否是错误的进入了拥塞状态，如果是那么就返回true，然后接下来就需要从错误的状态撤销.它的判断类似上面的tcp_try_undo_dsack。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int tcp_try_undo_partial(struct sock *sk, int acked)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	  </span><br><span class="line">/\* Partial ACK arrived. Force Hoe&amp;#8217;s retransmit. \*/</span><br><span class="line">	  </span><br><span class="line">int failed = tcp_is_reno(tp) || (tcp_fackets_out(tp) &gt; tp-&gt;reordering);</span><br><span class="line">  </span><br><span class="line">//判断是否需要撤销</span><br><span class="line">	  </span><br><span class="line">if (tcp_may_undo(tp)) &#123;</span><br><span class="line">		  </span><br><span class="line">/* Plain luck! Hole if filled with delayed</span><br><span class="line">		   </span><br><span class="line">* packet, rather than with a retransmit.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">if (!tcp_any_retrans_done(sk))</span><br><span class="line">			  </span><br><span class="line">tp-&gt;retrans_stamp = 0;</span><br><span class="line">  </span><br><span class="line">//update重定序长度</span><br><span class="line">		  </span><br><span class="line">tcp_update_reordering(sk, tcp_fackets_out(tp) + acked, 1);</span><br><span class="line"></span><br><span class="line">DBGUNDO(sk, &quot;Hoe&quot;);</span><br><span class="line">  </span><br><span class="line">//从cwr撤销</span><br><span class="line">		  </span><br><span class="line">tcp_undo_cwr(sk, false);</span><br><span class="line">		  </span><br><span class="line">NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPPARTIALUNDO);</span><br><span class="line"></span><br><span class="line">/* So&amp;#8230; Do not make Hoe&amp;#8217;s retransmit yet.</span><br><span class="line">		   </span><br><span class="line">* If the first packet was delayed, the rest</span><br><span class="line">		   </span><br><span class="line">* ones are most probably delayed as well.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">failed = 0;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">return failed;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是LOSS状态的处理，也就是说在LOSS状态时处理重复以及部分确认.这个状态的处理类似上面的recover状态，因此这里就简要的描述下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">case TCP_CA_Loss:</span><br><span class="line">		  </span><br><span class="line">if (flag &amp; FLAG_DATA_ACKED)</span><br><span class="line">			  </span><br><span class="line">icsk-&gt;icsk_retransmits = 0;</span><br><span class="line">		  </span><br><span class="line">if (tcp_is_reno(tp) &amp;&amp; flag &amp; FLAG_SND_UNA_ADVANCED)</span><br><span class="line">			  </span><br><span class="line">tcp_reset_reno_sack(tp);</span><br><span class="line">  </span><br><span class="line">//判断是否需要从LOSS状态撤销</span><br><span class="line">		  </span><br><span class="line">if (!tcp_try_undo_loss(sk)) &#123;</span><br><span class="line">  </span><br><span class="line">//不需要撤销，则调整拥塞窗口</span><br><span class="line">			  </span><br><span class="line">tcp_moderate_cwnd(tp);</span><br><span class="line">  </span><br><span class="line">//重传</span><br><span class="line">			  </span><br><span class="line">tcp_xmit_retransmit_queue(sk);</span><br><span class="line">			  </span><br><span class="line">return;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">		  </span><br><span class="line">if (icsk-&gt;icsk_ca_state != TCP_CA_Open)</span><br><span class="line">			  </span><br><span class="line">return;</span><br></pre></td></tr></table></figure>
<p>最后我们来看退出拥塞状态检测的处理，也就是当发送未确认的段大于等于high_seq(拥塞发生时的snd_nxt).当大于high_seq的时候，则说明可能我们需要从拥塞状态退出了，因为此时可能当拥塞状态发生时丢失的段都已经传输完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">		  </span><br><span class="line">case TCP_CA_Loss:</span><br><span class="line">			  </span><br><span class="line">icsk-&gt;icsk_retransmits = 0;</span><br><span class="line">  </span><br><span class="line">//尝试撤销拥塞状态</span><br><span class="line">			  </span><br><span class="line">if (tcp_try_undo_recovery(sk))</span><br><span class="line">				  </span><br><span class="line">return;</span><br><span class="line">			  </span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case TCP_CA_CWR:</span><br><span class="line">			  </span><br><span class="line">/\* CWR is to be held something \*above* high_seq</span><br><span class="line">			   </span><br><span class="line">\* is ACKed for CWR bit to reach receiver. \*/</span><br><span class="line">			  </span><br><span class="line">if (tp-&gt;snd_una != tp-&gt;high_seq) &#123;</span><br><span class="line">				  </span><br><span class="line">tcp_complete_cwr(sk);</span><br><span class="line">  </span><br><span class="line">//恢复到open状态.</span><br><span class="line">				  </span><br><span class="line">tcp_set_ca_state(sk, TCP_CA_Open);</span><br><span class="line">			  </span><br><span class="line">&#125;</span><br><span class="line">			  </span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case TCP_CA_Recovery:</span><br><span class="line">			  </span><br><span class="line">if (tcp_is_reno(tp))</span><br><span class="line">				  </span><br><span class="line">tcp_reset_reno_sack(tp);</span><br><span class="line">  </span><br><span class="line">//尝试撤销拥塞状态</span><br><span class="line">			  </span><br><span class="line">if (tcp_try_undo_recovery(sk))</span><br><span class="line">				  </span><br><span class="line">return;</span><br><span class="line">  </span><br><span class="line">//完成cwr</span><br><span class="line">			  </span><br><span class="line">tcp_complete_cwr(sk);</span><br><span class="line">			  </span><br><span class="line">break;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看最后一个函数，也就是tcp_try_undo_recovery函数。这个函数主要就是用于撤销拥塞状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static bool tcp_try_undo_recovery(struct sock *sk)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">  </span><br><span class="line">//是否需要撤销</span><br><span class="line">	  </span><br><span class="line">if (tcp_may_undo(tp)) &#123;</span><br><span class="line">		  </span><br><span class="line">int mib_idx;</span><br><span class="line"></span><br><span class="line">/* Happy end! We did not retransmit anything</span><br><span class="line">		   </span><br><span class="line">* or our original transmission succeeded.</span><br><span class="line">		   </span><br><span class="line">*/</span><br><span class="line">		  </span><br><span class="line">DBGUNDO(sk, inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Loss ? &quot;loss&quot; : &quot;retrans&quot;);</span><br><span class="line">  </span><br><span class="line">//撤销设置</span><br><span class="line">		  </span><br><span class="line">tcp_undo_cwr(sk, true);</span><br><span class="line">		  </span><br><span class="line">if (inet_csk(sk)-&gt;icsk_ca_state == TCP_CA_Loss)</span><br><span class="line">			  </span><br><span class="line">mib_idx = LINUX_MIB_TCPLOSSUNDO;</span><br><span class="line">		  </span><br><span class="line">else</span><br><span class="line">			  </span><br><span class="line">mib_idx = LINUX_MIB_TCPFULLUNDO;</span><br><span class="line"></span><br><span class="line">NET_INC_STATS_BH(sock_net(sk), mib_idx);</span><br><span class="line">		  </span><br><span class="line">tp-&gt;undo_marker = 0;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">if (tp-&gt;snd_una == tp-&gt;high_seq &amp;&amp; tcp_is_reno(tp)) &#123;</span><br><span class="line">		  </span><br><span class="line">/\* Hold old state until something \*above* high_seq</span><br><span class="line">		   </span><br><span class="line">* is ACKed. For Reno it is MUST to prevent false</span><br><span class="line">		   </span><br><span class="line">\* fast retransmits (RFC2582). SACK TCP is safe. \*/</span><br><span class="line">		  </span><br><span class="line">tcp_moderate_cwnd(tp);</span><br><span class="line">		  </span><br><span class="line">return true;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置状态为open.</span><br><span class="line">	  </span><br><span class="line">tcp_set_ca_state(sk, TCP_CA_Open);</span><br><span class="line">	  </span><br><span class="line">return false;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/tcp-ip/">tcp/ip</a><a href="/tags/linux/">linux</a><a href="/tags/tcp/">tcp</a></div><div class="post-nav"><a class="pre" href="/2013/05/11/early-retransmit-for-tcp-principle-and-implementation.html">Early Retransmit for TCP原理以及实现</a><a class="next" href="/2012/08/18/vegas-analysis-of-tcp-congestion-algorithm.html">tcp拥塞算法vegas分析</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/mysql-rocksdb.-data-reading-(ii).html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>