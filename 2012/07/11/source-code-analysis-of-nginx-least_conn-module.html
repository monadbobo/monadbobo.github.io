<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>nginx least_conn 模块源码剖析 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">nginx least_conn 模块源码剖析</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">nginx least_conn 模块源码剖析</h1><div class="post-meta">Jul 11, 2012<span> | </span><span class="category"><a href="/categories/nginx/">nginx</a><a href="/categories/nginx/server/">server</a><a href="/categories/nginx/server/源码阅读/">源码阅读</a></span></div><div class="post-content"><p>nginx在1.3.1添加了一个新模块 least_conn,也就是我们常说的最少连接负载均衡算法，简单来说就是每次选择的都是当前最少连接的一个server(这个最少连接不是全局的，是每个进程都有自己的一个统计列表)。</p>
<p>在看最少连接模块之前需要对round robin模块有一定的了解，这里我就不对round robin模块进行分析了，想要看这块代码，可以去我们组 卫岳的blog的这篇文章</p>
<p><a href="http://blog.sina.com.cn/s/blog_7303a1dc01014i0j.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7303a1dc01014i0j.html</a></p>
<p>ok，接下来就来看这个模块，首先来看如何打开least_conn模块:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static ngx_command_t ngx_http_upstream_least_conn_commands[] = &#123;</span><br><span class="line"></span><br><span class="line">&#123; ngx_string(&quot;least_conn&quot;),</span><br><span class="line">        </span><br><span class="line">NGX_HTTP_UPS_CONF|NGX_CONF_NOARGS,</span><br><span class="line">        </span><br><span class="line">ngx_http_upstream_least_conn,</span><br><span class="line">        </span><br><span class="line">0,</span><br><span class="line">        </span><br><span class="line">0,</span><br><span class="line">        </span><br><span class="line">NULL &#125;,</span><br><span class="line"></span><br><span class="line">ngx_null_command</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>可以看到命令很简单，就是在upstream块里面加上 least_conn就行了。</p>
<p>来看命令回调，least_conn的入口就是在这个里面设置的.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static char *</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_least_conn(ngx_conf_t \*cf, ngx_command_t \*cmd, void *conf)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_srv_conf_t *uscf;</span><br><span class="line"></span><br><span class="line">uscf = ngx_http_conf_get_module_srv_conf(cf, ngx_http_upstream_module);</span><br><span class="line"></span><br><span class="line">uscf-&gt;peer.init_upstream = ngx_http_upstream_init_least_conn;</span><br><span class="line"></span><br><span class="line">uscf-&gt;flags = NGX_HTTP_UPSTREAM_CREATE</span><br><span class="line">                    </span><br><span class="line">|NGX_HTTP_UPSTREAM_WEIGHT</span><br><span class="line">                    </span><br><span class="line">|NGX_HTTP_UPSTREAM_MAX_FAILS</span><br><span class="line">                    </span><br><span class="line">|NGX_HTTP_UPSTREAM_FAIL_TIMEOUT</span><br><span class="line">                    </span><br><span class="line">|NGX_HTTP_UPSTREAM_DOWN</span><br><span class="line">                    </span><br><span class="line">|NGX_HTTP_UPSTREAM_BACKUP;</span><br><span class="line"></span><br><span class="line">return NGX_CONF_OK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到很简单，就是设置了peer.init_upstream,然后设置了支持的flags。那么这里就有问题了，peer.init_upstream什么时候会被调用呢。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static char *</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_init_main_conf(ngx_conf_t \*cf, void \*conf)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_main_conf_t *umcf = conf;</span><br><span class="line"></span><br><span class="line">ngx_uint_t i;</span><br><span class="line">      </span><br><span class="line">ngx_array_t headers_in;</span><br><span class="line">      </span><br><span class="line">ngx_hash_key_t *hk;</span><br><span class="line">      </span><br><span class="line">ngx_hash_init_t hash;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_init_pt init;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_header_t *header;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_srv_conf_t **uscfp;</span><br><span class="line"></span><br><span class="line">uscfp = umcf-&gt;upstreams.elts;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; umcf-&gt;upstreams.nelts; i++) &#123;</span><br><span class="line">  </span><br><span class="line">//判断是否有设置 initupstream,默认是round robin算法.</span><br><span class="line">          </span><br><span class="line">init = uscfp[i]-&gt;peer.init_upstream ? uscfp[i]-&gt;peer.init_upstream:</span><br><span class="line">                                              </span><br><span class="line">ngx_http_upstream_init_round_robin;</span><br><span class="line"></span><br><span class="line">if (init(cf, uscfp[i]) != NGX_OK) &#123;</span><br><span class="line">              </span><br><span class="line">return NGX_CONF_ERROR;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以看到是在解析upstream命令的时候，调用init_upstream的，因此也就可以这么说，init_upstream中初始化的的东西，每个进程都有自己的一份拷贝.</p>
<p>所以我们来看ngx_http_upstream_init_least_conn，这个函数主要就是初始化round robin(主要是为了初始化权重/timeout等参数，而且least conn中如果多个server有相同的连接数，则会使用round robin算法)以及设置peer的init回调.</p>
<p>还有一个要注意的就是conns数组，这个数组每个slot保存了对应server的连接数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ngx_int_t</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_init_least_conn(ngx_conf_t *cf,</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_srv_conf_t *us)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_uint_t n;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_rr_peers_t *peers;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_least_conn_conf_t *lcf;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, cf-&gt;log, 0,</span><br><span class="line">                     </span><br><span class="line">&quot;init least conn&quot;);</span><br><span class="line">  </span><br><span class="line">//初始化round robin</span><br><span class="line">      </span><br><span class="line">if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">peers = us-&gt;peer.data;</span><br><span class="line"></span><br><span class="line">n = peers-&gt;number;</span><br><span class="line"></span><br><span class="line">if (peers-&gt;next) &#123;</span><br><span class="line">          </span><br><span class="line">n += peers-&gt;next-&gt;number;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lcf = ngx_http_conf_upstream_srv_conf(us,</span><br><span class="line">                                            </span><br><span class="line">ngx_http_upstream_least_conn_module);</span><br><span class="line">  </span><br><span class="line">//创建conns数组</span><br><span class="line">      </span><br><span class="line">lcf-&gt;conns = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_uint_t) * n);</span><br><span class="line">      </span><br><span class="line">if (lcf-&gt;conns == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置init</span><br><span class="line">      </span><br><span class="line">us-&gt;peer.init = ngx_http_upstream_init_least_conn_peer;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而us-&gt;peer.init是在upstream的request初始化的时候调用的，也就是说每个request都会调用这个函数来初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_init_request(ngx_http_request_t *r)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">  </span><br><span class="line">found:</span><br><span class="line"></span><br><span class="line">if (uscf-&gt;peer.init(r, uscf) != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_http_upstream_finalize_request(r, u,</span><br><span class="line">                                             </span><br><span class="line">NGX_HTTP_INTERNAL_SERVER_ERROR);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ngx_http_upstream_connect(r, u);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就来看peer.init回调ngx_http_upstream_init_least_conn_peer，在这个函数中，主要是用来初始化对应的数据结构,然后挂载对应的回调(getpeer/freepeer).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">      </span><br><span class="line">/\* the round robin data must be first \*/</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_rr_peer_data_t rrp;</span><br><span class="line">  </span><br><span class="line">//连接信息保存</span><br><span class="line">      </span><br><span class="line">ngx_uint_t *conns;</span><br><span class="line">  </span><br><span class="line">//对应的get和free连接的回调</span><br><span class="line">      </span><br><span class="line">ngx_event_get_peer_pt get_rr_peer;</span><br><span class="line">      </span><br><span class="line">ngx_event_free_peer_pt free_rr_peer;</span><br><span class="line">  </span><br><span class="line">&#125; ngx_http_upstream_lc_peer_data_t;</span><br><span class="line"></span><br><span class="line">static ngx_int_t</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r,</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_srv_conf_t *us)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_lc_peer_data_t *lcp;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_least_conn_conf_t *lcf;</span><br><span class="line"></span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,</span><br><span class="line">                     </span><br><span class="line">&quot;init least conn peer&quot;);</span><br><span class="line"></span><br><span class="line">lcf = ngx_http_conf_upstream_srv_conf(us,</span><br><span class="line">                                            </span><br><span class="line">ngx_http_upstream_least_conn_module);</span><br><span class="line"></span><br><span class="line">lcp = ngx_palloc(r-&gt;pool, sizeof(ngx_http_upstream_lc_peer_data_t));</span><br><span class="line">      </span><br><span class="line">if (lcp == NULL) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lcp-&gt;conns = lcf-&gt;conns;</span><br><span class="line"></span><br><span class="line">r-&gt;upstream-&gt;peer.data = &amp;lcp-&gt;rrp;</span><br><span class="line">  </span><br><span class="line">//初始化round robin</span><br><span class="line">      </span><br><span class="line">if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">return NGX_ERROR;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//设置回调</span><br><span class="line">      </span><br><span class="line">r-&gt;upstream-&gt;peer.get = ngx_http_upstream_get_least_conn_peer;</span><br><span class="line">      </span><br><span class="line">r-&gt;upstream-&gt;peer.free = ngx_http_upstream_free_least_conn_peer;</span><br><span class="line"></span><br><span class="line">lcp-&gt;get_rr_peer = ngx_http_upstream_get_round_robin_peer;</span><br><span class="line">      </span><br><span class="line">lcp-&gt;free_rr_peer = ngx_http_upstream_free_round_robin_peer;</span><br><span class="line"></span><br><span class="line">return NGX_OK;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面可以看到每个lcp都有自己的get peer和free回调，这是什么原因呢，和upstream-&gt;peer的get和free的区别在哪里，这个是这样的原因，主要是least conn算法中，如果多个server都有相同的连接数，那么就需要使用round robin算法了，所以就保存了round robin的peer回调。</p>
<p>然后来看对应的peer get回调在那里调用的，首先通过前面的blog 我们知道每次当要和upstream建立连接的时候，我们都需要调用ngx_event_connect_peer，最终这个函数会创建连接，然后再去connect upstream，而我们的get回调也就是在这个函数中调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">ngx_int_t</span><br><span class="line">  </span><br><span class="line">ngx_event_connect_peer(ngx_peer_connection_t *pc)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">int rc;</span><br><span class="line">      </span><br><span class="line">ngx_int_t event;</span><br><span class="line">      </span><br><span class="line">ngx_err_t err;</span><br><span class="line">      </span><br><span class="line">ngx_uint_t level;</span><br><span class="line">      </span><br><span class="line">ngx_socket_t s;</span><br><span class="line">      </span><br><span class="line">ngx_event_t \*rev, \*wev;</span><br><span class="line">      </span><br><span class="line">ngx_connection_t *c;</span><br><span class="line">  </span><br><span class="line">//调用get</span><br><span class="line">      </span><br><span class="line">rc = pc-&gt;get(pc, pc-&gt;data);</span><br><span class="line">      </span><br><span class="line">if (rc != NGX_OK) &#123;</span><br><span class="line">          </span><br><span class="line">return rc;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实nginx的load balance模块中，最核心的就是peer.get回调了，基本上核心的算法都在get回调里面实现，所以我们来看ngx_http_upstream_get_least_conn_peer,这个函数比较长，我们分段来看，首先是选择最少连接的server，这里要注意，其实不仅仅是最少连接，还要加上权重，这里nginx使用的是连接数和权重的乘积。</p>
<p>还有一个要注意的，就是对于每一个请求，Nginx保存了一个位图，这个位图保存了所有server是否已经被当前request使用过的状态，如果使用过则对应的位是1，否则为0，这个主要是为了处理失败的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">for (i = 0; i &lt; peers-&gt;number; i++) &#123;</span><br><span class="line">  </span><br><span class="line">//一个字节8位，所以计算当前peer所处的位置</span><br><span class="line">          </span><br><span class="line">n = i / (8 * sizeof(uintptr_t));</span><br><span class="line">  </span><br><span class="line">//得到当前peer的状态</span><br><span class="line">          </span><br><span class="line">m = (uintptr_t) 1 &lt;&lt; i % (8 * sizeof(uintptr_t));</span><br><span class="line">  </span><br><span class="line">//如果已经服务过，则跳过</span><br><span class="line">          </span><br><span class="line">if (lcp-&gt;rrp.tried[n] &amp; m) &#123;</span><br><span class="line">              </span><br><span class="line">continue;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">peer = &amp;peers-&gt;peer[i];</span><br><span class="line"></span><br><span class="line">if (peer-&gt;down) &#123;</span><br><span class="line">              </span><br><span class="line">continue;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//如果超过最大失败次数，并且还没超时，则跳过.</span><br><span class="line">          </span><br><span class="line">if (peer-&gt;max_fails</span><br><span class="line">              </span><br><span class="line">&amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails</span><br><span class="line">              </span><br><span class="line">&amp;&amp; now &amp;#8211; peer-&gt;checked &lt;= peer-&gt;fail_timeout)</span><br><span class="line">          </span><br><span class="line">&#123;</span><br><span class="line">              </span><br><span class="line">continue;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">           </span><br><span class="line">* select peer with least number of connections; if there are</span><br><span class="line">           </span><br><span class="line">* multiple peers with the same number of connections, select</span><br><span class="line">           </span><br><span class="line">* based on round-robin</span><br><span class="line">           </span><br><span class="line">*/</span><br><span class="line">  </span><br><span class="line">//选择server</span><br><span class="line">          </span><br><span class="line">if (best == NULL</span><br><span class="line">              </span><br><span class="line">|| lcp-&gt;conns[i] \* best-&gt;weight &lt; lcp-&gt;conns[p] \* peer-&gt;weight)</span><br><span class="line">          </span><br><span class="line">&#123;</span><br><span class="line">              </span><br><span class="line">best = peer;</span><br><span class="line">  </span><br><span class="line">//many表示是否有多个server满足条件.</span><br><span class="line">              </span><br><span class="line">many = 0;</span><br><span class="line">  </span><br><span class="line">//p为best的位置</span><br><span class="line">              </span><br><span class="line">p = i;</span><br><span class="line"></span><br><span class="line">&#125; else if (lcp-&gt;conns[i] * best-&gt;weight</span><br><span class="line">                     </span><br><span class="line">== lcp-&gt;conns[p] * peer-&gt;weight)</span><br><span class="line">          </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">//相等则说明有多个server满足条件.</span><br><span class="line">              </span><br><span class="line">many = 1;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来这段就是当有多个server满足条件的时候的处理，这里是如果多个server满足条件，则进入round robin的处理逻辑。下面的代码和round robin的get peer回调中算法是一模一样的。就是根据权重选择一个合适的server，这里Nginx还调整过round robin算法,想了解，可以看这里 <a href="http://trac.nginx.org/nginx/changeset/4668/nginx" target="_blank" rel="noopener">http://trac.nginx.org/nginx/changeset/4668/nginx</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">if (many) &#123;</span><br><span class="line">          </span><br><span class="line">ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0,</span><br><span class="line">                         </span><br><span class="line">&quot;get least conn peer, many&quot;);</span><br><span class="line"></span><br><span class="line">for (i = p; i &lt; peers-&gt;number; i++) &#123;</span><br><span class="line"></span><br><span class="line">n = i / (8 * sizeof(uintptr_t));</span><br><span class="line">              </span><br><span class="line">m = (uintptr_t) 1 &lt;&lt; i % (8 * sizeof(uintptr_t));</span><br><span class="line"></span><br><span class="line">if (lcp-&gt;rrp.tried[n] &amp; m) &#123;</span><br><span class="line">                  </span><br><span class="line">continue;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">peer = &amp;peers-&gt;peer[i];</span><br><span class="line"></span><br><span class="line">if (peer-&gt;down) &#123;</span><br><span class="line">                  </span><br><span class="line">continue;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (lcp-&gt;conns[i] \* best-&gt;weight != lcp-&gt;conns[p] \* peer-&gt;weight) &#123;</span><br><span class="line">                  </span><br><span class="line">continue;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (peer-&gt;max_fails</span><br><span class="line">                  </span><br><span class="line">&amp;&amp; peer-&gt;fails &gt;= peer-&gt;max_fails</span><br><span class="line">                  </span><br><span class="line">&amp;&amp; now &amp;#8211; peer-&gt;checked &lt;= peer-&gt;fail_timeout)</span><br><span class="line">              </span><br><span class="line">&#123;</span><br><span class="line">                  </span><br><span class="line">continue;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">peer-&gt;current_weight += peer-&gt;effective_weight;</span><br><span class="line">              </span><br><span class="line">total += peer-&gt;effective_weight;</span><br><span class="line"></span><br><span class="line">if (peer-&gt;effective_weight &lt; peer-&gt;weight) &#123;</span><br><span class="line">                  </span><br><span class="line">peer-&gt;effective_weight++;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (peer-&gt;current_weight &gt; best-&gt;current_weight) &#123;</span><br><span class="line">                  </span><br><span class="line">best = peer;</span><br><span class="line">                  </span><br><span class="line">p = i;</span><br><span class="line">              </span><br><span class="line">&#125;</span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">best-&gt;current_weight -= total;</span><br><span class="line">      </span><br><span class="line">best-&gt;checked = now;</span><br></pre></td></tr></table></figure>
<p>最后就是更新一些状态位，比如更新server的连接数 等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      </span><br><span class="line">pc-&gt;sockaddr = best-&gt;sockaddr;</span><br><span class="line">      </span><br><span class="line">pc-&gt;socklen = best-&gt;socklen;</span><br><span class="line">      </span><br><span class="line">pc-&gt;name = &amp;best-&gt;name;</span><br><span class="line"></span><br><span class="line">lcp-&gt;rrp.current = p;</span><br><span class="line"></span><br><span class="line">n = p / (8 * sizeof(uintptr_t));</span><br><span class="line">      </span><br><span class="line">m = (uintptr_t) 1 &lt;&lt; p % (8 * sizeof(uintptr_t));</span><br><span class="line">  </span><br><span class="line">//设置对应的server的状态</span><br><span class="line">      </span><br><span class="line">lcp-&gt;rrp.tried[n] |= m;</span><br><span class="line">  </span><br><span class="line">//更新连接数</span><br><span class="line">      </span><br><span class="line">lcp-&gt;conns[p]++;</span><br><span class="line"></span><br><span class="line">if (pc-&gt;tries == 1 &amp;&amp; peers-&gt;next) &#123;</span><br><span class="line">          </span><br><span class="line">pc-&gt;tries += peers-&gt;next-&gt;number;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就来看peer的free回调，它主要是用来清理一些状态比如连接数减1等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static void</span><br><span class="line">  </span><br><span class="line">ngx_http_upstream_free_least_conn_peer(ngx_peer_connection_t *pc,</span><br><span class="line">      </span><br><span class="line">void *data, ngx_uint_t state)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">      </span><br><span class="line">ngx_http_upstream_lc_peer_data_t *lcp = data;</span><br><span class="line"></span><br><span class="line">ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&gt;log, 0,</span><br><span class="line">                     </span><br><span class="line">&quot;free least conn peer %ui %ui&quot;, pc-&gt;tries, state);</span><br><span class="line"></span><br><span class="line">if (lcp-&gt;rrp.peers-&gt;single) &#123;</span><br><span class="line">          </span><br><span class="line">lcp-&gt;free_rr_peer(pc, &amp;lcp-&gt;rrp, state);</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (state == 0 &amp;&amp; pc-&gt;tries == 0) &#123;</span><br><span class="line">          </span><br><span class="line">return;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//更新连接状态</span><br><span class="line">      </span><br><span class="line">lcp-&gt;conns[lcp-&gt;rrp.current]&amp;#8211;;</span><br><span class="line">  </span><br><span class="line">//调用round robin的free.</span><br><span class="line">      </span><br><span class="line">lcp-&gt;free_rr_peer(pc, &amp;lcp-&gt;rrp, state);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/nginx/">nginx</a><a href="/tags/loadbalance/">loadbalance</a></div><div class="post-nav"><a class="pre" href="/2012/08/01/.html">tcp中RTO的计算以及linux下的实现</a><a class="next" href="/2012/07/04/a-problem-caused-by-opening-tcp_tw_recycle.html">打开tcp_tw_recycle引起的一个问题</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/design-and-implementation-of-redo-log-in-innodb-(i).html">InnoDB中Redo log设计与实现(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/.html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/.html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>