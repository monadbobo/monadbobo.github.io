<!DOCTYPE html><html lang="[&quot;zh-CN&quot;,&quot;en&quot;,&quot;default&quot;]"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>intel万兆网卡驱动简要分析 | pagefault</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">intel万兆网卡驱动简要分析</h1><a id="logo" href="/.">pagefault</a><p class="description">但行好事 莫問前程</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">intel万兆网卡驱动简要分析</h1><div class="post-meta">Jun 30, 2012<span> | </span><span class="category"><a href="/categories/kernel/">kernel</a></span></div><div class="post-content"><p>这里分析的驱动代码是给予linux kernel 3.4.4</p>
<p>对应的文件在drivers/net/ethernet/intel 目录下，这个分析不涉及到很细节的地方，主要目的是理解下数据在协议栈和驱动之间是如何交互的。</p>
<p>首先我们知道网卡都是pci设备，因此这里每个网卡驱动其实就是一个pci驱动。并且intel这里是把好几个万兆网卡(82599/82598/x540)的驱动做在一起的。</p>
<p>首先我们来看对应的pci_driver的结构体，这里每个pci驱动都是一个pci_driver的结构体，而这里是多个万兆网卡共用这个结构体ixgbe_driver.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static struct pci_driver ixgbe_driver = &#123;</span><br><span class="line">	  </span><br><span class="line">.name = ixgbe_driver_name,</span><br><span class="line">	  </span><br><span class="line">.id_table = ixgbe_pci_tbl,</span><br><span class="line">	  </span><br><span class="line">.probe = ixgbe_probe,</span><br><span class="line">	  </span><br><span class="line">.remove = __devexit_p(ixgbe_remove),</span><br><span class="line">  </span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">	  </span><br><span class="line">.suspend = ixgbe_suspend,</span><br><span class="line">	  </span><br><span class="line">.resume = ixgbe_resume,</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">	  </span><br><span class="line">.shutdown = ixgbe_shutdown,</span><br><span class="line">	  </span><br><span class="line">.err_handler = &amp;ixgbe_err_handler</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>然后是模块初始化方法,这里其实很简单，就是调用pci的驱动注册方法，把ixgbe挂载到pci设备链中。 这里不对pci设备的初始化做太多介绍，我以前的blog有这方面的介绍，想了解的可以去看看。这里我们只需要知道最终内核会调用probe回调来初始化ixgbe。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">char ixgbe_driver_name[] = &quot;ixgbe&quot;;</span><br><span class="line">  </span><br><span class="line">static const char ixgbe_driver_string[] =</span><br><span class="line">			        </span><br><span class="line">&quot;Intel(R) 10 Gigabit PCI Express Network Driver&quot;;</span><br><span class="line"></span><br><span class="line">static int __init ixgbe_init_module(void)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">int ret;</span><br><span class="line">	  </span><br><span class="line">pr_info(&quot;%s &amp;#8211; version %s\n&quot;, ixgbe_driver_string, ixgbe_driver_version);</span><br><span class="line">	  </span><br><span class="line">pr_info(&quot;%s\n&quot;, ixgbe_copyright);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_IXGBE_DCA</span><br><span class="line">	  </span><br><span class="line">dca_register_notify(&amp;dca_notifier);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">ret = pci_register_driver(&amp;ixgbe_driver);</span><br><span class="line">	  </span><br><span class="line">return ret;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不去追究具体如何调用probe的细节，我们直接来看probe函数，这个函数中通过硬件的信息来确定需要初始化那个驱动(82598/82599/x540),然后核心的驱动结构就放在下面的这个数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static const struct ixgbe_info *ixgbe_info_tbl[] = &#123;</span><br><span class="line">	  </span><br><span class="line">[board_82598] = &amp;ixgbe_82598_info,</span><br><span class="line">	  </span><br><span class="line">[board_82599] = &amp;ixgbe_82599_info,</span><br><span class="line">	  </span><br><span class="line">[board_X540] = &amp;ixgbe_X540_info,</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ixgbe_probe函数很长，我们这里就不详细分析了，因为这部分就是对网卡进行初始化。不过我们关注下面几个代码片段。</p>
<p>首先是根据硬件的参数来取得对应的驱动值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">const struct ixgbe_info *ii = ixgbe_info_tbl[ent-&gt;driver_data];</span><br></pre></td></tr></table></figure>
<p>然后就是如何将不同的网卡驱动挂载到对应的回调中，这里做的很简单，就是通过对应的netdev的结构取得adapter，然后所有的核心操作都是保存在adapter中的，最后将ii的所有回调拷贝给adapter就可以了。我们来看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">struct net_device *netdev;</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_adapter *adapter = NULL;</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_hw *hw;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line"></span><br><span class="line">adapter = netdev_priv(netdev);</span><br><span class="line">	  </span><br><span class="line">pci_set_drvdata(pdev, adapter);</span><br><span class="line"></span><br><span class="line">adapter-&gt;netdev = netdev;</span><br><span class="line">	  </span><br><span class="line">adapter-&gt;pdev = pdev;</span><br><span class="line">	  </span><br><span class="line">hw = &amp;adapter-&gt;hw;</span><br><span class="line">	  </span><br><span class="line">hw-&gt;back = adapter;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">	  </span><br><span class="line">memcpy(&amp;hw-&gt;mac.ops, ii-&gt;mac_ops, sizeof(hw-&gt;mac.ops));</span><br><span class="line">	  </span><br><span class="line">hw-&gt;mac.type = ii-&gt;mac;</span><br><span class="line"></span><br><span class="line">/\* EEPROM \*/</span><br><span class="line">	  </span><br><span class="line">memcpy(&amp;hw-&gt;eeprom.ops, ii-&gt;eeprom_ops, sizeof(hw-&gt;eeprom.ops));</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br></pre></td></tr></table></figure>
<p>最后需要关注的就是设置网卡属性，这些属性一般来说都是通过ethtool 可以设置的属性(比如tso/checksum等),这里我们就截取一部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">netdev-&gt;features = NETIF_F_SG |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_IP_CSUM |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_IPV6_CSUM |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_HW_VLAN_TX |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_HW_VLAN_RX |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_HW_VLAN_FILTER |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_TSO |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_TSO6 |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_RXHASH |</span><br><span class="line">			     </span><br><span class="line">NETIF_F_RXCSUM;</span><br><span class="line"></span><br><span class="line">netdev-&gt;hw_features = netdev-&gt;features;</span><br><span class="line"></span><br><span class="line">switch (adapter-&gt;hw.mac.type) &#123;</span><br><span class="line">	  </span><br><span class="line">case ixgbe_mac_82599EB:</span><br><span class="line">	  </span><br><span class="line">case ixgbe_mac_X540:</span><br><span class="line">		  </span><br><span class="line">netdev-&gt;features |= NETIF_F_SCTP_CSUM;</span><br><span class="line">		  </span><br><span class="line">netdev-&gt;hw_features |= NETIF_F_SCTP_CSUM |</span><br><span class="line">				         </span><br><span class="line">NETIF_F_NTUPLE;</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">	  </span><br><span class="line">default:</span><br><span class="line">		  </span><br><span class="line">break;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">netdev-&gt;hw_features |= NETIF_F_RXALL;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line"></span><br><span class="line">netdev-&gt;priv_flags |= IFF_UNICAST_FLT;</span><br><span class="line">	  </span><br><span class="line">netdev-&gt;priv_flags |= IFF_SUPP_NOFCS;</span><br><span class="line"></span><br><span class="line">if (adapter-&gt;flags &amp; IXGBE_FLAG_SRIOV_ENABLED)</span><br><span class="line">		  </span><br><span class="line">adapter-&gt;flags &amp;= ~(IXGBE_FLAG_RSS_ENABLED |</span><br><span class="line">				      </span><br><span class="line">IXGBE_FLAG_DCB_ENABLED);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">	  </span><br><span class="line">if (pci_using_dac) &#123;</span><br><span class="line">		  </span><br><span class="line">netdev-&gt;features |= NETIF_F_HIGHDMA;</span><br><span class="line">		  </span><br><span class="line">netdev-&gt;vlan_features |= NETIF_F_HIGHDMA;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_CAPABLE)</span><br><span class="line">		  </span><br><span class="line">netdev-&gt;hw_features |= NETIF_F_LRO;</span><br><span class="line">	  </span><br><span class="line">if (adapter-&gt;flags2 &amp; IXGBE_FLAG2_RSC_ENABLED)</span><br><span class="line">		  </span><br><span class="line">netdev-&gt;features |= NETIF_F_LRO;</span><br></pre></td></tr></table></figure>
<p>然后我们来看下中断的注册，因为万兆网卡大部分都是多对列网卡(配合msix)，因此对于上层软件来说，就好像有多个网卡一样，它们之间的数据是相互独立的，这里读的话主要是napi驱动的poll方法，后面我们会分析这个.</p>
<p>到了这里或许要问那么网卡是如何挂载回调给上层，从而上层来发送数据呢，这里是这样子的，每个网络设备都有一个回调函数表(比如ndo_start_xmit)来供上层调用，而在ixgbe中的话，就是ixgbe_netdev_ops，下面就是这个结构，不过只是截取了我们很感兴趣的几个地方.</p>
<p>不过这里注意，读回调并不在里面，这是因为写是软件主动的，而读则是硬件主动的。现在ixgbe是NAPI的，因此它的poll回调是ixgbe_poll，是中断注册时候通过netif_napi_add添加进去的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static const struct net_device_ops ixgbe_netdev_ops = &#123;</span><br><span class="line">	  </span><br><span class="line">.ndo_open = ixgbe_open,</span><br><span class="line">	  </span><br><span class="line">.ndo_stop = ixgbe_close,</span><br><span class="line">	  </span><br><span class="line">.ndo_start_xmit = ixgbe_xmit_frame,</span><br><span class="line">	  </span><br><span class="line">.ndo_select_queue = ixgbe_select_queue,</span><br><span class="line">	  </span><br><span class="line">.ndo_set_rx_mode = ixgbe_set_rx_mode,</span><br><span class="line">	  </span><br><span class="line">.ndo_validate_addr = eth_validate_addr,</span><br><span class="line">	  </span><br><span class="line">.ndo_set_mac_address = ixgbe_set_mac,</span><br><span class="line">	  </span><br><span class="line">.ndo_change_mtu = ixgbe_change_mtu,</span><br><span class="line">	  </span><br><span class="line">.ndo_tx_timeout = ixgbe_tx_timeout,</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">	  </span><br><span class="line">.ndo_set_features = ixgbe_set_features,</span><br><span class="line">	  </span><br><span class="line">.ndo_fix_features = ixgbe_fix_features,</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里我们最关注的其实就是ndo_start_xmit回调，这个回调就是驱动提供给协议栈的发送回调接口。我们来看这个函数.</p>
<p>它的实现很简单，就是选取对应的队列，然后调用ixgbe_xmit_frame_ring来发送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static netdev_tx_t ixgbe_xmit_frame(struct sk_buff *skb,</span><br><span class="line">				      </span><br><span class="line">struct net_device *netdev)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_adapter *adapter = netdev_priv(netdev);</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_ring *tx_ring;</span><br><span class="line"></span><br><span class="line">if (skb-&gt;len &lt;= 0) &#123;</span><br><span class="line">		  </span><br><span class="line">dev_kfree_skb_any(skb);</span><br><span class="line">		  </span><br><span class="line">return NETDEV_TX_OK;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">	   </span><br><span class="line">* The minimum packet size for olinfo paylen is 17 so pad the skb</span><br><span class="line">	   </span><br><span class="line">* in order to meet this minimum size requirement.</span><br><span class="line">	   </span><br><span class="line">*/</span><br><span class="line">	  </span><br><span class="line">if (skb-&gt;len &lt; 17) &#123;</span><br><span class="line">		  </span><br><span class="line">if (skb_padto(skb, 17))</span><br><span class="line">			  </span><br><span class="line">return NETDEV_TX_OK;</span><br><span class="line">		  </span><br><span class="line">skb-&gt;len = 17;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//取得对应的队列</span><br><span class="line">	  </span><br><span class="line">tx_ring = adapter-&gt;tx_ring[skb-&gt;queue_mapping];</span><br><span class="line">  </span><br><span class="line">//发送数据</span><br><span class="line">	  </span><br><span class="line">return ixgbe_xmit_frame_ring(skb, adapter, tx_ring);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在ixgbe_xmit_frame_ring中，我们就关注两个地方，一个是tso(什么是TSO，请自行google)，一个是如何发送.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">tso = ixgbe_tso(tx_ring, first, &amp;hdr_len);</span><br><span class="line">	  </span><br><span class="line">if (tso &lt; 0)</span><br><span class="line">		  </span><br><span class="line">goto out_drop;</span><br><span class="line">	  </span><br><span class="line">else if (!tso)</span><br><span class="line">		  </span><br><span class="line">ixgbe_tx_csum(tx_ring, first);</span><br><span class="line"></span><br><span class="line">/\* add the ATR filter if ATR is on \*/</span><br><span class="line">	  </span><br><span class="line">if (test_bit(__IXGBE_TX_FDIR_INIT_DONE, &amp;tx_ring-&gt;state))</span><br><span class="line">		  </span><br><span class="line">ixgbe_atr(tx_ring, first);</span><br><span class="line"></span><br><span class="line">#ifdef IXGBE_FCOE</span><br><span class="line">  </span><br><span class="line">xmit_fcoe:</span><br><span class="line">  </span><br><span class="line">#endif /\* IXGBE_FCOE \*/</span><br><span class="line">	  </span><br><span class="line">ixgbe_tx_map(tx_ring, first, hdr_len);</span><br></pre></td></tr></table></figure>
<p>调用ixgbe_tso处理完tso之后，就会调用ixgbe_tx_map来发送数据。而ixgbe_tx_map所做的最主要是两步，第一步请求DMA，第二步写寄存器，通知网卡发送数据.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">	  </span><br><span class="line">dma = dma_map_single(tx_ring-&gt;dev, skb-&gt;data, size, DMA_TO_DEVICE);</span><br><span class="line">	  </span><br><span class="line">if (dma_mapping_error(tx_ring-&gt;dev, dma))</span><br><span class="line">		  </span><br><span class="line">goto dma_error;</span><br><span class="line"></span><br><span class="line">/\* record length, and DMA address \*/</span><br><span class="line">	  </span><br><span class="line">dma_unmap_len_set(first, len, size);</span><br><span class="line">	  </span><br><span class="line">dma_unmap_addr_set(first, dma, dma);</span><br><span class="line"></span><br><span class="line">tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma);</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">		  </span><br><span class="line">while (unlikely(size &gt; IXGBE_MAX_DATA_PER_TXD)) &#123;</span><br><span class="line">			  </span><br><span class="line">tx_desc-&gt;read.cmd_type_len =</span><br><span class="line">				  </span><br><span class="line">cmd_type | cpu_to_le32(IXGBE_MAX_DATA_PER_TXD);</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">			  </span><br><span class="line">tx_desc++;</span><br><span class="line">			  </span><br><span class="line">if (i == tx_ring-&gt;count) &#123;</span><br><span class="line">				  </span><br><span class="line">tx_desc = IXGBE_TX_DESC(tx_ring, 0);</span><br><span class="line">				  </span><br><span class="line">i = 0;</span><br><span class="line">			  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dma += IXGBE_MAX_DATA_PER_TXD;</span><br><span class="line">			  </span><br><span class="line">size -= IXGBE_MAX_DATA_PER_TXD;</span><br><span class="line"></span><br><span class="line">tx_desc-&gt;read.buffer_addr = cpu_to_le64(dma);</span><br><span class="line">			  </span><br><span class="line">tx_desc-&gt;read.olinfo_status = 0;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">		  </span><br><span class="line">data_len -= size;</span><br><span class="line"></span><br><span class="line">dma = skb_frag_dma_map(tx_ring-&gt;dev, frag, 0, size,</span><br><span class="line">				         </span><br><span class="line">DMA_TO_DEVICE);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line"></span><br><span class="line">frag++;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;</span><br><span class="line">	  </span><br><span class="line">tx_ring-&gt;next_to_use = i;</span><br><span class="line"></span><br><span class="line">/\* notify HW of packet \*/</span><br><span class="line">	  </span><br><span class="line">writel(i, tx_ring-&gt;tail);</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br></pre></td></tr></table></figure>
<p>上面的操作是异步的，也就是说此时内核还不能释放SKB，而是网卡硬件发送完数据之后，会再次产生中断通知内核，然后内核才能释放内存.接下来我们来看这部分代码。</p>
<p>首先来看的是中断注册的代码，这里我们假设启用了MSIX,那么网卡的中断注册回调就是ixgbe_request_msix_irqs函数，这里我们可以看到调用request_irq函数来注册回调，并且每个队列都有自己的中断号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct net_device *netdev = adapter-&gt;netdev;</span><br><span class="line">	  </span><br><span class="line">int q_vectors = adapter-&gt;num_msix_vectors &amp;#8211; NON_Q_VECTORS;</span><br><span class="line">	  </span><br><span class="line">int vector, err;</span><br><span class="line">	  </span><br><span class="line">int ri = 0, ti = 0;</span><br><span class="line"></span><br><span class="line">for (vector = 0; vector &lt; q_vectors; vector++) &#123;</span><br><span class="line">		  </span><br><span class="line">struct ixgbe_q_vector *q_vector = adapter-&gt;q_vector[vector];</span><br><span class="line">		  </span><br><span class="line">struct msix_entry *entry = &amp;adapter-&gt;msix_entries[vector];</span><br><span class="line">  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;..</span><br><span class="line">		  </span><br><span class="line">err = request_irq(entry-&gt;vector, &amp;ixgbe_msix_clean_rings, 0,</span><br><span class="line">				    </span><br><span class="line">q_vector-&gt;name, q_vector);</span><br><span class="line">		  </span><br><span class="line">if (err) &#123;</span><br><span class="line">			  </span><br><span class="line">e_err(probe, &quot;request_irq failed for MSIX interrupt &quot;</span><br><span class="line">			        </span><br><span class="line">&quot;Error: %d\n&quot;, err);</span><br><span class="line">			  </span><br><span class="line">goto free_queue_irqs;</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">		  </span><br><span class="line">/\* If Flow Director is enabled, set interrupt affinity \*/</span><br><span class="line">		  </span><br><span class="line">if (adapter-&gt;flags &amp; IXGBE_FLAG_FDIR_HASH_CAPABLE) &#123;</span><br><span class="line">			  </span><br><span class="line">/\* assign the mask for this irq \*/</span><br><span class="line">			  </span><br><span class="line">irq_set_affinity_hint(entry-&gt;vector,</span><br><span class="line">					        </span><br><span class="line">&amp;q_vector-&gt;affinity_mask);</span><br><span class="line">		  </span><br><span class="line">&#125;</span><br><span class="line">	  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">free_queue_irqs:</span><br><span class="line">	  </span><br><span class="line">&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;&amp;#8230;.</span><br><span class="line">	  </span><br><span class="line">return err;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对应的中断回调是ixgbe_msix_clean_rings,而这个函数呢，做的事情很简单(需要熟悉NAPI的原理，我以前的blog有介绍),就是调用napi_schedule来重新加入软中断处理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">static irqreturn_t ixgbe_msix_clean_rings(int irq, void *data)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_q_vector *q_vector = data;</span><br><span class="line"></span><br><span class="line">/\* EIAM disabled interrupts (on this vector) for us \*/</span><br><span class="line"></span><br><span class="line">if (q_vector-&gt;rx.ring || q_vector-&gt;tx.ring)</span><br><span class="line">		  </span><br><span class="line">napi_schedule(&amp;q_vector-&gt;napi);</span><br><span class="line"></span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而NAPI驱动我们知道，最终是会调用网卡驱动挂载的poll回调，在ixgbe中，对应的回调就是ixgbe_poll，那么也就是说这个函数要做两个工作，一个是处理读，一个是处理写完之后的清理.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">int ixgbe_poll(struct napi_struct *napi, int budget)</span><br><span class="line">  </span><br><span class="line">&#123;</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_q_vector *q_vector =</span><br><span class="line">				  </span><br><span class="line">container_of(napi, struct ixgbe_q_vector, napi);</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_adapter *adapter = q_vector-&gt;adapter;</span><br><span class="line">	  </span><br><span class="line">struct ixgbe_ring *ring;</span><br><span class="line">	  </span><br><span class="line">int per_ring_budget;</span><br><span class="line">	  </span><br><span class="line">bool clean_complete = true;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_IXGBE_DCA</span><br><span class="line">	  </span><br><span class="line">if (adapter-&gt;flags &amp; IXGBE_FLAG_DCA_ENABLED)</span><br><span class="line">		  </span><br><span class="line">ixgbe_update_dca(q_vector);</span><br><span class="line">  </span><br><span class="line">#endif</span><br><span class="line">  </span><br><span class="line">//清理写</span><br><span class="line">	  </span><br><span class="line">ixgbe_for_each_ring(ring, q_vector-&gt;tx)</span><br><span class="line">		  </span><br><span class="line">clean_complete &amp;= !!ixgbe_clean_tx_irq(q_vector, ring);</span><br><span class="line"></span><br><span class="line">/* attempt to distribute budget to each queue fairly, but don&amp;#8217;t allow</span><br><span class="line">	   </span><br><span class="line">\* the budget to go below 1 because we&amp;#8217;ll exit polling \*/</span><br><span class="line">	  </span><br><span class="line">if (q_vector-&gt;rx.count &gt; 1)</span><br><span class="line">		  </span><br><span class="line">per_ring_budget = max(budget/q_vector-&gt;rx.count, 1);</span><br><span class="line">	  </span><br><span class="line">else</span><br><span class="line">		  </span><br><span class="line">per_ring_budget = budget;</span><br><span class="line">  </span><br><span class="line">//读数据，并清理已完成的</span><br><span class="line">	  </span><br><span class="line">ixgbe_for_each_ring(ring, q_vector-&gt;rx)</span><br><span class="line">		  </span><br><span class="line">clean_complete &amp;= ixgbe_clean_rx_irq(q_vector, ring,</span><br><span class="line">						       </span><br><span class="line">per_ring_budget);</span><br><span class="line"></span><br><span class="line">/\* If all work not completed, return budget and keep polling \*/</span><br><span class="line">	  </span><br><span class="line">if (!clean_complete)</span><br><span class="line">		  </span><br><span class="line">return budget;</span><br><span class="line"></span><br><span class="line">/\* all work done, exit the polling mode \*/</span><br><span class="line">	  </span><br><span class="line">napi_complete(napi);</span><br><span class="line">	  </span><br><span class="line">if (adapter-&gt;rx_itr_setting &amp; 1)</span><br><span class="line">		  </span><br><span class="line">ixgbe_set_itr(q_vector);</span><br><span class="line">	  </span><br><span class="line">if (!test_bit(__IXGBE_DOWN, &amp;adapter-&gt;state))</span><br><span class="line">		  </span><br><span class="line">ixgbe_irq_enable_queues(adapter, ((u64)1 &lt;&lt; q_vector-&gt;v_idx));</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tags"><a href="/tags/kernel/">kernel</a><a href="/tags/network/">network</a></div><div class="post-nav"><a class="pre" href="/2012/07/03/an-out-of-socket-memory-problem.html">一个out of socket memory的问题</a><a class="next" href="/2012/05/30/mochiweb-source-code-analysis-(2).html">mochiweb源码分析(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/">SPDY</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/SPDY/协议/">协议</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/">erlang</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/erlang/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/">kernel</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/mac/">mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/server/">server</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/kernel/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/lua/源码阅读/">源码阅读</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/">server</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/server/源码阅读/">源码阅读</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/协议/">协议</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言规范/">语言规范</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rocksdb/" style="font-size: 15px;">rocksdb</a> <a href="/tags/kernel/" style="font-size: 15px;">kernel</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/opensource/" style="font-size: 15px;">opensource</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/server/" style="font-size: 15px;">server</a> <a href="/tags/mac/" style="font-size: 15px;">mac</a> <a href="/tags/aio/" style="font-size: 15px;">aio</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/process/" style="font-size: 15px;">process</a> <a href="/tags/qemu/" style="font-size: 15px;">qemu</a> <a href="/tags/google/" style="font-size: 15px;">google</a> <a href="/tags/协议/" style="font-size: 15px;">协议</a> <a href="/tags/路由/" style="font-size: 15px;">路由</a> <a href="/tags/tcp/" style="font-size: 15px;">tcp</a> <a href="/tags/TFO/" style="font-size: 15px;">TFO</a> <a href="/tags/rfc/" style="font-size: 15px;">rfc</a> <a href="/tags/c/" style="font-size: 15px;">c</a> <a href="/tags/语言规范/" style="font-size: 15px;">语言规范</a> <a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/spdy/" style="font-size: 15px;">spdy</a> <a href="/tags/kenel/" style="font-size: 15px;">kenel</a> <a href="/tags/tcp-ip/" style="font-size: 15px;">tcp/ip</a> <a href="/tags/sever/" style="font-size: 15px;">sever</a> <a href="/tags/cache/" style="font-size: 15px;">cache</a> <a href="/tags/fs/" style="font-size: 15px;">fs</a> <a href="/tags/rfs/" style="font-size: 15px;">rfs</a> <a href="/tags/congest/" style="font-size: 15px;">congest</a> <a href="/tags/web-server/" style="font-size: 15px;">web server</a> <a href="/tags/tcp-cork/" style="font-size: 15px;">tcp_cork</a> <a href="/tags/服务器设计/" style="font-size: 15px;">服务器设计</a> <a href="/tags/keepalive/" style="font-size: 15px;">keepalive</a> <a href="/tags/pipeline/" style="font-size: 15px;">pipeline</a> <a href="/tags/server，mm/" style="font-size: 15px;">server，mm</a> <a href="/tags/epoll/" style="font-size: 15px;">epoll</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/mochiweb/" style="font-size: 15px;">mochiweb</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/loadbalance/" style="font-size: 15px;">loadbalance</a> <a href="/tags/InnoDB/" style="font-size: 15px;">InnoDB</a> <a href="/tags/glibc/" style="font-size: 15px;">glibc</a> <a href="/tags/systemcall/" style="font-size: 15px;">systemcall</a> <a href="/tags/心情/" style="font-size: 15px;">心情</a> <a href="/tags/gro/" style="font-size: 15px;">gro</a> <a href="/tags/gc/" style="font-size: 15px;">gc</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/04/18/design-and-implementation-of-mtr-(mini-transaction).html">MTR(mini-transaction)设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/17/design-and-implementation-of-linkbuf-in-innodb.html">InnoDB中LinkBuf设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/17/innodb-tablespace-source-code-analysis.html">InnoDB tablespace源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/19/.html">MySQL · RocksDB · 数据的读取(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/13/mysql-rocksdb.-data-reading-(i).html">MySQL · RocksDB · 数据的读取(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/27/mysql-rocksdb-level-compact-analysis.html">MySQL · RocksDB · Level Compact 分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/07/mysql-rocksdb-memtable-flush-analysis.html">MySQL · RocksDB · Memtable flush分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/writing-of-mysql.-rocksdb.-memtable.html">MySQL · RocksDB ·  MemTable的写入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/04/implementation-of-mysql-rocksdb-writing-logic.html">MySQL · RocksDB ·  写入逻辑的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/introduction-to-mysql-rocksdb-column-family.html">MySQL · RocksDB · Column Family介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">pagefault.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>